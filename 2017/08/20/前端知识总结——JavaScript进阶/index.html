<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaScript,面向对象," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="是时候展现真正的技术了，来探索JavaScript的海洋，一切才刚刚开始。">
<meta name="keywords" content="JavaScript,面向对象">
<meta property="og:type" content="article">
<meta property="og:title" content="前端知识总结——JavaScript进阶">
<meta property="og:url" content="http://din-binbin.coding.me/2017/08/20/前端知识总结——JavaScript进阶/index.html">
<meta property="og:site_name" content="Thinking Coding">
<meta property="og:description" content="是时候展现真正的技术了，来探索JavaScript的海洋，一切才刚刚开始。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-09-25T17:37:43.067Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端知识总结——JavaScript进阶">
<meta name="twitter:description" content="是时候展现真正的技术了，来探索JavaScript的海洋，一切才刚刚开始。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://din-binbin.coding.me/2017/08/20/前端知识总结——JavaScript进阶/"/>





  <title>前端知识总结——JavaScript进阶 | Thinking Coding</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Thinking Coding</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://din-binbin.coding.me/2017/08/20/前端知识总结——JavaScript进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="白发渔樵">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thinking Coding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端知识总结——JavaScript进阶</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T02:49:46+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>是时候展现真正的技术了，来探索JavaScript的海洋，一切才刚刚开始。<br><a id="more"></a></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>既然是面向对象，那么，对象是什么，怎么创建对象？</p>
<p>通俗地说，对象是抽象的，实例是具体的。</p>
<hr>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 采用工厂模式批量产出很多类似的对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatBottle</span>(<span class="params">name,price,isKeepWarm</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        name:name,</div><div class="line">        price:price,</div><div class="line">        isKeepWarm:isKeepWarm</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bottle1=creatBottle(<span class="string">'bottle1'</span>,<span class="number">29</span>,<span class="literal">false</span>);</div><div class="line"><span class="keyword">var</span> bottle2=creatBottle(<span class="string">'bottle2'</span>,<span class="number">39</span>,<span class="literal">true</span>);</div><div class="line"><span class="keyword">var</span> bottle3=creatBottle(<span class="string">'bottle3'</span>,<span class="number">49</span>,<span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>这样的黑盒方式，类似工厂的流水线，因此称为工厂模式。</p>
<p>但是，工厂模式有一个问题：怎么证明<code>bottle1</code>是<code>Bottle</code>？</p>
<hr>
<h1 id="函数再探索"><a href="#函数再探索" class="headerlink" title="函数再探索"></a>函数再探索</h1><p>函数相关的，包括<code>arguments</code>、<code>this</code>、<code>name</code>、<code>length</code>、<code>prototype</code>、<code>apply()</code>、<code>bind()</code>、<code>calss()</code>等。</p>
<h2 id="函数的arguments"><a href="#函数的arguments" class="headerlink" title="函数的arguments"></a>函数的arguments</h2><p><code>arguments</code>是一个对象，类数组，具有length属性，保存了函数的参数。</p>
<p><code>arguments</code>非常是个动态参数的场景。</p>
<h2 id="函数的this"><a href="#函数的this" class="headerlink" title="函数的this"></a>函数的this</h2><p><code>this</code>其实就是执行环境，比如js代码在浏览器执行，浏览器在系统上执行，执行环境就是运行时的宿主环境。函数的<code>this</code>就是函数的执行环境。</p>
<ul>
<li>一般情况，如果函数在全局作用域下，那么this一般指向window</li>
<li>一般情况，如果是某个对象的方法，那么this一般指向该对象</li>
</ul>
<p>注：this不是在定义的时候确定的，而是在调用的时候，切记。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.name=<span class="string">'windows'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">    name:<span class="string">'hahaha'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayName();</div><div class="line"><span class="comment">// 此时的`this`在全局作用域下，指向`window`，因此`name`为`windows`</span></div><div class="line"></div><div class="line">obj.sayName=sayName;</div><div class="line">obj.sayName();</div><div class="line"><span class="comment">// 此时的`this`是对象的方法，指向对象，因此`name`为`hahaha`</span></div></pre></td></tr></table></figure>
<h2 id="函数的常用方法"><a href="#函数的常用方法" class="headerlink" title="函数的常用方法"></a>函数的常用方法</h2><p>函数的<code>bind()</code>、<code>call()</code>、<code>apply()</code>方法可以用来改变<code>this</code>的指向，也就是改变函数的执行环境。</p>
<ul>
<li><p><code>bind()</code></p>
<p><code>bind</code>会创建一个新函数，称为绑定函数，当调用这个函数的时候，绑定函数会以创建它时传入<code>bind()</code>方法的第一个参数作为<code>this</code>，传入<code>bind()</code>方法的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数；</p>
</li>
<li><p><code>call()</code>和<code>apply()</code></p>
<p>都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部this的指向）。<code>this</code>指向他们的第一个参数，<code>apply</code>的第二个参数是一个参数数组，<code>call</code>的第二个及其以后的参数都是数组里面的元素，就是说要全部列举出来。</p>
</li>
</ul>
<p><code>bind</code>与<code>apply</code>、<code>call</code>最大的区别就是：<code>bind</code>不会立即调用，其他两个会立即调用。</p>
<h2 id="函数的常用属性"><a href="#函数的常用属性" class="headerlink" title="函数的常用属性"></a>函数的常用属性</h2><ul>
<li>name —— 函数名</li>
<li><p>length —— 参数的个数</p>
<p>注：<code>length</code>是定义时就确定的形参的个数，而<code>arguments.length</code>是实际参数的个数</p>
</li>
<li><p>prototype —— 原型对象</p>
</li>
</ul>
<hr>
<h1 id="跨语言的数据类型分类"><a href="#跨语言的数据类型分类" class="headerlink" title="跨语言的数据类型分类"></a>跨语言的数据类型分类</h1><h2 id="First-Class"><a href="#First-Class" class="headerlink" title="First Class"></a>First Class</h2><p>可以作为函数的参数和返回值，也可以赋值给变量</p>
<h2 id="Second-Class"><a href="#Second-Class" class="headerlink" title="Second Class"></a>Second Class</h2><p>可以作为函数的参数，但不能从函数返回，也不能赋值给变量</p>
<h2 id="Third-Class"><a href="#Third-Class" class="headerlink" title="Third Class"></a>Third Class</h2><p>不能作为函数的参数</p>
<hr>
<h1 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包 closure"></a>闭包 closure</h1><p>闭包是指有权访问另一个函数作用域中的变量的函数。 —— 《JavaScript高级程序设计》</p>
<h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>如果我们需要隐藏一些不应该被直接修改的数据，我们需要使用到私有变量和特权方法。那么什么是私有变量和特权方法呢？</p>
<ul>
<li>任何在函数中定义的变量，都可以认为是私有变量。因为不能在函数外部访问这些变量。</li>
<li>私有变量包括函数参数，局部变量以及在函数内部定义的其他函数。</li>
</ul>
<p>下面的代码,在这个函数内部，有三个私有变量 <code>param</code>、<code>privateVariable</code>、 <code>privateFunction</code>。在函数内部可以访问到这几个变量，但在函数外部则不能访问他们。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params">param</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> privateVariable = <span class="number">20</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 在函数外部无法直接访问到私有变量和方法</span></div></pre></td></tr></table></figure>
<h2 id="创建特权方法来访问私有变量"><a href="#创建特权方法来访问私有变量" class="headerlink" title="创建特权方法来访问私有变量"></a>创建特权方法来访问私有变量</h2><p>我们如果需要访问私有变量时，可以怎么做呢？我们可以在函数的内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，我们就可以创建用于访问私有变量的公有方法。</p>
<p>我们把有权访问私有变量和私有函数的公有方法称为特权方法。</p>
<p>如下面的代码，<code>publicMethod</code> 就是特权方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params">param</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> privateVariable = <span class="number">20</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">10</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 特权方法</span></div><div class="line">  <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      privateVariable ++;</div><div class="line">      <span class="keyword">return</span> privateFunction();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>如何证明一个对象是某个对象的实例？</p>
<h2 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>;</div></pre></td></tr></table></figure>
<h2 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h2><ul>
<li>首先会创建一个新对象，并将构造函数的<code>this</code>指向这个对象</li>
<li>然后通过构造函数，给新建对象赋值属性和属性值</li>
<li>最后返回这个新对象</li>
</ul>
<h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bottle</span>(<span class="params">name,price,isKeepWarm</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">    <span class="keyword">this</span>.price=price;</div><div class="line">    <span class="keyword">this</span>.isKeepWarm=isKeepWarm;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bottle=<span class="keyword">new</span> Bottle(<span class="string">'杯子'</span>,<span class="number">29</span>,<span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(bottle <span class="keyword">instanceof</span> Bottle);</div></pre></td></tr></table></figure>
<p>缺点；构造函数每次创建实例的时候都会创建相同逻辑的函数作为对象的方法，重复声明消耗空间。</p>
<hr>
<h1 id="原型prototype"><a href="#原型prototype" class="headerlink" title="原型prototype"></a>原型prototype</h1><p>原型是函数的一个属性，是一个对象。同一个构造函数生成的实例，都会共享同一个原型。</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 指向构造函数</span></div><div class="line"><span class="built_in">Object</span>.prototype.constructor===<span class="built_in">Object</span>;</div></pre></td></tr></table></figure>
<h2 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Bottle.protorype.name=<span class="string">'杯子'</span>;</div><div class="line"></div><div class="line">Bottle.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf"></a>isPrototypeOf</h2><p>用于检测实例与原型的指向关系。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bottle.prototype.isPrototypeOf(bottle);</div></pre></td></tr></table></figure>
<h2 id="原型共享的缺陷"><a href="#原型共享的缺陷" class="headerlink" title="原型共享的缺陷"></a>原型共享的缺陷</h2><p>修改引用数据类型的时候，会造成数据污染。</p>
<hr>
<h1 id="构造函数结合原型"><a href="#构造函数结合原型" class="headerlink" title="构造函数结合原型"></a>构造函数结合原型</h1><p>从之前的工厂模式到构造函数，再到原型，都存在一些缺陷，接下来我们将尽量避免这些缺陷。</p>
<h2 id="怎样结合扬长避短"><a href="#怎样结合扬长避短" class="headerlink" title="怎样结合扬长避短"></a>怎样结合扬长避短</h2><p>结合各个方法的优缺点，可以总结出如下的创建对象的方式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造函数独享属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bottle</span>(<span class="params">name,price,isKeepWarm</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">    <span class="keyword">this</span>.price=price;</div><div class="line">    <span class="keyword">this</span>.isKeepWarm;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 原型共享方法</span></div><div class="line">Bottle.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bottle=<span class="keyword">new</span> Bottle(<span class="string">'保温杯'</span>,<span class="number">111</span>,<span class="literal">true</span>);</div><div class="line"></div><div class="line">bottle.sayName();</div></pre></td></tr></table></figure>
<h2 id="属性的覆盖"><a href="#属性的覆盖" class="headerlink" title="属性的覆盖"></a>属性的覆盖</h2><p>如果<code>prototype</code>和构造函数定义了同样的属性，那么构造函数定义的会覆盖<code>prototype</code>上定义的，因为查找由远及近。</p>
<h2 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h2><p>判断实例中是否有某个属性，不管是在构造函数中定义的，还是挂在原型<code>prototype</code>上的。有则返回<code>true</code>，否则返回<code>false</code>。</p>
<h2 id="hasOwnProperty-方法"><a href="#hasOwnProperty-方法" class="headerlink" title="hasOwnProperty() 方法"></a>hasOwnProperty() 方法</h2><p>查看某个属性是在实例上还是在原型上。</p>
<hr>
<h1 id="经典的面向对象"><a href="#经典的面向对象" class="headerlink" title="经典的面向对象"></a>经典的面向对象</h1><p>所说的“经典的面向对象”，是有“类”这个概念的面向对象，比如 Java ，它就有“类”的概念。</p>
<p>面向对象这个概念，实在是太像我们的世界。</p>
<p>说道“人”，Person ，大家肯定是想到一个鼻子，两个眼睛，是一个宽泛的概念，可以让你想到任何人。</p>
<p>但是，“你我”又有区别，虽然都是人，但我叫 jero ，你叫刘德华，我很帅，你却更帅。在“人”这个大的类别下，你我是两个不同的实体，两个不同的对象，你我都是具象化的人，是一个具体的概念。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.legs = <span class="number">2</span>;</div><div class="line">       <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Person(<span class="string">'刘德华'</span>));</div></pre></td></tr></table></figure>
<p>虽然 JS 里面没有类的概念，但我们还是习惯叫“类”，而且不同的“类”有时候是有关系的，比如“人”是“动物”，这个时候，“人”就是子类，“动物”就是父类，也挺容易理解。</p>
<p>上面的 class Person 代码，也是 JS 代码，ES6 新增了类的语法，创建对象更容易了。</p>
<p>可参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">JavaScript的类 | MDN</a></p>
<p>更多关于ES6，可参考：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6 入门</a></p>
<hr>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承可以使其子类具有父类的属性和方法，而不需要重复编写相同的代码。</p>
<p>即 —— 父类包含共有属性和公用方法，子类再特殊化。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>子类实例指向子类原型，子类原型指向父类实例，而父类原型又指向父类实例。因此，通过原型链，可以形成一种链式查找，子类具有父类的属性和方法。</p>
<h2 id="原型链继承的不足"><a href="#原型链继承的不足" class="headerlink" title="原型链继承的不足"></a>原型链继承的不足</h2><ul>
<li>constructor指向问题<blockquote>
<p>可手动更改指向，使其正确</p>
</blockquote>
</li>
<li>属性共享问题<blockquote>
<p>引用类型共享问题</p>
</blockquote>
</li>
<li>参数<blockquote>
<p>子类不能定义自己的参数，会沿用父类</p>
</blockquote>
</li>
</ul>
<h2 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plane</span>(<span class="params">color</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.color=color;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fighter</span>(<span class="params">color</span>)</span>&#123;</div><div class="line">    Plane.call(<span class="keyword">this</span>,color);</div><div class="line">    <span class="keyword">this</span>.bullets=[];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fighter=<span class="keyword">new</span> Fighter(<span class="string">'blue'</span>);</div></pre></td></tr></table></figure>
<p>借用构造函数可以继承父类构造函数上的属性和方法。</p>
<p>但是，只借用构造函数不能继承原型上的属性和方法。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plane</span>(<span class="params">color</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.color=color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Plane.prototype.fly=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'flying'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fighter</span>(<span class="params">color</span>)</span>&#123;</div><div class="line">    Plane.call(<span class="keyword">this</span>,color);</div><div class="line">    <span class="keyword">this</span>.bullets=[];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Fighter.prototype=<span class="keyword">new</span> Plane();</div><div class="line">Fighter.prototype.constructor=Fighter;</div><div class="line"></div><div class="line">Fighter.prototype.shoot=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'biu biu biu'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fighter=<span class="keyword">new</span> Fighter(<span class="string">'blue'</span>);</div></pre></td></tr></table></figure>
<p>组合继承特点：</p>
<ul>
<li>属性和方法都是从父类继承的（代码复用）</li>
<li>继承的属性是私有的（互不影响）</li>
<li>继承的方法都在原型里（函数复用）</li>
</ul>
<p>继承组合的不足：</p>
<ul>
<li>两次调用父类的构造函数</li>
<li>属性冗余（子类的属性覆盖父类）</li>
</ul>
<h2 id="继承的最佳实践"><a href="#继承的最佳实践" class="headerlink" title="继承的最佳实践"></a>继承的最佳实践</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Fighter.prototype=<span class="keyword">new</span> Plane();</div></pre></td></tr></table></figure>
<p>上述这行代码的目的是想继承父类原型上的方法，但是同时也继承了父类实例的属性。可以使用一个函数，只继承原型而不继承父类实例属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>)</span>&#123;</div><div class="line">    <span class="comment">// 复制父类原型</span></div><div class="line">    <span class="keyword">var</span> prototype=<span class="built_in">Object</span>.creat(superType.prototype);</div><div class="line">    <span class="comment">// 修正constructor指向</span></div><div class="line">    prototype.constructor=subType;</div><div class="line">    <span class="comment">// 修改子类原型指向</span></div><div class="line">    subType.prototype=prototype;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，最佳实践代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plane</span>(<span class="params">color</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.color=color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Plane.prototype.fly=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'flying'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fighter</span>(<span class="params">color</span>)</span>&#123;</div><div class="line">    Plane.call(<span class="keyword">this</span>,color); <span class="comment">// 继承属性</span></div><div class="line">    <span class="keyword">this</span>.bullets=[];</div><div class="line">&#125;</div><div class="line"></div><div class="line">inheritPrototype(Fighter,Plane); <span class="comment">// 继承方法</span></div><div class="line"></div><div class="line">Fighter.prototype.shoot=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'biu biu biu'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fighter=<span class="keyword">new</span> Fighter(<span class="string">'blue'</span>);</div></pre></td></tr></table></figure>
<hr>
<h1 id="ES6中的继承"><a href="#ES6中的继承" class="headerlink" title="ES6中的继承"></a>ES6中的继承</h1><p>到目前为止，我们已经知道了 JS 中继承方式的最佳实践了。幸运的是，ES6 标准已经将 经典的 <code>class</code> 声明类和继承的方式纳入标准了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="comment">// 构造函数</span></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 方法</span></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 ES6 中继承是通过 <code>extends</code> 关键字声明的，比如下面 <code>Student</code> 类继承了 <code>Person</code> 类</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="comment">// 构造函数</span></div><div class="line">    <span class="keyword">constructor</span>(name, grade) &#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">        <span class="keyword">this</span>.grade = grade;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 方法</span></div><div class="line">    sayGrade() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`I am Grade <span class="subst">$&#123;<span class="keyword">this</span>.grade&#125;</span>`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面继承方式关键点其实就2个：一个是通过 <code>extends</code> 关键字声明继承关系，第二是在子类构造函数 <code>constructor</code> 中调用 <code>super</code> 函数，这其实就相当于我们的借用构造函数。要注意的点是 <code>constructor</code> 中 <code>this</code> 对象要 <code>super</code> 调用之后使用，不然会报错。</p>
<hr>
<h1 id="无处不在的继承"><a href="#无处不在的继承" class="headerlink" title="无处不在的继承"></a>无处不在的继承</h1><p>div 继承自 HTMLElement 继承自 Element 继承自 Node</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"> # JavaScript</a>
          
            <a href="/tags/面向对象/" rel="tag"> # 面向对象</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/16/前端知识总结——jQuery/" rel="next" title="前端知识总结——jQuery">
                <i class="fa fa-chevron-left"></i> 前端知识总结——jQuery
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/22/前端知识总结——神奇的canvas/" rel="prev" title="前端知识总结——神奇的canvas">
                前端知识总结——神奇的canvas <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="白发渔樵" />
          <p class="site-author-name" itemprop="name">白发渔樵</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#工厂模式"><span class="nav-number">2.</span> <span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数再探索"><span class="nav-number">3.</span> <span class="nav-text">函数再探索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的arguments"><span class="nav-number">3.1.</span> <span class="nav-text">函数的arguments</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的this"><span class="nav-number">3.2.</span> <span class="nav-text">函数的this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的常用方法"><span class="nav-number">3.3.</span> <span class="nav-text">函数的常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的常用属性"><span class="nav-number">3.4.</span> <span class="nav-text">函数的常用属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#跨语言的数据类型分类"><span class="nav-number">4.</span> <span class="nav-text">跨语言的数据类型分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#First-Class"><span class="nav-number">4.1.</span> <span class="nav-text">First Class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Second-Class"><span class="nav-number">4.2.</span> <span class="nav-text">Second Class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Third-Class"><span class="nav-number">4.3.</span> <span class="nav-text">Third Class</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#闭包-closure"><span class="nav-number">5.</span> <span class="nav-text">闭包 closure</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#私有变量"><span class="nav-number">5.1.</span> <span class="nav-text">私有变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建特权方法来访问私有变量"><span class="nav-number">5.2.</span> <span class="nav-text">创建特权方法来访问私有变量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造函数"><span class="nav-number">6.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#instanceof-操作符"><span class="nav-number">6.1.</span> <span class="nav-text">instanceof 操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-操作符"><span class="nav-number">6.2.</span> <span class="nav-text">new 操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数创建对象"><span class="nav-number">6.3.</span> <span class="nav-text">构造函数创建对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原型prototype"><span class="nav-number">7.</span> <span class="nav-text">原型prototype</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#constructor-NaN"><span class="nav-number">7.1.</span> <span class="nav-text">constructor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读写"><span class="nav-number">7.2.</span> <span class="nav-text">读写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isPrototypeOf-NaN"><span class="nav-number">7.3.</span> <span class="nav-text">isPrototypeOf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型共享的缺陷"><span class="nav-number">7.4.</span> <span class="nav-text">原型共享的缺陷</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造函数结合原型"><span class="nav-number">8.</span> <span class="nav-text">构造函数结合原型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#怎样结合扬长避短"><span class="nav-number">8.1.</span> <span class="nav-text">怎样结合扬长避短</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性的覆盖"><span class="nav-number">8.2.</span> <span class="nav-text">属性的覆盖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#in-操作符"><span class="nav-number">8.3.</span> <span class="nav-text">in 操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hasOwnProperty-方法"><span class="nav-number">8.4.</span> <span class="nav-text">hasOwnProperty() 方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#经典的面向对象"><span class="nav-number">9.</span> <span class="nav-text">经典的面向对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#继承"><span class="nav-number">10.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原型链"><span class="nav-number">10.1.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型链继承的不足"><span class="nav-number">10.2.</span> <span class="nav-text">原型链继承的不足</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#借用构造函数继承"><span class="nav-number">10.3.</span> <span class="nav-text">借用构造函数继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合继承"><span class="nav-number">10.4.</span> <span class="nav-text">组合继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承的最佳实践"><span class="nav-number">10.5.</span> <span class="nav-text">继承的最佳实践</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6中的继承"><span class="nav-number">11.</span> <span class="nav-text">ES6中的继承</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#无处不在的继承"><span class="nav-number">12.</span> <span class="nav-text">无处不在的继承</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">白发渔樵</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
