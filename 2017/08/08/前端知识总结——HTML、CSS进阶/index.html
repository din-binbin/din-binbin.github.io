<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="HTML,CSS," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="了解了HTML和CSS的基础知识后，就可以继续深入HTML和CSS的博大精深了。">
<meta name="keywords" content="HTML,CSS">
<meta property="og:type" content="article">
<meta property="og:title" content="前端知识总结——HTML、CSS进阶">
<meta property="og:url" content="http://binbin-io.github.io/2017/08/08/前端知识总结——HTML、CSS进阶/index.html">
<meta property="og:site_name" content="Thinking Coding">
<meta property="og:description" content="了解了HTML和CSS的基础知识后，就可以继续深入HTML和CSS的博大精深了。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://binbin-io.github.io/images/vfm.png">
<meta property="og:image" content="http://binbin-io.github.io/images/vfm-line-boxes.png">
<meta property="og:image" content="http://binbin-io.github.io/images/grids-excel.png">
<meta property="og:image" content="http://binbin-io.github.io/images/render-1.png">
<meta property="og:image" content="http://binbin-io.github.io/images/render-2.png">
<meta property="og:image" content="http://binbin-io.github.io/images/render-3.png">
<meta property="og:image" content="http://binbin-io.github.io/images/render-4.png">
<meta property="og:image" content="http://binbin-io.github.io/images/render-5.png">
<meta property="og:image" content="http://binbin-io.github.io/images/render-6.png">
<meta property="og:updated_time" content="2017-09-25T17:31:43.630Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端知识总结——HTML、CSS进阶">
<meta name="twitter:description" content="了解了HTML和CSS的基础知识后，就可以继续深入HTML和CSS的博大精深了。">
<meta name="twitter:image" content="http://binbin-io.github.io/images/vfm.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://binbin-io.github.io/2017/08/08/前端知识总结——HTML、CSS进阶/"/>





  <title>前端知识总结——HTML、CSS进阶 | Thinking Coding</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Thinking Coding</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://binbin-io.github.io/2017/08/08/前端知识总结——HTML、CSS进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="白发渔樵">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thinking Coding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端知识总结——HTML、CSS进阶</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-08T15:24:58+08:00">
                2017-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>了解了HTML和CSS的基础知识后，就可以继续深入HTML和CSS的博大精深了。<br><a id="more"></a></p>
<h1 id="HTML-CSS布局"><a href="#HTML-CSS布局" class="headerlink" title="HTML+CSS布局"></a>HTML+CSS布局</h1><p>这里引入一下古老的table布局方法：用表格定义天然的区块再填入内容来布局。缺点如下：</p>
<ul>
<li>加载慢，需等到表格加载完才显示。</li>
<li>HTML语义化</li>
</ul>
<p>表格之后，布局主要是div + CSS，并且导致div标签被滥用。</p>
<hr>
<h1 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h1><ul>
<li>方便团队开发</li>
<li>有利于SEO</li>
<li>对屏幕阅读软件友好</li>
</ul>
<p>HTML 语义当然不仅仅只是几个 HTML 语义标签。HTML 就是文档，最开始的《Web 简史》中有提到过，万维网的雏形是一个文档共享系统，万维网就是一个放大版的文档共享系统。只是随着 Web 的发展，各种酷炫的页面和应用层出不穷，倒是让新入行的小伙伴忽略了，HTML 的本质其实是文档（document）。</p>
<p>视觉上的各种酷炫会给人以视觉冲击，但对机器来说，并没有什么用，它们更看重的是语义，这样才能更好地解析内容。这也是为什么样式会从结构里面分离出来的原因之一。</p>
<p>可参考：<a href="https://segmentfault.com/a/1190000002695791" target="_blank" rel="external">深入理解HTML5标签</a></p>
<hr>
<h1 id="让-IE8-支持-HTML5-语义化标签"><a href="#让-IE8-支持-HTML5-语义化标签" class="headerlink" title="让 IE8 支持 HTML5 语义化标签"></a>让 IE8 支持 HTML5 语义化标签</h1><p>HTML5是 HTML 最新的修订版本，于2014年10月由万维网联盟（W3C）完成标准制定。而 IE8 面世时间为2009年3月19日，时间相差如此之大，所以 IE8 作为比较古老的浏览器，不支持 HTML 5 引入的语义化标签（如 <code>header</code>、<code>nav</code>、<code>menu</code>、<code>section</code>、<code>article</code> 等）。</p>
<h2 id="IE8-对-HTML5-标签的处理"><a href="#IE8-对-HTML5-标签的处理" class="headerlink" title="IE8 对 HTML5 标签的处理"></a>IE8 对 HTML5 标签的处理</h2><p>在 IE8 里面，未定义的标签——IE8 不认识所有新引入的 HTML5 标签，所以定义样式是不会生效。</p>
<h2 id="如何让-IE8-支持-HTML5-标签"><a href="#如何让-IE8-支持-HTML5-标签" class="headerlink" title="如何让 IE8 支持 HTML5 标签"></a>如何让 IE8 支持 HTML5 标签</h2><p>虽然默认不支持，但是我们可以通过 JS 使用 <code>document.createElement</code> 来“欺骗” IE 的 CSS 引擎，让它知道某个标签的存在，具体做法如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML5 test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="built_in">document</span>.createElement(<span class="string">'section'</span>);</span></div><div class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="css">        <span class="selector-tag">section</span> &#123; <span class="attribute">color</span>: red; &#125;</span></div><div class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></div><div class="line">        Hello!</div><div class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="借助-html5shiv-js-让IE8支持更多的HTML5特性"><a href="#借助-html5shiv-js-让IE8支持更多的HTML5特性" class="headerlink" title="借助 html5shiv.js 让IE8支持更多的HTML5特性"></a>借助 html5shiv.js 让IE8支持更多的HTML5特性</h2><p>其实不只是 IE8 ， IE6-9、 Safari 4.x (以及 iPhone 3.x)、还有Firefox 3.x 等等，对 HTML5 的支持都不完善。所以有了一个库<code>html5shiv.js</code> 来做统一处理，shiv 意为用作武器的小刀（实际上是一个拼写错误，应该为 shim），在机械工程中的专业释义为垫片，比喻给那些老旧的浏览器加个垫片，让它们基本能用。</p>
<p>可参考：<a href="https://github.com/aFarkas/html5shiv/" target="_blank" rel="external"><code>html5shiv.js</code></a></p>
<hr>
<h1 id="显示类型-display"><a href="#显示类型-display" class="headerlink" title="显示类型 display"></a>显示类型 display</h1><p>在HTML的元素显示时，有的是块级元素，有的是行内元素。</p>
<h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><ul>
<li><code>display:block</code></li>
<li><code>display:table</code></li>
<li><p><code>display:list-item</code></p>
</li>
<li><p>特征：</p>
<ul>
<li>每个元素另起一行</li>
<li>可设置宽高、行高、上下边距、左右边距</li>
</ul>
</li>
</ul>
<h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><ul>
<li><code>display:inline</code></li>
<li><p><code>display:inline-block</code></p>
</li>
<li><p>特征：</p>
<ul>
<li>和其他行内元素同一行</li>
<li>不可设置宽高、行高、上下边距，可设置左右边距</li>
</ul>
</li>
</ul>
<h2 id="Why？"><a href="#Why？" class="headerlink" title="Why？"></a>Why？</h2><p>这并非是由HTML定义的，而是由默认的css定义的，这也就意味着我们更改元素的显示类型<code>display</code>。</p>
<p>除了上述属性，<code>display</code>还有<code>flex</code>、<code>grid</code>属性，以及<code>inline-block</code>、<code>inline-flex</code>、<code>inline-grid</code>，后面再详细回顾。</p>
<hr>
<h1 id="视觉格式化模型（visual-formatting-model）"><a href="#视觉格式化模型（visual-formatting-model）" class="headerlink" title="视觉格式化模型（visual formatting model）"></a>视觉格式化模型（visual formatting model）</h1><p>前面我们已经学习了盒模型（box model），知道了元素会被渲染成一个个盒子。那么这些盒子在屏幕上的位置又是怎么放置的呢？这就是我们现在要学习的——CSS 视觉格式化模型(visual formatting model)。视觉格式化模型是 CSS 布局的一个基础理论体系。</p>
<h2 id="盒子的位置摆放"><a href="#盒子的位置摆放" class="headerlink" title="盒子的位置摆放"></a>盒子的位置摆放</h2><p>默认情况下，盒子按照元素在 HTML 中的先后位置从左至右自上而下一个接着一个排列摆放。</p>
<p><img src="/images/vfm.png" alt="默认盒子摆放"></p>
<p>在图中我们可以看到，有些元素的盒子被渲染为完整的一行，如h1、p、div；而有些元素的盒子则被渲染为水平排列，直到该行被占满然后换行，如span、a、strong。</p>
<p>这是因为不同的盒子使用的是不同的格式化上下文（formatting context）来布局，每个格式化上下文都拥有一套不同的渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。（就如我们参加结婚喜宴一样，有父母长辈席，好友席，同事席，甚至前男/女朋友席等，不同的身份坐到对应位置即可。）</p>
<h2 id="格式化上下文（formatting-context）"><a href="#格式化上下文（formatting-context）" class="headerlink" title="格式化上下文（formatting context）"></a>格式化上下文（formatting context）</h2><p>我们常见的两个格式化上下文分别为：块格式化上下文（block formatting context 简称 BFC）和行内格式化上下文（inline formatting context 简称 IFC）</p>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>块级盒（block-level boxes）：当元素的 CSS 属性 display 的计算值为 <code>block</code>，<code>list-item</code>，<code>table</code>，<code>flex</code> 或 <code>grid</code> 时，它是块级元素。视觉上呈现为块，竖直排列。典型的如 <code>&lt;div&gt;</code> 元素，<code>&lt;p&gt;</code> 元素等都是块级元素。</p>
<p>每个块级元素至少生成一个块级盒，称为主要块级盒(principal block-level box)。一些元素，比如<code>&lt;li&gt;</code>，生成额外的盒来放置项目符号，不过多数元素只生成一个主要块级盒。块级盒参与 BFC，被渲染为完整的一个新行。</p>
<p>默认根元素（html 元素）会创建一个 BFC，其块级盒子元素将会按照如下规则进行渲染：</p>
<ul>
<li>块级盒会在垂直方向，一个接一个地放置，每个盒子水平占满整个容器空间</li>
<li>块级盒的垂直方向距离由上下 <code>margin</code> 决定，同属于一个 BFC 中的两个或以上块级盒的相接的 <code>margin</code> 会发生重叠</li>
<li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</li>
<li>计算 BFC 的高度时，浮动元素也参与计算</li>
</ul>
<p>除此之外，还有其他方法可以创建一个新的 BFC，具体可参看：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="external">块格式化上下文 | MDN</a>。除此之外，<code>flexbox</code> 布局和 <code>grids</code> 布局中的 <code>item</code> 都会创建一个新的 BFC。</p>
<p>可参考：<a href="http://www.html-js.com/article/1866" target="_blank" rel="external">CSS之BFC详解</a></p>
<h3 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h3><p>行内级盒（inline-level boxes）：当元素的 CSS 属性 display 的计算值为 inline，inline-block，inline-table，inline-flex 或 inline-grid 时，它是行内级元素。视觉上它将内容与其它行内级元素排列为一行，直到该行被占满然后换行。典型的如段落内容，文本或图片，都是行内级元素。</p>
<p>注：由于目前几乎所有资料都将行内元素当做行内级元素，所以前面的课程我们也遵循这个美丽的错误。严格来说，行内元素不包括 inline-block 的，行内级元素才包括。我们要理解其中的区别，知晓这个美丽的错误。</p>
<p>行内级元素生成行内级盒，参与行内格式化上下文（inline formatting context），被渲染为水平排列, 直到当行被占满然后换行。每一行排列的行内级盒都可以看做由一个匿名的行盒包裹，如下图（使用了两种灰色背景色来模拟）：</p>
<p><img src="/images/vfm-line-boxes.png" alt="行内级盒"></p>
<p>当块容器盒（block container box）不包括任何块级盒（block-level boxes）时，就会创建一个行内格式化上下文（IFC）。（一般来说一个块级盒也是一个块容器盒）</p>
<p>IFC 中的行内级盒将会按照如下规则进行渲染（规则有点多，大概主要点就是行盒，折行机制，水平对齐方式，垂直高度及垂直对齐方式）：</p>
<ul>
<li>盒子一个接一个地水平摆放，当容器宽度不够时就会换行</li>
<li>在水平方向上，这些盒的外边距、边框、内边距所占用的空间都会被计算，但行内盒的垂直的<code>border</code>，<code>padding</code> 与 <code>margin</code> 都不会撑开行盒的高度</li>
<li>在垂直方向上，这些盒可能会以不同形式来对齐，可通过 <code>vertical-align</code> 来设置，默认对齐为 <code>baseline</code></li>
<li>每一行将生成一个行盒（line box），包括该行所有的盒子，行盒的宽度是由包含块和存在的浮动来决定</li>
<li>行盒一般左右边都贴紧其包含块，但是会因为浮动盒（<code>float</code> 元素）的存在而发生变化。浮动盒会位于包含块边缘与行盒边缘之间，这样行盒的可用宽度就小于包含块的宽度</li>
<li>当所有盒的总宽度小于行盒的宽度，那么行盒中的水平方向排版由 <code>text-align</code> 属性来决定</li>
<li>当所有盒的总宽度超过一个行盒时，就会形成多个行盒，多个行盒相互之间垂直方向不能分离，不能重叠</li>
<li>当一个行内盒超过行盒的宽度时，它会被分割成多个盒，这些盒被分布在多个行盒里。如果一个行内盒不能被分割（比如只包含单个字符，或<code>word-breaking</code>机制被禁用，或该行内框受<code>white-space</code>属性值为<code>nowrap</code>或<code>pre</code>的影响），那么这个行内盒将溢出这个行盒</li>
<li>当一个行内盒发生分割时，分割处的 <code>margin</code>, <code>border</code>和 <code>padding</code>不会有任何视觉效果（或者其他任何分裂，只要是有多个行盒）</li>
<li>行盒的高度由内部元素中实际高度最高的元素计算出来。每个行盒的高度由于内容不一样，所以高度也可能不一样</li>
<li>在一个行盒中，当他包含的内部容器的高度小于行盒的高度的时候，内部容器的垂直位置可由自己的 <code>vertical-align</code> 属性来确定</li>
</ul>
<p>注：在 IFC 的环境中，是不能存在块级元素的，如果将块级元素插入到 IFC 中，那么此 IFC 将会被破坏掉变成 BFC，而块级元素前的元素或文本和块级元素后的元素或文本将会各自自动产生一个匿名块盒其包围。</p>
<h3 id="其他格式化上下文"><a href="#其他格式化上下文" class="headerlink" title="其他格式化上下文"></a>其他格式化上下文</h3><p>除此之外，还有一些其他不同类型的盒子，如下：</p>
<ul>
<li><a href="https://www.w3.org/TR/CSS22/tables.html#model" target="_blank" rel="external">表格布局</a>：可以创建一个表格包裹盒(table wrapper box)，包括了表格盒(table box)及任何标题盒(caption boxes)。</li>
<li><a href="https://www.w3.org/TR/css3-multicol/#the-multi-column-model" target="_blank" rel="external">多列布局</a>：可以在容器盒与内容之间创建列盒(column boxes)</li>
<li><a href="https://www.w3.org/TR/css-flexbox-1/#flex-containers" target="_blank" rel="external">弹性布局</a>：将会创建一个弹性容器盒（flex container box）</li>
<li><a href="https://www.w3.org/TR/css-grid-1/#grid-model" target="_blank" rel="external">网格布局</a>：将会创建一个网格容器盒（grid container box）</li>
</ul>
<p>而这些盒子也将采用不用的格式化上下文来渲染，如 table formatting context（table 布局）、flex formatting context（flexbox 布局）、grid formatting context（grid 布局）。</p>
<p>可参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Visual_formatting_model#.E7.9B.92.E7.9A.84.E7.94.9F.E6.88.90" target="_blank" rel="external">视觉格式化模型 | MDN</a></p>
<hr>
<h1 id="定位方案"><a href="#定位方案" class="headerlink" title="定位方案"></a>定位方案</h1><p>上面我们所讨论的BFC、IFC其实都是常规流（normal flow）中盒子的摆放。但实际上我们有三种定位方案，分别为：</p>
<ul>
<li>常规流（normal flow）：盒一个接一个排列，不同的盒子采用不同的格式化上下文渲染。</li>
<li>浮动（float）：盒将从常规流里提出来，放在当前盒的旁边。</li>
<li>绝对定位(absolute positioning)：盒将脱离常规流，其坐标是绝对的（通过 <code>top / bottom / left / right</code> 来设置）。</li>
</ul>
<h2 id="常规流（normal-flow）"><a href="#常规流（normal-flow）" class="headerlink" title="常规流（normal flow）"></a>常规流（normal flow）</h2><p>默认盒的定位方案就是常规流，但是如果触发了以下任何一个条件，将不会使用常规流：</p>
<ul>
<li><code>position</code> 的值非 <code>static</code> 或 <code>relative</code></li>
<li><code>float</code> 的值非 <code>none</code></li>
</ul>
<p>在常规流中，不同的盒子将采用不同的格式化上下文渲染，也就是上面所讲的部分。</p>
<h2 id="浮动（float）"><a href="#浮动（float）" class="headerlink" title="浮动（float）"></a>浮动（float）</h2><p>对于浮动定位方案, 盒称为浮动盒（floating boxes）。它位于当前行的开头或末尾。这导致常规流环绕在它的周边，除非设置 <code>clear</code> 属性。</p>
<p>要使用浮动定位方案，元素 CSS 属性 <code>position</code> 必须为 <code>static</code> 或 <code>relative</code>，然后 <code>float</code> 不为 <code>none</code> 。如果 <code>float</code> 设为 <code>left</code>, 则浮动定位到当前位置的开始位置，如果设为 <code>right</code>, 则浮动定位到当前位置的最后位置。</p>
<h2 id="绝对定位（absolute-position）"><a href="#绝对定位（absolute-position）" class="headerlink" title="绝对定位（absolute position）"></a>绝对定位（absolute position）</h2><p>如果元素的属性 <code>position</code> 不是 <code>static</code> 或 <code>relative，</code> 那它就是绝对定位元素。</p>
<p>对于绝对定位方案，盒从常规流中被移除，不影响常规流的布局。 它的定位相对于它的包含块，定位坐标可通过属性 <code>top、bottom、left、right</code> 来设置 。</p>
<p>固定定位元素(fixed positioned element)也是绝对定位元素，它的包含块是视口。当页面滚动时它固定在屏幕上，因为视口没有移动。</p>
<hr>
<h1 id="float-及如何清除浮动"><a href="#float-及如何清除浮动" class="headerlink" title="float 及如何清除浮动"></a>float 及如何清除浮动</h1><h2 id="元素浮动的目的"><a href="#元素浮动的目的" class="headerlink" title="元素浮动的目的"></a>元素浮动的目的</h2><p>实现文字环绕元素的效果。</p>
<p><code>float</code>的取值包括，<code>none</code> | <code>left</code> | <code>right</code> 。</p>
<h2 id="浮动带来的问题"><a href="#浮动带来的问题" class="headerlink" title="浮动带来的问题"></a>浮动带来的问题</h2><p>父元素高度塌陷。</p>
<h2 id="如何清除浮动"><a href="#如何清除浮动" class="headerlink" title="如何清除浮动"></a>如何清除浮动</h2><p>清除浮动主要是为了解决由于浮动元素脱离文流导致的元素重叠或者父元素高度坍塌的问题，而这两个问题分别对应了需要清除浮动的两种种情况：清除前面兄弟元素浮动和闭合子元素浮动（解决父元素高度坍塌）。</p>
<h3 id="清除前面兄弟元素浮动"><a href="#清除前面兄弟元素浮动" class="headerlink" title="清除前面兄弟元素浮动"></a>清除前面兄弟元素浮动</h3><ul>
<li>清除前面兄弟元素浮动很简单，只需要在不想受到浮动元素影响的元素上使用 <code>clear:both</code> 即可。</li>
<li>在 CSS2 以前，<code>clear</code> 的原理为自动增加元素的上外边距（<code>margin-top</code>）值，使之最后落在浮动元素的下面。在 CSS2.1 中引入了一个清除区域（<code>clearance</code>）——在元素上外边距之上增加的额外间距，使之最后落在浮动元素的下面。</li>
<li>所以如果需要设置浮动元素与 <code>clear</code> 元素的间距，得设置浮动的元素的 <code>margin-bottom</code>，而不是 <code>clear</code> 元素的 <code>margin-top</code>。</li>
</ul>
<h3 id="闭合子元素浮动"><a href="#闭合子元素浮动" class="headerlink" title="闭合子元素浮动"></a>闭合子元素浮动</h3><ul>
<li>我们知道，在计算页面排版的时候，如果没有设置父元素的高度，那么该父元素的高度是由他的子元素高度撑开的。但是如果子元素是设置了浮动，脱离了文档流，那么父元素计算高度的时候就会忽略该子元素，甚至当所有子元素都是浮动的时候，就会出现父元素高度为 0 的情况，这就是所谓的父元素高度坍塌问题。</li>
<li>为了能让父元素正确包裹子元素的高度，不发生坍塌，我们需要闭合子元素的浮动。</li>
<li><p>一般我们有两种办法可以用来闭合子元素浮动：</p>
<ul>
<li>给最后一个元素设置 <code>clear: both</code></li>
<li>给父元素新建一个 BFC(块格式化上下文)</li>
</ul>
<p>方法一：由于我们最后一个元素使用 clear:both，所以该元素就能不受浮动元素影响出现在父元素的最底部，而父元素计算高度的时候需要考虑到这个正常元素的位置，所以高度自然包裹到了最底部，也就没有了坍塌。对于这个方法，以前我们是利用新增一个空元素（<code>&lt;b&gt;</code> 或 <code>&lt;span&gt;</code> 或 <code>&lt;div&gt;</code> 等）来实现的，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"clear-box"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.clear-box</span> &#123;</div><div class="line">    <span class="attribute">clear</span>: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然这种办法比较直观，但是不是很优雅，因为增加了一个无用的空白标签，比较冗余而且不方便后期维护（一般不太建议使用该办法）。所以后期有了通过父元素的伪元素（<code>::after</code>）实现的著名 <code>clearfix</code> 方法，代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container clearfix"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</div><div class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</div><div class="line">    <span class="attribute">display</span>:table;</div><div class="line">    <span class="attribute">clear</span>: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：该方法的原理是：父元素在新建一个 BFC 时，其高度计算时会把浮动子元素的包进来。下面这些都可以创建一个 BFC：</p>
<ul>
<li>根元素或其它包含它的元素</li>
<li>浮动 (元素的 <code>float</code> 不是 <code>none</code>)</li>
<li>绝对定位的元素 (元素具有 <code>position</code> 为 <code>absolute</code> 或 <code>fixed</code>)</li>
<li>内联块 <code>inline-blocks</code> (元素具有 <code>display: inline-block</code>)</li>
<li>表格单元格 (元素具有 <code>display: table-cell</code>，HTML表格单元格默认属性)</li>
<li>表格标题 (元素具有 <code>display: table-caption</code>, HTML表格标题默认属性)</li>
<li>块元素具有<code>overflow</code> ，且值不是 <code>visible</code></li>
<li><code>display: flow-root</code></li>
</ul>
<p>虽然有这么多方法可用，可我们常用的就是 <code>overflow: hidden</code>，代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="float-布局"><a href="#float-布局" class="headerlink" title="float 布局"></a>float 布局</h1><p>常见的float布局有，两栏布局、三栏布局、流动布局。</p>
<ul>
<li>两栏布局：一栏固定宽度并设置浮动，另一栏可设置宽度并浮动，也可不设置宽度不浮动。</li>
<li>三栏布局：三栏均设置宽度并浮动。</li>
<li>流动布局：最外层容器设置<code>margin</code>左右值为<code>auto</code>；中间一栏设置左右<code>margin</code>值以给左右两栏预留位置；三栏均设置浮动，并且左右两栏根据<code>margin-left</code>来调整位置使其在中间栏的<code>margin</code>上。（左边栏为<code>margin-left:-100%</code>;右边栏为<code>margin-left:-margin值</code>。）</li>
</ul>
<hr>
<h1 id="网格布局系统"><a href="#网格布局系统" class="headerlink" title="网格布局系统"></a>网格布局系统</h1><p>参考：<a href="https://960.gs/" target="_blank" rel="external">960网格布局官网</a></p>
<p>960s是网格布局系统的鼻祖，当然随着技术的发展，基于它又发展了很多其他的网格布局系统，但是思想是想通的，无非是整体多少宽度分成几分，间距是多少，如何组合等。为什么是12列呢？因为12可以被2，3，4，6整除，这样做等分的时候是非常方便的。</p>
<hr>
<h1 id="position-属性"><a href="#position-属性" class="headerlink" title="position 属性"></a>position 属性</h1><p>设置元素的定位方式，四种取值：</p>
<ul>
<li><code>static</code>（静态）</li>
<li><code>relative</code>（相对）—— 相对于自己的位置偏移</li>
<li><code>absolute</code>（绝对）—— 相对于非<code>static</code>最近的父元素偏移</li>
<li><code>fixed</code>（固定）—— 一般来说相对于视窗偏移</li>
</ul>
<hr>
<h1 id="z-index-属性"><a href="#z-index-属性" class="headerlink" title="z-index 属性"></a>z-index 属性</h1><p>网页正常文档流排版可以理解为在一个平面立面里面，元素占据空间，依次排列，互不覆盖。但是当页面中元素设置了定位属性的时候，难免会出现元素之间相互重叠的情况。</p>
<p><code>z-index</code> 属性用于指定已定位元素在垂直于页面方向的排列顺序，其属性值有2种：<code>auto</code>（默认值）和整数。这里有2个需要注意的点：</p>
<ul>
<li>z-index 属性只对定位元素元素生效，也就是 <code>position</code> 属性不为 <code>static</code> 的元素。</li>
<li>除了默认值 <code>auto</code>， <code>z-index</code> 可以设置为任意整数，正数，0，负数都可以。</li>
</ul>
<p>一般情况下，<code>z-index</code> 值进行比较有下面2条规则：</p>
<ul>
<li>数值大的在上面(<code>auto</code> 数值上相当于0)。</li>
<li>数值相同的，在 HTML 结构中排后面的在上面。</li>
</ul>
<h2 id="层叠规则"><a href="#层叠规则" class="headerlink" title="层叠规则"></a>层叠规则</h2><ul>
<li>默认HTML结构顺序。</li>
<li><code>position</code>（非<code>static</code>值）元素高于其他元素。</li>
<li><code>position</code>（非<code>static</code>值）元素之间先通过<code>z-index</code>值判断。</li>
<li>如果<code>z-index</code>相同则按照HTML结构顺序。</li>
</ul>
<h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><p>上面说到，<code>z-index</code> 默认值 <code>auto</code> 数值上等于0，那设置了 <code>z-index:0</code> 和 默认的 <code>z-index:auto</code>; 有没有区别呢？ 答案是有区别的。区别在于设置了 <code>z-index</code> 属性为整数值(包括0)的元素，自身会创建一个层叠上下文。而创建一个层叠上下文之后，其子元素的层叠顺序就相对于父元素计算，不会与外部元素比较。即并不是所有情况 <code>z-index</code> 值大的元素都会在上面，我们在进行 <code>z-index</code> 比较的时候要留意其祖先元素有没有建立独立的层叠上下文，<code>z-index</code> 只有在同一个层叠上下文中比较才有意义。</p>
<p>另外，对定位元素设置 z-index 属性不是唯一创建层叠上下文的方法，具有下面属性的元素都会创建层叠上下文（具体可参看：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="external">层叠上下文 | MDN</a>）：</p>
<ul>
<li>根元素 (HTML)</li>
<li><code>z-index</code> 值不为 <code>&quot;auto&quot;</code>的 绝对/相对定位</li>
<li>一个 <code>z-index</code> 值不为 <code>&quot;auto&quot;</code>的 <code>flex</code> 项目 (<code>flex item</code>)，即：父元素 <code>display: flex|inline-flex</code></li>
<li><code>opacity</code> 属性值小于 <code>1</code> 的元素</li>
<li><code>transform</code> 属性值不为 <code>&quot;none&quot;</code>的元素，</li>
<li><code>mix-blend-mode</code> 属性值不为 <code>&quot;normal&quot;</code>的元素，</li>
<li><code>filter</code>值不为<code>“none”</code>的元素，</li>
<li><code>perspective</code>值不为<code>“none”</code>的元素，</li>
<li><code>isolation</code> 属性被设置为 <code>&quot;isolate&quot;</code>的元素，</li>
<li><code>position: fixed</code></li>
<li>在 <code>will-change</code> 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考这篇文章）</li>
<li><code>-webkit-overflow-scrolling</code> 属性被设置 <code>&quot;touch&quot;</code>的元素</li>
</ul>
<p>可参考：<a href="http://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="external">深入理解CSS中的层叠上下文和层叠顺序</a> 、<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index" target="_blank" rel="external">理解CSS的 z-index属性</a> 。</p>
<hr>
<h1 id="flexbox-布局"><a href="#flexbox-布局" class="headerlink" title="flexbox 布局"></a>flexbox 布局</h1><p>当给父元素设置<code>display:flex</code>属性后，其直接子元素会形成一个flexbox布局模型，可以非常容易的去排列子元素。父元素成为flex <code>container</code>，子元素称为<code>flex item</code>。</p>
<h2 id="flex-container-属性"><a href="#flex-container-属性" class="headerlink" title="flex container 属性"></a>flex container 属性</h2><ul>
<li><code>flex-direction(主轴方向) : row | row-reverse | column | column-reverse</code></li>
<li><code>flex-wrap(一条主轴排满后是否换行) : nowrap | wrap | wrap-reverse</code></li>
<li><code>justify-content(主轴上的对齐方式) : flex-start | flex-end | center | space-between | space- around</code></li>
<li><code>align-items(交叉轴的对齐方式) : stretch | flex-start | flex-end | center | baseline</code></li>
<li><code>align-content(多根轴线对齐方式) : stretch | flex-start | flex-end | center | space-between | space-around</code></li>
</ul>
<h2 id="flex-item-属性"><a href="#flex-item-属性" class="headerlink" title="flex item 属性"></a>flex item 属性</h2><ul>
<li><code>order(排列顺序)</code></li>
<li><code>flex-grow(放大比例)</code></li>
<li><code>flex-shrink(缩小比例)</code></li>
<li><code>flex-basis(item所占主轴空间，会覆盖width)</code></li>
<li><code>align-self(对齐方式，会覆盖align-items)</code></li>
</ul>
<p>可参考：<a href="https://codepen.io/enxaneta/full/adLPwv" target="_blank" rel="external">Flexbox playground</a></p>
<h2 id="剩余空间分配相关属性"><a href="#剩余空间分配相关属性" class="headerlink" title="剩余空间分配相关属性"></a>剩余空间分配相关属性</h2><p>flexbox 布局中的子元素可以通过设置 <code>flex</code> 属性来改变其所分配到的空间大小。<code>flex</code> 属性包括了 <code>flex-basis</code>、 <code>flex-grow</code>、<code>flex-shrink</code> 。</p>
<ul>
<li><p>flex-basis</p>
<ul>
<li><code>flex-basis</code> 用来定义子元素的默认宽或高。如果父容器 <code>flex-direction</code> 属性的方向为水平方向则为宽度，如为垂直方向则为高度。相当于给子元素设置宽或高。如果同时设置了该属性与宽或高，则该属性权重大于宽或高的值。</li>
</ul>
</li>
<li><p>flex-grow</p>
<ul>
<li><code>flex-grow</code> 用来指定父容器多余空间的分配比率，默认值为0。如果子元素的宽度的总和超过父容器，<code>flex-grow</code> 将不生效。</li>
</ul>
</li>
<li><p>flex-shrink</p>
<ul>
<li><code>flex-shrink</code> 用来指定父容器空间不够时子元素的缩小比例，默认为1。如果一个 flexbox 项目的 <code>flex-shrink</code> 属性为0，则该元素不会被压缩。</li>
</ul>
</li>
</ul>
<p>关于flexbox布局，可参考：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">Flex布局教程：语法篇</a> 、 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">Flex 布局教程：实例篇</a></p>
<hr>
<h1 id="grids-布局系统"><a href="#grids-布局系统" class="headerlink" title="grids 布局系统"></a>grids 布局系统</h1><p>随着 CSS 的不断发展及完善，一种新的网格布局方式被纳入规范，它将会解决所有的网格问题，这就是我们要说的 CSS Grid Layout。</p>
<p><img src="/images/grids-excel.png" alt="网格布局类比excel"></p>
<ul>
<li><code>Grid Container</code>：首先我们要设置父元素的布局为 grid，通过使用 display 属性给元素显式设置属性值grid或inline-grid，此时这个元素将自动变成网格容器，对应上图的Sheet1</li>
<li><code>Grid Item</code>：Item 是 container 的直接子元素，如果不考虑单元格的合并跟下面的 cell 是一样的，如果有单元格合并，在该 item 可能包括几个cell，对应上图的一个个格子，如蓝色的 A1</li>
<li><code>Grid Lines</code>：网格线分为水平线和垂直线，对应上图的橙色线条</li>
<li><code>Grid Track</code>：就是由lines构成的水平和垂直空间，对应到上图的水平和垂直灰色区域，而对于table来说就是row和column</li>
<li><code>Grid Cell</code>：简单来说就是单元格了，对应到上图就是蓝色的A1，而对于table来说就是单元格</li>
<li><code>Grid Area</code>：网格区域是由任意四条网格线组成的空间，可能由一个或多个单元格组成。对应到上图就是红色区域，相当于表格中的合并单元格之后的区域</li>
</ul>
<p>网格系统布局其实跟 flexbox 布局差不多，都是由父子元素构成的布局。所以属性分为父元素属性和子元素属性。</p>
<p>可参考：<a href="https://css-tricks.com/snippets/css/complete-guide-grid/#prop-align-items" target="_blank" rel="external">A Complete Guide to Grid</a></p>
<h2 id="父元素（Grid-Container）属性"><a href="#父元素（Grid-Container）属性" class="headerlink" title="父元素（Grid Container）属性"></a>父元素（Grid Container）属性</h2><ul>
<li><p>第一类：如何去定义一个网格系统，行列及间距等。</p>
<ul>
<li><code>display：grid/inline-grid</code>，定义使用网格系统</li>
<li><code>grid-template-columns</code>：定义垂直栏</li>
<li><code>grid-template-rows</code>：定义水平行</li>
<li><code>grid-template-areas</code>：定义区域</li>
<li><code>grid-column-gap</code>：定义垂直栏与垂直栏之间的间距，如上图的A与B之间的间距</li>
<li><code>grid-row-gap</code>：定义水平行与水平行之间的间距，如上图的1与2之间的间距</li>
<li><code>grid-gap</code>：上面两个栏与行间距的缩写</li>
</ul>
</li>
<li><p>第二类：自动分配形式，当定义的行或列数量不够时，多出 item 的自动排列方式：</p>
<ul>
<li><code>grid-auto-columns</code>：定义多出的 item 的自动column的宽度大小</li>
<li><code>grid-auto-rows</code>：定义多出的 item 自动 row 的高度大小</li>
<li><code>grid-auto-flow</code>：定义自动 item 是按照先水平方向排列还是垂直方向排列</li>
</ul>
</li>
<li><p>分布对齐的方式（属性跟 flexbox 的有点像）。</p>
<ul>
<li><code>justify-items</code>：item 在水平行中的对齐方式</li>
<li><code>align-items</code>：item 在垂直栏中的对齐方式</li>
<li><code>justify-content</code>：整个水平行在 grid 范围的对齐方式，这里有个好用的 <code>space-evenly</code> 值，补足了以前flex的 <code>space-around</code> 和 <code>space-between</code> 的不足</li>
<li><code>align-content</code>：整个垂直栏在 grid 范围的对齐方式</li>
</ul>
</li>
</ul>
<h2 id="子元素（Grid-Item）属性"><a href="#子元素（Grid-Item）属性" class="headerlink" title="子元素（Grid Item）属性"></a>子元素（Grid Item）属性</h2><ul>
<li><p>单元格所占格子多少</p>
<ul>
<li><code>grid-column-start</code>：item 的起始栏</li>
<li><code>grid-column-end</code>：item 的结束栏</li>
<li><code>grid-column</code>：起始栏和结束栏的简写</li>
<li><code>grid-row-start</code>：item 的起始行</li>
<li><code>grid-row-end</code>：item 的结束行</li>
<li><code>grid-row</code>：起始行与结束行的简写</li>
<li><code>grid-area</code>：item所在区域</li>
</ul>
</li>
<li><p>单元格的自定义对齐方式，这个跟 flexbox 的 item 有点相似。</p>
<ul>
<li><code>justify-self</code>：自定义 item 的水平方向对齐方式</li>
<li><code>align-self</code>：自定义 item 的垂直方向对齐方式</li>
</ul>
</li>
</ul>
<hr>
<h1 id="浏览器是如何渲染-HTML-amp-CSS-的"><a href="#浏览器是如何渲染-HTML-amp-CSS-的" class="headerlink" title="浏览器是如何渲染 HTML&amp;CSS 的"></a>浏览器是如何渲染 HTML&amp;CSS 的</h1><p>我们现在已经知道，使用 HTML &amp; CSS 可以搭建出一个漂亮的 Web 页面。那么浏览器到底是如何使用我们的 HTML &amp; CSS 渲染成我们在屏幕上所看到的页面呢？虽然具体渲染过程很复杂，但是还是可以将其分为几个关键路径，如下：</p>
<ul>
<li>处理 HTML 标记并构建 DOM 树</li>
<li>处理 CSS 标记并构建 CSSOM 树</li>
<li>将 DOM 与 CSSOM 合并成一个渲染树</li>
<li>根据渲染树来布局，以计算每个节点的几何信息，再将各个节点绘制到屏幕上</li>
</ul>
<h2 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h2><p>首先浏览器渲染页面前会根据 HTML 结构构建成对应的 DOM 树。以下面的 HTML 代码为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其 DOM 树生成的流程如下图：</p>
<p><img src="/images/render-1.png" alt="DOM树生成流程"></p>
<ul>
<li>转换： 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。</li>
<li>令牌化： 浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，“”、“”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。</li>
<li>词法分析： 发出的令牌转换成定义其属性和规则的“对象”。</li>
<li>DOM 构建： 最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。</li>
</ul>
<p>整个流程的最终输出就是我们这个简单页面的文档对象模型 (DOM)，如下图：</p>
<p><img src="/images/render-2.png" alt="文档对象模型"></p>
<h2 id="构建-CSSOM-树"><a href="#构建-CSSOM-树" class="headerlink" title="构建 CSSOM 树"></a>构建 CSSOM 树</h2><p>在浏览器构建上面的 DOM 时，在文档的 head 部分遇到了一个 link 标记，该标记引用一个外部 CSS 样式表：style.css。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* style.css */</span></div><div class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span> &#125;</div><div class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>: bold &#125;</div><div class="line"><span class="selector-tag">span</span> &#123; <span class="attribute">color</span>: red &#125;</div><div class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123; <span class="attribute">display</span>: none &#125;</div><div class="line"><span class="selector-tag">img</span> &#123; <span class="attribute">float</span>: right &#125;</div></pre></td></tr></table></figure>
<p>与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 过程，不过是为 CSS 而不是 HTML：</p>
<p><img src="/images/render-3.png" alt="CSSOM渲染过程"></p>
<p>CSS 字节转换成字符，接着转换成令牌和节点，最后挂靠到一个称为“CSS 对象模型”(CSSOM) 的树结构内：</p>
<p><img src="/images/render-4.png" alt="CSSOM"></p>
<p>CSSOM 为何具有树结构？这是因为浏览器为页面上的任何对象计算最后一组样式时，都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式），然后通过应用更具体的规则（即规则“向下级联”）以递归方式优化计算的样式。</p>
<h2 id="合并渲染树"><a href="#合并渲染树" class="headerlink" title="合并渲染树"></a>合并渲染树</h2><p>接下来就是将 DOM 树与 CSSOM 树合并形成渲染树。渲染树会网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。</p>
<p><img src="/images/render-5.png" alt="合并成渲染树"></p>
<p>渲染树只包含渲染网页所需的节点，如<code>display: none;</code>的元素是不会出现在渲染树种的。</p>
<h2 id="布局及绘制"><a href="#布局及绘制" class="headerlink" title="布局及绘制"></a>布局及绘制</h2><p>有了渲染树，我们就可以进入“布局”阶段。到目前为止，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们尚未计算它们在设备视口内的确切位置和大小——这就是布局阶段，也称为自动重排。</p>
<p>为弄清每个对象在网页上的确切大小和位置，浏览器从渲染树的根节点开始进行遍历。让我们考虑下面这样一个简单的实例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critial Path: Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 50%"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 50%"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>以上网页的正文包含两个嵌套 div：第一个（父）div 将节点的显示尺寸设置为视口宽度的 50%；而里面内嵌的第二个 div 将其宽度设置为其父项的 50%，即视口宽度的 25%。如下图：</p>
<p><img src="/images/render-6.png" alt="布局"></p>
<p>布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素。</p>
<p>最后，既然我们知道了哪些节点可见、它们的计算样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素形成我们可见的页面。这一步通常称为绘制或栅格化。</p>
<hr>
<h1 id="重排与重绘"><a href="#重排与重绘" class="headerlink" title="重排与重绘"></a>重排与重绘</h1><p>一个页面渲染完毕后，随着用户的操作，或者数据变化，网页还会进行重新渲染。根据不同的触发条件，重新渲染分为两种情况：重排（reflow）和重绘（repaint）。</p>
<ul>
<li>所有对元素视觉表现属性的修改，都会导致重绘（repaint）。比如修改了背景颜色、文字颜色等。</li>
<li>所有会触发元素布局发生变化的修改，都会导致重排（reflow）。比如窗口尺寸发生变化，删除、添加 DOM 元素，修改了影响元素盒子大小的 CSS 属性如 <code>width</code>、 <code>height</code>、 <code>padding</code> 等。</li>
</ul>
<p>通常情况下，重排的影响更大，重排会导致文档局部或全部的重新运算：重新计算元素位置，大小。（改变一个元素的布局，可能会影响很多个元素的布局）</p>
<p>不管是重绘还是重排导致的重新渲染，都会阻塞浏览器。重新渲染的的过程中，JavaScript 会被阻塞，用户的交互行为也会被卡住。复杂的 CSS 动画甚至会拖慢 JavaScript 的运行速度。</p>
<h2 id="导致重排和重绘的场景"><a href="#导致重排和重绘的场景" class="headerlink" title="导致重排和重绘的场景"></a>导致重排和重绘的场景</h2><ul>
<li><p>CSS 属性改变,包括但不限于以下场景：</p>
<ul>
<li>通过 <code>display: none</code> 隐藏 DOM 节点（导致重绘和重排）</li>
<li>通过 <code>visibility: hidden</code> 隐藏 DOM 节点 （导致重绘，因为它没有影响其它元素位置布局）</li>
<li>CSS 动画</li>
<li>通过 JavaScript 添加样式，修改样式</li>
</ul>
</li>
<li><p>用户交互</p>
<ul>
<li>对浏览器窗口进行缩放操作会导致重排</li>
<li>对 DOM 节点进行操作，添加、删除、更新 DOM 节点都会导致重排</li>
<li>光标 <code>:hover</code> 、进入文本输入框、修改浏览器的字体都会导致重排</li>
</ul>
</li>
</ul>
<p>可参考：<a href="https://csstriggers.com/" target="_blank" rel="external">CSS triggers</a></p>
<hr>
<h1 id="最佳实践（减少重新渲染）"><a href="#最佳实践（减少重新渲染）" class="headerlink" title="最佳实践（减少重新渲染）"></a>最佳实践（减少重新渲染）</h1><p>所有的最佳实践都是围绕尽最大可能的降低重绘和重排的频率，来达到减少重新渲染的目的。</p>
<h2 id="CSS-属性的读、写操作分开"><a href="#CSS-属性的读、写操作分开" class="headerlink" title="CSS 属性的读、写操作分开"></a>CSS 属性的读、写操作分开</h2><p>浏览对 CSS 属性的连续修改做了优化，比如下面的连续修改两次 style，不会导致两次重新渲染：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">div.style.color = <span class="string">'blue'</span>;</div><div class="line">div.style.marginTop = <span class="string">'30px'</span>;</div></pre></td></tr></table></figure>
<p>上面代码只会进行一次重新渲染。但是如果写的不好，则会触发两次重新渲染，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">div.style.color = <span class="string">'blue'</span>;</div><div class="line"><span class="keyword">var</span> margin = <span class="built_in">parseInt</span>(div.style.marginTop);</div><div class="line">div.style.marginTop = (margin + <span class="number">10</span>) + <span class="string">'px'</span>;</div></pre></td></tr></table></figure>
<p>上面代码对 div 元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不重新渲染然后得到该元素的位置。</p>
<p>除此之外，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染：</p>
<ul>
<li><code>offsetTop/offsetLeft/offsetWidth/offsetHeight</code></li>
<li><code>scrollTop/scrollLeft/scrollWidth/scrollHeight</code></li>
<li><code>clientTop/clientLeft/clientWidth/clientHeight</code></li>
<li><code>getComputedStyle()</code></li>
</ul>
<h2 id="通过-class-或者-csstext-来批量更新样式"><a href="#通过-class-或者-csstext-来批量更新样式" class="headerlink" title="通过 class 或者 csstext 来批量更新样式"></a>通过 class 或者 csstext 来批量更新样式</h2><p>上面对通过对 style 对 CSS 属性一个一个修改，其实更好的方式应该是通过 class 来批量化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> left = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> top = <span class="number">10</span>;</div><div class="line">el.style.left = left + <span class="string">"px"</span>;</div><div class="line">el.style.top  = top  + <span class="string">"px"</span>;</div><div class="line"><span class="comment">// good</span></div><div class="line">el.className += <span class="string">" theclassname"</span>;</div><div class="line"><span class="comment">// good</span></div><div class="line">el.style.cssText += <span class="string">"; left: "</span> + left + <span class="string">"px; top: "</span> + top + <span class="string">"px;"</span>;</div></pre></td></tr></table></figure>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><ul>
<li>DOM 样式离线更新：尽量使用离线 DOM，而不是真实的网页 DOM 来改变元素样式。比如，操作 <code>Document Fragment</code>对象，完成后再把这个对象加入 DOM。再比如，使用 <code>cloneNode()</code> 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。</li>
<li>使用 <code>display: none</code> 进行样式批量更新：先将元素设为 <code>display: none</code>（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。</li>
<li>善用 <code>position：position</code> 属性为 <code>absolute</code> 或 <code>fixed</code> 的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。</li>
<li>将元素设置为不可见：只在必要的时候，才将元素的 <code>display</code> 属性为可见，因为不可见的元素不影响重排和重绘。另外，<code>visibility : hidden</code> 的元素只对重绘有影响，不影响重排。</li>
<li>减少样式的更新频率：使用虚拟 DOM 脚本库，比如 React 等。</li>
<li>调节 js 运行帧率：使用 <code>window.requestAnimationFrame()</code>、<code>window.requestIdleCallback()</code> 这两个方法调节重新渲染的频率。</li>
<li>慎用 table 布局：table 的单元格具有非常好的自适应特性，但是同时代价也很高，能不用就不用。如果非要使用 table ，给 table 添加 <code>table-layout: fixed</code> 属性，这个属性的目的是让后面单元格的宽度由表头的宽度来决定——减少布局的计算量。</li>
</ul>
<p>可参考：<a href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="external">网页性能管理详解</a> 、 <a href="http://taobaofed.org/blog/2016/04/25/performance-composite/" target="_blank" rel="external">无线性能优化：Composite</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/HTML/" rel="tag"> # HTML</a>
          
            <a href="/tags/CSS/" rel="tag"> # CSS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/24/前端知识总结——CSS预处理/" rel="next" title="前端知识总结——CSS预处理">
                <i class="fa fa-chevron-left"></i> 前端知识总结——CSS预处理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/09/前端知识总结——HTML、CSS补充/" rel="prev" title="前端知识总结——HTML、CSS补充">
                前端知识总结——HTML、CSS补充 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="白发渔樵" />
          <p class="site-author-name" itemprop="name">白发渔樵</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#HTML-CSS布局"><span class="nav-number">1.</span> <span class="nav-text">HTML+CSS布局</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTML语义化"><span class="nav-number">2.</span> <span class="nav-text">HTML语义化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#让-IE8-支持-HTML5-语义化标签"><span class="nav-number">3.</span> <span class="nav-text">让 IE8 支持 HTML5 语义化标签</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IE8-对-HTML5-标签的处理"><span class="nav-number">3.1.</span> <span class="nav-text">IE8 对 HTML5 标签的处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何让-IE8-支持-HTML5-标签"><span class="nav-number">3.2.</span> <span class="nav-text">如何让 IE8 支持 HTML5 标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#借助-html5shiv-js-让IE8支持更多的HTML5特性"><span class="nav-number">3.3.</span> <span class="nav-text">借助 html5shiv.js 让IE8支持更多的HTML5特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#显示类型-display"><span class="nav-number">4.</span> <span class="nav-text">显示类型 display</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#块级元素"><span class="nav-number">4.1.</span> <span class="nav-text">块级元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#行内元素"><span class="nav-number">4.2.</span> <span class="nav-text">行内元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Why？"><span class="nav-number">4.3.</span> <span class="nav-text">Why？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#视觉格式化模型（visual-formatting-model）"><span class="nav-number">5.</span> <span class="nav-text">视觉格式化模型（visual formatting model）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#盒子的位置摆放"><span class="nav-number">5.1.</span> <span class="nav-text">盒子的位置摆放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#格式化上下文（formatting-context）"><span class="nav-number">5.2.</span> <span class="nav-text">格式化上下文（formatting context）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BFC"><span class="nav-number">5.2.1.</span> <span class="nav-text">BFC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IFC"><span class="nav-number">5.2.2.</span> <span class="nav-text">IFC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他格式化上下文"><span class="nav-number">5.2.3.</span> <span class="nav-text">其他格式化上下文</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#定位方案"><span class="nav-number">6.</span> <span class="nav-text">定位方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常规流（normal-flow）"><span class="nav-number">6.1.</span> <span class="nav-text">常规流（normal flow）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浮动（float）"><span class="nav-number">6.2.</span> <span class="nav-text">浮动（float）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绝对定位（absolute-position）"><span class="nav-number">6.3.</span> <span class="nav-text">绝对定位（absolute position）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#float-及如何清除浮动"><span class="nav-number">7.</span> <span class="nav-text">float 及如何清除浮动</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#元素浮动的目的"><span class="nav-number">7.1.</span> <span class="nav-text">元素浮动的目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浮动带来的问题"><span class="nav-number">7.2.</span> <span class="nav-text">浮动带来的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何清除浮动"><span class="nav-number">7.3.</span> <span class="nav-text">如何清除浮动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#清除前面兄弟元素浮动"><span class="nav-number">7.3.1.</span> <span class="nav-text">清除前面兄弟元素浮动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭合子元素浮动"><span class="nav-number">7.3.2.</span> <span class="nav-text">闭合子元素浮动</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#float-布局"><span class="nav-number">8.</span> <span class="nav-text">float 布局</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网格布局系统"><span class="nav-number">9.</span> <span class="nav-text">网格布局系统</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#position-属性"><span class="nav-number">10.</span> <span class="nav-text">position 属性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#z-index-属性"><span class="nav-number">11.</span> <span class="nav-text">z-index 属性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#层叠规则"><span class="nav-number">11.1.</span> <span class="nav-text">层叠规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#层叠上下文"><span class="nav-number">11.2.</span> <span class="nav-text">层叠上下文</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#flexbox-布局"><span class="nav-number">12.</span> <span class="nav-text">flexbox 布局</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#flex-container-属性"><span class="nav-number">12.1.</span> <span class="nav-text">flex container 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flex-item-属性"><span class="nav-number">12.2.</span> <span class="nav-text">flex item 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剩余空间分配相关属性"><span class="nav-number">12.3.</span> <span class="nav-text">剩余空间分配相关属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#grids-布局系统"><span class="nav-number">13.</span> <span class="nav-text">grids 布局系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#父元素（Grid-Container）属性"><span class="nav-number">13.1.</span> <span class="nav-text">父元素（Grid Container）属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子元素（Grid-Item）属性"><span class="nav-number">13.2.</span> <span class="nav-text">子元素（Grid Item）属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#浏览器是如何渲染-HTML-amp-CSS-的"><span class="nav-number">14.</span> <span class="nav-text">浏览器是如何渲染 HTML&CSS 的</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#构建-DOM-树"><span class="nav-number">14.1.</span> <span class="nav-text">构建 DOM 树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构建-CSSOM-树"><span class="nav-number">14.2.</span> <span class="nav-text">构建 CSSOM 树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并渲染树"><span class="nav-number">14.3.</span> <span class="nav-text">合并渲染树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布局及绘制"><span class="nav-number">14.4.</span> <span class="nav-text">布局及绘制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#重排与重绘"><span class="nav-number">15.</span> <span class="nav-text">重排与重绘</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#导致重排和重绘的场景"><span class="nav-number">15.1.</span> <span class="nav-text">导致重排和重绘的场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#最佳实践（减少重新渲染）"><span class="nav-number">16.</span> <span class="nav-text">最佳实践（减少重新渲染）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS-属性的读、写操作分开"><span class="nav-number">16.1.</span> <span class="nav-text">CSS 属性的读、写操作分开</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过-class-或者-csstext-来批量更新样式"><span class="nav-number">16.2.</span> <span class="nav-text">通过 class 或者 csstext 来批量更新样式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他方法"><span class="nav-number">16.3.</span> <span class="nav-text">其他方法</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">白发渔樵</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
