{"meta":{"title":"Thinking Coding","subtitle":null,"description":null,"author":"ice","url":"http://ice-io.github.io"},"pages":[{"title":"about","date":"2017-08-25T11:54:41.000Z","updated":"2017-08-25T11:57:04.322Z","comments":true,"path":"about/index.html","permalink":"http://ice-io.github.io/about/index.html","excerpt":"","text":"About Me"},{"title":"分类","date":"2017-08-25T13:26:44.000Z","updated":"2017-08-25T13:27:15.951Z","comments":true,"path":"categories/index.html","permalink":"http://ice-io.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-08-25T13:24:35.000Z","updated":"2017-08-25T13:25:42.461Z","comments":true,"path":"tags/index.html","permalink":"http://ice-io.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端知识总结——CSS动画","slug":"前端知识总结——CSS动画","date":"2017-08-23T08:59:21.000Z","updated":"2017-09-07T15:17:27.424Z","comments":true,"path":"2017/08/23/前端知识总结——CSS动画/","link":"","permalink":"http://ice-io.github.io/2017/08/23/前端知识总结——CSS动画/","excerpt":"学习了HTML和CSS的相关知识后，接下来继续复习——CSS动画。","text":"学习了HTML和CSS的相关知识后，接下来继续复习——CSS动画。 CSS动画简介通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。 CSS动画包括 补间动画 和 帧动画 。 补间动画：transition；帧动画：animation。 动画必备属性 transformtransform 本意是变形，变换之意，在 CSS 中使用该属性可对元素进行移动（translate）、旋转（rotate）、缩放（scale）、倾斜（skew）等效果。因其有着各种特效及优良的性能，所以成为动画的标配。 在学习之前，我们可以简单欣赏下几个案例： 翻转号码 翻转cube 欣赏之后再来学习transform的相关知识点吧。 translate 其语法为：transform: translate(tx[, ty])。其中 tx 表示 x 方向偏移，ty 表示 y 方向偏移，如果 ty 没有指定值则为0。可以分拆为：transform: translateX(tx) 或 transform: translateY(ty)。 简单示例如下（虚线框表示原先位置）： 123.box &#123; transform: translate(50px, 30px);&#125; 注：tx，ty 如果为百分比值的话，其参考计算的是元素本身的宽和高，而不是父元素的宽和高。所以经常使用该方法设置定位居中，代码如下： 123456.demo &#123; position: absolute; top: 50%; /* 父元素高度的一半位置 */ left: 50%; /* 父元素宽度的一半位置 */ transform: translate(-50%, -50%); /* 元素本身的一半宽、高 */&#125; scale 其语法为：transform: scale(sx[, sy])。其中 sx 表示 x 方向的缩放比例，sy 表示 y 方向的缩放比例，如果 sy 没有指定值则与 sx 相等。同样也可以分拆为：transform: scaleX(sx) 和 transform: scaleY(sy)。 简单示例如下： 123.box &#123; transform: scale(1.2);&#125; rotate 其语法为：transform: rotate(angle)。angle 表示顺时针角度。 简单示例如下： 123.box &#123; transform: rotate(15deg);&#125; skew 其语法为：transform: skew(ax[, ay])。其中 ax 表示 x 方向的顺时针角度，ay 表示 y 方向的顺时针角度，如果 ay 没有指定值则 y 方向没有倾斜。 简单示例如下： 123.box &#123; transform: skew(30deg);&#125; 复合变换 上面几个变换，都可以自由组合形成更复杂的复合变换。 简单示例如下： 123.box &#123; transform: translate(30px) rotate(10deg) skew(0, 5deg);&#125; 变换中心点 默认上面所有的变换都是以元素的中心位置为参考原点的，不过我们可以通过属性 transform-origin 来改变参考原点。 其语法为：transform-origin: ox oy。其中 ox 表示 x 方向的位置，可使用 left、right、center、&lt;length&gt;、&lt;percentage&gt;；oy 表示 y 方向的位置，可使用top、bottom、center、&lt;length&gt;、&lt;percentage&gt;。如果只传入一个值，则另一个值默认为 50% 。 简单示例如下：123456789101112.box &#123; transform: rotate(15deg);&#125;.box-origin-top-left &#123; transform-origin: left top;&#125;.box-origin-right &#123; transform-origin: right; /* 设置一个值，则另一个为50% */&#125;.box-origin-px &#123; transform-origin: 200px 80%;&#125; 三维变换，可参考：CSS3 3D transform变换 、 Intro to CSS 3D transforms 继续了解transform可参考：深入浅出CSS Transform 、 理解CSS3 transform中的Matrix(矩阵) 缓动函数 ease —— 默认值，慢速开始，然后变快，然后慢速结束。 linear —— 以相同速度开始直至结束。 ease-in —— 慢速开始。 ease-out —— 慢速结束。 ease-in-out —— 慢速开始，慢速结束。 上面几种取值其实是cubic-bezier(n,n,n,n)函数的特殊值。 可参考：缓动函数速查表 、 cubic-bezier animation 动画 animation-name（名称） animation-duration（持续时间） animation-timing-function（缓动函数） animation-delay（延迟时间） animation-iteration-count（循环次数） animation-direction（运动方向） animation-fill-mode（动画开始和结束的帧样式） animation-play-state（动画状态：暂停 | 运行） 通过关键字@keyframes来定义关键帧，再通过animation-name属性来调用。 注：定义关键帧的时候，from相当于0% ，to相当于100% 。 transition 动画 和 animation 动画的比较 transition 动画 animation 动画 需要借助交互（如:hover,:active,add class） 既可自动也可交互 只能定义第一帧和最后一帧样式 可以控制多帧，还可以控制暂停播放 常见 CSS 动画库自从 CSS3 有了动画功能，从此 Web 页面就迈进“忽如一夜春风来，千页万页动画开”的盛况。 所以 CSS 动画除了是炫技之选更是一项基本技能，当然也就有无数前辈为之呕心沥血总结经验了。 Animate.css Animate.css 是最早的也是目前最流行和最易于使用的CSS动画库之一，其包含了60多款不同类型的 CSS 动画如晃动、闪动、淡出淡出效果等，如果你想快速的使用各种 CSS 动画特效的话，你可以选择它。 Magic CSS3 Animation Magic CSS3 Animations 是一个特殊效果的 CSS 动画库，你可以免费用于你的 Web 项目，简单的引用 CSS 样式：magic.css 或 magic.min.css （压缩版）即可。该项目提供了一个特别酷的演示应用程序。与 animate.css 相比，Magic CSS3 Animation 的大小适中，它的特色动画，如魔法效果，愚蠢的效果和炸弹效果十分出众和特别。 Hover CSS Hover.css 是一个 CSS 动画库，专为您的网站中的按钮和其他 UI 元素而设计。它具有非常好的2D转换，以及许多其他精心制作的动画。 Effeckt Effeckt.css 是一个集合了众多新鲜而又实用的的 CSS/jQuery 动画效果，这些都适用于网站或是移动 APP 的网页，比如一些 AJAX 弹出框动画、菜单动画、图片标题展示等等，这些特效动画都能给你的网站提升一定用户体验，而且简单实用。 Single Element CSS Spinners 在页面中，我们时常需要使用 gif 图片来实现比较炫酷的 loading 动画。Single Element CSS Spinners是一个CSS螺旋加载动画的集合。使用Single Element CSS Spinners 来替代 gif 来实现螺旋加载动画，不仅减少了请求图片的次数，同时还能够通过代码来灵活地修改动画的参数。 注：一般不建议全部拿来使用，而是使用哪个动画效果就拷贝对应的样式。 动画性能优化CSS3 动画给 Web 的用户体验带来了巨大提升，本文将尝试从浏览器渲染的角度，来解析动画优化的原理及其技巧。为大家提供一些动画性能优化的参考。 60fps与设备刷新率 目前大多数设备的屏幕刷新率为60fps（Frame per Second），即每秒60帧。因此，如果在页面中有一个动画或渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致，即每一帧要在16毫秒（1S/60 = 16.66ms）之内完成。如果无法完成，由于帧率的下降会导致内容在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。 浏览器渲染 简单来说，浏览器的渲染过程其实就是将页面转换成像素显示到屏幕上，大致有如下几个步骤： Javascript操作： 一般来说，我们会使用 JavaScript 来实现一些交互操作。比如用往页面里添加一些元素，切换显示隐藏等 style 样式计算： 该过程根据 CSS 选择器，获取每个元素匹配的 CSS 样式并计算其最终应用样式 Layout 布局：该过程计算元素要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 &lt;body&gt; 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局是经常发生的。 Paint 绘制：本质上就是填充像素的过程。包括绘制文字、颜色、图像、边框和阴影等。也就是绘制元素所有的可视效果。 Composite 渲染层合并：在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。 如果我们需要提高动画的性能，需要做的就是减少浏览器在动画运行时所需要做的工作。当 CSS 在进行动画时，其不同属性值引起的改变，重新渲染可能会有三种执行路径： A：layout -&gt; paint -&gt; composite B：paint -&gt; composite C：composite很明显，最短路径的 C 动画性能是最高的，所以我们在使用动画的时候就得考虑使用什么属性，以尽量减少执行路径。 动画属性 CSS 的属性大致分为三类：布局类（layout），绘制类（paint），合成类（composite）。 重排（reflow） 由元素的布局类属性改变所触发的行为过程，我们称为 reflow，也叫做 relayout（重新布局）。当某个节点 reflow 时会重新计算节点的尺寸和位置，还可能会引起其它节点的 reflow。该系列属性的改变，会执行路径 A 进行重新渲染，所以性能是最差的。（这充分说明，重排会引起重绘）。触发重排的属性如下： 盒子模型相关属性会触发重布局：width、height、padding、margin、display、border-width、border、min-height 定位属性及浮动也会触发重布局：top、bottom、left、right、position、float、clear 改变节点内部文字结构也会触发重布局：text-align、overflow、font-weight、font-family、line-height、vertival-align、white-space、font-size 重绘 绘制类属性改变触发节点重新绘制其可视效果的过程，我们称为 repaint。该系列属性的改变，会执行路径 B，所以性能一般。触发重绘的属性如下： color、border-style、border-radius、visibility、text-decoration、background、background-image、background-position、background-repeat、background-size、outline-color、outline、outline-style、outline-width、box-shadow 上面的属性由于不会修改节点的大小和位置，因此不会触发重排，其只是改变了节点内部的渲染效果，所以只会进行重绘以下的步骤。 composite 目前只有两个属性属于 composite 类： transform、opactiy 该系列属性的改变，会执行路径 C，所以性能最佳。 动画性能优化技巧 减少动画元素 减少动画元素，是动画性能优化中首先需要完成的。通过审查页面动画 DOM 元素结构，去除不必要的动画元素，减少元素的数量，相应地会减少布页面局和绘制的时间。 尽量使用 fixed、absolute 定位 对于动画元素，尽量使用用 fixed、absolute 定位方式，避免影响到其他节点重排。 尽量只改变transform和opacity 能用 transform、opacity 优先使用，其属性的改变不会发生重排和重绘。如位移操作的，可以使用translate 来实现，渐隐渐现效果可以使用 opacity 属性来实现。 恰当开启硬件加速效果 对动画元素应用transform: translate3d(0, 0, 0)、will-change: transform 等来开启硬件加速。通常开启硬件加速可以让动画变得更加流畅。但这里需注意，在不需要的时候需去掉避免过多的内存消耗。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ice-io.github.io/tags/CSS/"},{"name":"CSS动画","slug":"CSS动画","permalink":"http://ice-io.github.io/tags/CSS动画/"}]},{"title":"前端知识总结——HTML、CSS进阶篇","slug":"前端知识总结——HTML、CSS进阶篇","date":"2017-08-21T07:24:58.000Z","updated":"2017-09-07T07:52:21.520Z","comments":true,"path":"2017/08/21/前端知识总结——HTML、CSS进阶篇/","link":"","permalink":"http://ice-io.github.io/2017/08/21/前端知识总结——HTML、CSS进阶篇/","excerpt":"了解了HTML和CSS的基础知识后，就可以继续深入HTML和CSS的博大精深了。","text":"了解了HTML和CSS的基础知识后，就可以继续深入HTML和CSS的博大精深了。 CSS布局 这里引入一下古老的table布局方法：用表格定义天然的区块再填入内容来布局。缺点如下： 加载慢，需等到表格加载完才显示。 HTML语义化 表格之后，布局主要是div + CSS —— 导致div标签被滥用 HTML语义化 方便团队开发 有利于SEO 对屏幕阅读软件友好 HTML 语义当然不仅仅只是几个 HTML 语义标签。HTML 就是文档，最开始的《Web 简史》中我们有提到过，万维网的雏形是一个文档共享系统，万维网就是一个放大版的文档共享系统。只是随着 Web 的发展，各种酷炫的页面和应用层出不穷，倒是让新入行的小伙伴忽略了，HTML 的本质其实是文档（document）。视觉上的各种酷炫会给人以视觉冲击，但对机器来说，并没有什么用，它们更看重的是语义，这样才能更好地解析内容。这也是为什么样式会从结构里面分离出来的原因之一。 可参考：深入理解HTML5标签 让 IE8 支持 HTML5 语义化标签HTML5是 HTML 最新的修订版本，于2014年10月由万维网联盟（W3C）完成标准制定。而 IE8 面世时间为2009年3月19日，时间相差如此之大，所以 IE8 作为比较古老的浏览器，不支持 HTML 5 引入的语义化标签（如 header、nav、menu、section、article 等）。 默认情况下 IE8 对 HTML5 标签的处理 在 IE8 里面，未定义的标签——IE8 不认识所有新引入的 HTML5 标签，所以定义样式是不会生效。 如何让 IE8 支持 HTML5 标签虽然默认不支持，但是我们可以通过 JS 使用 document.createElement 来“欺骗” IE 的 CSS 引擎，让它知道某个标签的存在，具体做法如下： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;HTML5 test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; document.createElement('section'); &lt;/script&gt; &lt;style&gt; section &#123; color: red; &#125; &lt;/style&gt; &lt;section&gt; Hello! &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 借助html5shiv.js让IE8支持更多的HTML5特性 其实不只是 IE8 ， IE6-9、 Safari 4.x (以及 iPhone 3.x)、还有Firefox 3.x 等等，对 HTML5 的支持都不完善。所以有了一个库html5shiv.js 来做统一处理，shiv 意为用作武器的小刀（实际上是一个拼写错误，应该为 shim），在机械工程中的专业释义为垫片，比喻给那些老旧的浏览器加个垫片，让它们基本能用。可参考：html5shiv.js 显示类型-display在HTML的元素显示时，有的是块级元素，有的是行内元素。 比如块级： display:block; display:table; display:list-item; 特征： 每个元素另起一行； 可设置宽高、行高、上下边距、左右边距。 比如行内： display:inline; display:inline-block; 特征： 和其他行内元素同一行； 不可设置宽高、行高、上下边距，可设置左右边距。 这并非是由HTML定义的，而是由默认的css定义的，这也就意味着我们更改元素的显示类型display。 除了上述属性，display还有flex、grid属性，以及inline-block、inline-flex、inline-grid，后面再详细回顾。 视觉格式化模型（visual formatting model）前面我们已经学习了盒模型（box model），知道了元素会被渲染成一个个盒子。那么这些盒子在屏幕上的位置又是怎么放置的呢？这就是我们现在要学习的——CSS 视觉格式化模型(visual formatting model)。视觉格式化模型是 CSS 布局的一个基础理论体系。 盒子的位置摆放 默认情况下，盒子按照元素在 HTML 中的先后位置从左至右自上而下一个接着一个排列摆放。 在图中我们可以看到，有些元素的盒子被渲染为完整的一行，如h1、p、div；而有些元素的盒子则被渲染为水平排列，直到该行被占满然后换行，如span、a、strong。 这是因为不同的盒子使用的是不同的格式化上下文（formatting context）来布局，每个格式化上下文都拥有一套不同的渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。（就如我们参加结婚喜宴一样，有父母长辈席，好友席，同事席，甚至前男/女朋友席等，不同的身份坐到对应位置即可。） 格式化上下文（formatting context） 我们常见的两个格式化上下文分别为：块格式化上下文（block formatting context 简称 BFC）和行内格式化上下文（inline formatting context 简称 IFC） BFC 块级盒（block-level boxes） 当元素的 CSS 属性 display 的计算值为 block，list-item，table，flex 或 grid 时，它是块级元素。视觉上呈现为块，竖直排列。典型的如 &lt;div&gt; 元素，&lt;p&gt; 元素等都是块级元素。 每个块级元素至少生成一个块级盒，称为主要块级盒(principal block-level box)。一些元素，比如&lt;li&gt;，生成额外的盒来放置项目符号，不过多数元素只生成一个主要块级盒。 块级盒参与 BFC，被渲染为完整的一个新行。 渲染规则 默认根元素（html 元素）会创建一个 BFC，其块级盒子元素将会按照如下规则进行渲染： 块级盒会在垂直方向，一个接一个地放置，每个盒子水平占满整个容器空间 块级盒的垂直方向距离由上下 margin 决定，同属于一个 BFC 中的两个或以上块级盒的相接的 margin 会发生重叠 BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此 计算 BFC 的高度时，浮动元素也参与计算 除此之外，还有其他方法可以创建一个新的 BFC，具体可参看：块格式化上下文 | MDN。除此之外，flexbox 布局和 grids 布局中的 item 都会创建一个新的 BFC。 可参考：CSS之BFC详解 IFC 行内级盒（inline-level boxes） 当元素的 CSS 属性 display 的计算值为 inline，inline-block，inline-table，inline-flex 或 inline-grid 时，它是行内级元素。视觉上它将内容与其它行内级元素排列为一行，直到该行被占满然后换行。典型的如段落内容，文本或图片，都是行内级元素。 注：由于目前几乎所有资料都将行内元素当做行内级元素，所以前面的课程我们也遵循这个美丽的错误。严格来说，行内元素不包括 inline-block 的，行内级元素才包括。我们要理解其中的区别，知晓这个美丽的错误。 行内级元素生成行内级盒，参与行内格式化上下文（inline formatting context），被渲染为水平排列, 直到当行被占满然后换行。 每一行排列的行内级盒都可以看做由一个匿名的行盒包裹，如下图（使用了两种灰色背景色来模拟）： ![行内级盒](images/vfm-line-boxes.png) 渲染规则 当块容器盒（block container box）不包括任何块级盒（block-level boxes）时，就会创建一个行内格式化上下文（IFC）。（一般来说一个块级盒也是一个块容器盒） IFC 中的行内级盒将会按照如下规则进行渲染（规则有点多，大概主要点就是行盒，折行机制，水平对齐方式，垂直高度及垂直对齐方式）： 盒子一个接一个地水平摆放，当容器宽度不够时就会换行 在水平方向上，这些盒的外边距、边框、内边距所占用的空间都会被计算，但行内盒的垂直的border，padding 与 margin 都不会撑开行盒的高度 在垂直方向上，这些盒可能会以不同形式来对齐，可通过 vertical-align 来设置，默认对齐为 baseline 每一行将生成一个行盒（line box），包括该行所有的盒子，行盒的宽度是由包含块和存在的浮动来决定 行盒一般左右边都贴紧其包含块，但是会因为浮动盒（float 元素）的存在而发生变化。浮动盒会位于包含块边缘与行盒边缘之间，这样行盒的可用宽度就小于包含块的宽度 当所有盒的总宽度小于行盒的宽度，那么行盒中的水平方向排版由 text-align 属性来决定 当所有盒的总宽度超过一个行盒时，就会形成多个行盒，多个行盒相互之间垂直方向不能分离，不能重叠 当一个行内盒超过行盒的宽度时，它会被分割成多个盒，这些盒被分布在多个行盒里。如果一个行内盒不能被分割（比如只包含单个字符，或word-breaking机制被禁用，或该行内框受white-space属性值为nowrap或pre的影响），那么这个行内盒将溢出这个行盒 当一个行内盒发生分割时，分割处的 margin, border和 padding不会有任何视觉效果（或者其他任何分裂，只要是有多个行盒） 行盒的高度由内部元素中实际高度最高的元素计算出来。每个行盒的高度由于内容不一样，所以高度也可能不一样 在一个行盒中，当他包含的内部容器的高度小于行盒的高度的时候，内部容器的垂直位置可由自己的 vertical-align 属性来确定 注：在 IFC 的环境中，是不能存在块级元素的，如果将块级元素插入到 IFC 中，那么此 IFC 将会被破坏掉变成 BFC，而块级元素前的元素或文本和块级元素后的元素或文本将会各自自动产生一个匿名块盒其包围。 其他格式化上下文 除此之外，还有一些其他不同类型的盒子，如下： 表格布局：可以创建一个表格包裹盒(table wrapper box)，包括了表格盒(table box)及任何标题盒(caption boxes)。 多列布局：可以在容器盒与内容之间创建列盒(column boxes) 弹性布局：将会创建一个弹性容器盒（flex container box） 网格布局：将会创建一个网格容器盒（grid container box） 而这些盒子也将采用不用的格式化上下文来渲染，如 table formatting context（table 布局）、flex formatting context（flexbox 布局）、grid formatting context（grid 布局）。 可参考：视觉格式化模型 | MDN 定位方案上面我们所讨论的BFC、IFC其实都是常规流（normal flow）中盒子的摆放。但实际上我们有三种定位方案，分别为： 常规流（normal flow）：盒一个接一个排列，不同的盒子采用不同的格式化上下文渲染。 浮动（float）：盒将从常规流里提出来，放在当前盒的旁边。 绝对定位(absolute positioning)：盒将脱离常规流，其坐标是绝对的（通过 top / bottom / left / right 来设置）。 常规流（normal flow） 默认盒的定位方案就是常规流，但是如果触发了以下任何一个条件，将不会使用常规流： position 的值非 static 或 relative float 的值非 none 在常规流中，不同的盒子将采用不同的格式化上下文渲染，也就是上面所讲的部分。 浮动（float） 对于浮动定位方案, 盒称为浮动盒（floating boxes）。它位于当前行的开头或末尾。这导致常规流环绕在它的周边，除非设置 clear 属性。 要使用浮动定位方案，元素 CSS 属性 position 必须为 static 或 relative，然后 float 不为 none 。如果 float 设为 left, 则浮动定位到当前位置的开始位置，如果设为 right, 则浮动定位到当前位置的最后位置。 绝对定位（absolute position） 如果元素的属性 position 不是 static 或 relative， 那它就是绝对定位元素。 对于绝对定位方案，盒从常规流中被移除，不影响常规流的布局。 它的定位相对于它的包含块，定位坐标可通过属性 top、bottom、left、right 来设置 。 固定定位元素(fixed positioned element)也是绝对定位元素，它的包含块是视口。当页面滚动时它固定在屏幕上，因为视口没有移动。 float 及如何清除浮动元素浮动最开始的目的，就是实现文字环绕元素的效果 float的取值包括，none | left | right 。 浮动带来的问题：父元素高度塌陷。 如何清除浮动 清除浮动主要是为了解决由于浮动元素脱离文流导致的元素重叠或者父元素高度坍塌的问题，而这两个问题分别对应了需要清除浮动的两种种情况：清除前面兄弟元素浮动和闭合子元素浮动（解决父元素高度坍塌）。 清除前面兄弟元素浮动 清除前面兄弟元素浮动很简单，只需要在不想受到浮动元素影响的元素上使用 clear:both 即可。 在 CSS2 以前，clear 的原理为自动增加元素的上外边距（margin-top）值，使之最后落在浮动元素的下面。在 CSS2.1 中引入了一个清除区域（clearance）——在元素上外边距之上增加的额外间距，使之最后落在浮动元素的下面。 所以如果需要设置浮动元素与 clear 元素的间距，得设置浮动的元素的 margin-bottom，而不是 clear 元素的 margin-top。 闭合子元素浮动 我们知道，在计算页面排版的时候，如果没有设置父元素的高度，那么该父元素的高度是由他的子元素高度撑开的。但是如果子元素是设置了浮动，脱离了文档流，那么父元素计算高度的时候就会忽略该子元素，甚至当所有子元素都是浮动的时候，就会出现父元素高度为 0 的情况，这就是所谓的父元素高度坍塌问题。 为了能让父元素正确包裹子元素的高度，不发生坍塌，我们需要闭合子元素的浮动。 一般我们有两种办法可以用来闭合子元素浮动： 给最后一个元素设置 clear: both 给父元素新建一个 BFC(块格式化上下文) 方法一：由于我们最后一个元素使用 clear:both，所以该元素就能不受浮动元素影响出现在父元素的最底部，而父元素计算高度的时候需要考虑到这个正常元素的位置，所以高度自然包裹到了最底部，也就没有了坍塌。 对于这个方法，以前我们是利用新增一个空元素（&lt;b&gt; 或 &lt;span&gt; 或 &lt;div&gt; 等）来实现的，如下： 1234567891011&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;span class=\"clear-box\"&gt;&lt;/span&gt;&lt;/div&gt;.box &#123; float: left;&#125;.clear-box &#123; clear: both;&#125; 虽然这种办法比较直观，但是不是很优雅，因为增加了一个无用的空白标签，比较冗余而且不方便后期维护（一般不太建议使用该办法）。所以后期有了通过父元素的伪元素（::after）实现的著名 clearfix 方法，代码如下： 123456789&lt;div class=\"container clearfix\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/div&gt;.clearfix::after &#123; content:\"\"; display:table; clear: both;&#125; 方法二：该方法的原理是：父元素在新建一个 BFC 时，其高度计算时会把浮动子元素的包进来。下面这些都可以创建一个 BFC： 根元素或其它包含它的元素 浮动 (元素的 float 不是 none) 绝对定位的元素 (元素具有 position 为 absolute 或 fixed) 内联块 inline-blocks (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) 块元素具有overflow ，且值不是 visible display: flow-root 虽然有这么多方法可用，可我们常用的就是 overflow: hidden，代码如下： 12345678910&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/div&gt;.container &#123; overflow: hidden;&#125;.box &#123; float: left;&#125; float 布局常见的float布局有，两栏布局、三栏布局、流动布局。 两栏布局：一栏固定宽度并设置浮动，另一栏可设置宽度并浮动，也可不设置宽度不浮动。 三栏布局：三栏均设置宽度并浮动。 流动布局：最外层容器设置margin左右值为auto；中间一栏设置左右margin值以给左右两栏预留位置；三栏均设置浮动，并且左右两栏根据margin-left来调整位置使其在中间栏的margin上。（左边栏为margin-left:-100%;右边栏为margin-left:-margin值。） 网格布局系统参考：960网格布局官网 960s 是网格布局系统的鼻祖，当然随着技术的发展，基于它又发展了很多其他的网格布局系统，但是思想是想通的，无非是整体多少宽度分成几分，间距是多少，如何组合等。为什么是12列呢？因为12可以被2，3，4，6整除，这样做等分的时候是非常方便的。 position 属性position —— 设置元素的定位方式。四种取值： static（静态） relative（相对）—— 相对于自己的位置偏移 absolute（绝对）—— 相对于非static最近的父元素偏移 fixed（固定）—— 一般来说相对于视窗偏移 z-index 属性 网页正常文档流排版可以理解为在一个平面立面里面，元素占据空间，依次排列，互不覆盖。但是当页面中元素设置了定位属性的时候，难免会出现元素之间相互重叠的情况。 z-index 属性用于指定已定位元素在垂直于页面方向的排列顺序，其属性值有2种：auto（默认值）和整数。这里有2个需要注意的点： z-index 属性只对定位元素元素生效，也就是 position 属性不为 static 的元素。 除了默认值 auto， z-index 可以设置为任意整数，正数，0，负数都可以。 一般情况下，z-index 值进行比较有下面2条规则： 数值大的在上面(auto 数值上相当于0)。 数值相同的，在 HTML 结构中排后面的在上面。 层叠规则： 默认HTML结构顺序。 position（非static值）元素高于其他元素。 position（非static值）元素之间先通过z-index值判断。 如果z-index相同则按照HTML结构顺序。 层叠上下文 上面说到，z-index 默认值 auto 数值上等于0，那设置了 z-index:0 和 默认的 z-index:auto; 有没有区别呢？ 答案是有区别的。区别在于设置了 z-index 属性为整数值(包括0)的元素，自身会创建一个层叠上下文。而创建一个层叠上下文之后，其子元素的层叠顺序就相对于父元素计算，不会与外部元素比较。即并不是所有情况 z-index 值大的元素都会在上面，我们在进行 z-index 比较的时候要留意其祖先元素有没有建立独立的层叠上下文，z-index 只有在同一个层叠上下文中比较才有意义。 另外，对定位元素设置 z-index 属性不是唯一创建层叠上下文的方法，具有下面属性的元素都会创建层叠上下文（具体可参看：层叠上下文 | MDN）： 根元素 (HTML) z-index 值不为 &quot;auto&quot;的 绝对/相对定位 一个 z-index 值不为 &quot;auto&quot;的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex opacity 属性值小于 1 的元素 transform 属性值不为 &quot;none&quot;的元素， mix-blend-mode 属性值不为 &quot;normal&quot;的元素， filter值不为“none”的元素， perspective值不为“none”的元素， isolation 属性被设置为 &quot;isolate&quot;的元素， position: fixed 在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考这篇文章） -webkit-overflow-scrolling 属性被设置 &quot;touch&quot;的元素 可参考：深入理解CSS中的层叠上下文和层叠顺序 、理解CSS的 z-index属性 。 flexbox 布局当给父元素设置display:flex属性后，其直接子元素会形成一个flexbox布局模型，可以非常容易的去排列子元素。父元素成为flex container，子元素称为flex item。 flex container 属性： flex-direction(主轴方向) : row | row-reverse | column | column-reverse flex-wrap(一条主轴排满后是否换行) : nowrap | wrap | wrap-reverse justify-content(主轴上的对齐方式) : flex-start | flex-end | center | space-between | space- around align-items(交叉轴的对齐方式) : stretch | flex-start | flex-end | center | baseline align-content(多根轴线对齐方式) : stretch | flex-start | flex-end | center | space-between | space-around flex item 属性： order(排列顺序) flex-grow(放大比例) flex-shrink(缩小比例) flex-basis(item所占主轴空间，会覆盖width) align-self(对齐方式，会覆盖align-items) 可参考：Flexbox playground 剩余空间分配相关属性 flexbox 布局中的子元素可以通过设置 flex 属性来改变其所分配到的空间大小。flex 属性包括了 flex-basis、 flex-grow、flex-shrink 。 flex-basisflex-basis 用来定义子元素的默认宽或高。如果父容器 flex-direction 属性的方向为水平方向则为宽度，如为垂直方向则为高度。相当于给子元素设置宽或高。如果同时设置了该属性与宽或高，则该属性权重大于宽或高的值。 flex-growflex-grow 用来指定父容器多余空间的分配比率，默认值为0。如果子元素的宽度的总和超过父容器，flex-grow 将不生效。 flex-shrinkflex-shrink 用来指定父容器空间不够时子元素的缩小比例，默认为1。如果一个 flexbox 项目的 flex-shrink 属性为0，则该元素不会被压缩。 关于flexbox布局，可参考：Flex布局教程：语法篇 、 Flex 布局教程：实例篇 grids 布局系统随着 CSS 的不断发展及完善，一种新的网格布局方式被纳入规范，它将会解决所有的网格问题，这就是我们要说的 CSS Grid Layout。 Grid Container：首先我们要设置父元素的布局为 grid，通过使用 display 属性给元素显式设置属性值grid或inline-grid，此时这个元素将自动变成网格容器，对应上图的Sheet1 Grid Item：Item 是 container 的直接子元素，如果不考虑单元格的合并跟下面的 cell 是一样的，如果有单元格合并，在该 item 可能包括几个cell，对应上图的一个个格子，如蓝色的 A1 Grid Lines：网格线分为水平线和垂直线，对应上图的橙色线条 Grid Track：就是由lines构成的水平和垂直空间，对应到上图的水平和垂直灰色区域，而对于table来说就是row和column Grid Cell：简单来说就是单元格了，对应到上图就是蓝色的A1，而对于table来说就是单元格 Grid Area：网格区域是由任意四条网格线组成的空间，可能由一个或多个单元格组成。对应到上图就是红色区域，相当于表格中的合并单元格之后的区域 网格系统基本属性 网格系统布局其实跟 flexbox 布局差不多，都是由父子元素构成的布局。所以属性分为父元素属性和子元素属性。 可参考：A Complete Guide to Grid 父元素（Grid Container）属性: 第一类：如何去定义一个网格系统，行列及间距等。 display：grid/inline-grid，定义使用网格系统 grid-template-columns：定义垂直栏 grid-template-rows：定义水平行 grid-template-areas：定义区域 grid-column-gap：定义垂直栏与垂直栏之间的间距，如上图的A与B之间的间距 grid-row-gap：定义水平行与水平行之间的间距，如上图的1与2之间的间距 grid-gap：上面两个栏与行间距的缩写 第二类：自动分配形式，当定义的行或列数量不够时，多出 item 的自动排列方式： grid-auto-columns：定义多出的 item 的自动column的宽度大小 grid-auto-rows：定义多出的 item 自动 row 的高度大小 grid-auto-flow：定义自动 item 是按照先水平方向排列还是垂直方向排列 分布对齐的方式（属性跟 flexbox 的有点像）。 justify-items：item 在水平行中的对齐方式 align-items：item 在垂直栏中的对齐方式 justify-content：整个水平行在 grid 范围的对齐方式，这里有个好用的 space-evenly 值，补足了以前flex的 space-around 和 space-between 的不足 align-content：整个垂直栏在 grid 范围的对齐方式 子元素（Grid Item）属性： 单元格所占格子多少 grid-column-start：item 的起始栏 grid-column-end：item 的结束栏 grid-column：起始栏和结束栏的简写 grid-row-start：item 的起始行 grid-row-end：item 的结束行 grid-row：起始行与结束行的简写 grid-area：item所在区域 单元格的自定义对齐方式，这个跟 flexbox 的 item 有点相似。 justify-self：自定义 item 的水平方向对齐方式 align-self：自定义 item 的垂直方向对齐方式 浏览器是如何渲染 HTML&amp;CSS 的 我们现在已经知道，使用 HTML &amp; CSS 可以搭建出一个漂亮的 Web 页面。那么浏览器到底是如何使用我们的 HTML &amp; CSS 渲染成我们在屏幕上所看到的页面呢？ 虽然具体渲染过程很复杂，但是还是可以将其分为几个关键路径，如下： 处理 HTML 标记并构建 DOM 树 处理 CSS 标记并构建 CSSOM 树 将 DOM 与 CSSOM 合并成一个渲染树 根据渲染树来布局，以计算每个节点的几何信息，再将各个节点绘制到屏幕上 构建 DOM 树 首先浏览器渲染页面前会根据 HTML 结构构建成对应的 DOM 树。以下面的 HTML 代码为例： 1234567891011&lt;html&gt; &lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; &lt;link href=\"style.css\" rel=\"stylesheet\"&gt; &lt;title&gt;Critical Path&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src=\"awesome-photo.jpg\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 其 DOM 树生成的流程如下图： 转换： 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。 令牌化： 浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，“”、“”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。 词法分析： 发出的令牌转换成定义其属性和规则的“对象”。 DOM 构建： 最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。 整个流程的最终输出就是我们这个简单页面的文档对象模型 (DOM)，如下图： 构建 CSSOM 树 在浏览器构建上面的 DOM 时，在文档的 head 部分遇到了一个 link 标记，该标记引用一个外部 CSS 样式表：style.css。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容： 1234567/* style.css */body &#123; font-size: 16px &#125;p &#123; font-weight: bold &#125;span &#123; color: red &#125;p span &#123; display: none &#125;img &#123; float: right &#125; 与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 过程，不过是为 CSS 而不是 HTML： CSS 字节转换成字符，接着转换成令牌和节点，最后挂靠到一个称为“CSS 对象模型”(CSSOM) 的树结构内： CSSOM 为何具有树结构？这是因为浏览器为页面上的任何对象计算最后一组样式时，都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式），然后通过应用更具体的规则（即规则“向下级联”）以递归方式优化计算的样式。 合并渲染树接下来就是将 DOM 树与 CSSOM 树合并形成渲染树。渲染树会网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。 渲染树只包含渲染网页所需的节点，如display: none;的元素是不会出现在渲染树种的。 布局及绘制有了渲染树，我们就可以进入“布局”阶段。到目前为止，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们尚未计算它们在设备视口内的确切位置和大小——这就是布局阶段，也称为自动重排。 为弄清每个对象在网页上的确切大小和位置，浏览器从渲染树的根节点开始进行遍历。让我们考虑下面这样一个简单的实例： 1234567891011&lt;html&gt; &lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; &lt;title&gt;Critial Path: Hello world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=\"width: 50%\"&gt; &lt;div style=\"width: 50%\"&gt;Hello world!&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 以上网页的正文包含两个嵌套 div：第一个（父）div 将节点的显示尺寸设置为视口宽度的 50%；而里面内嵌的第二个 div 将其宽度设置为其父项的 50%，即视口宽度的 25%。如下图： 布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素。 最后，既然我们知道了哪些节点可见、它们的计算样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素形成我们可见的页面。这一步通常称为绘制或栅格化。 重排与重绘一个页面渲染完毕后，随着用户的操作，或者数据变化，网页还会进行重新渲染。根据不同的触发条件，重新渲染分为两种情况：重排（reflow）和重绘（repaint）。 所有对元素视觉表现属性的修改，都会导致重绘（repaint）。比如修改了背景颜色、文字颜色等。 所有会触发元素布局发生变化的修改，都会导致重排（reflow）。比如窗口尺寸发生变化，删除、添加 DOM 元素，修改了影响元素盒子大小的 CSS 属性如 width、 height、 padding 等。 通常情况下，重排的影响更大，重排会导致文档局部或全部的重新运算：重新计算元素位置，大小。（改变一个元素的布局，可能会影响很多个元素的布局） 不管是重绘还是重排导致的重新渲染，都会阻塞浏览器。重新渲染的的过程中，JavaScript 会被阻塞，用户的交互行为也会被卡住。复杂的 CSS 动画甚至会拖慢 JavaScript 的运行速度。 导致重排和重绘的场景 CSS 属性改变,包括但不限于以下场景： 通过 display: none 隐藏 DOM 节点（导致重绘和重排） 通过 visibility: hidden 隐藏 DOM 节点 （导致重绘，因为它没有影响其它元素位置布局） CSS 动画 通过 JavaScript 添加样式，修改样式 可参考：CSS triggers（ 注：Composite （渲染层合并） 是 chrome 引入 GPU 加速带来的新概念。） 用户交互 对浏览器窗口进行缩放操作会导致重排 对 DOM 节点进行操作，添加、删除、更新 DOM 节点都会导致重排 光标 :hover 、进入文本输入框、修改浏览器的字体都会导致重排 最佳实践（减少重新渲染）所有的最佳实践都是围绕尽最大可能的降低重绘和重排的频率，来达到减少重新渲染的目的。 CSS 属性的读、写操作分开 浏览对 CSS 属性的连续修改做了优化，比如下面的连续修改两次 style，不会导致两次重新渲染： 12div.style.color = 'blue';div.style.marginTop = '30px'; 上面代码只会进行一次重新渲染。但是如果写的不好，则会触发两次重新渲染，如下： 123div.style.color = 'blue';var margin = parseInt(div.style.marginTop);div.style.marginTop = (margin + 10) + 'px'; 上面代码对 div 元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不重新渲染然后得到该元素的位置。 除此之外，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染： offsetTop/offsetLeft/offsetWidth/offsetHeight scrollTop/scrollLeft/scrollWidth/scrollHeight clientTop/clientLeft/clientWidth/clientHeight getComputedStyle() 通过 class 或者 csstext 来批量更新样式 上面对通过对 style 对 CSS 属性一个一个修改，其实更好的方式应该是通过 class 来批量化。 1234567891011// badvar left = 10;var top = 10;el.style.left = left + \"px\";el.style.top = top + \"px\";// good el.className += \" theclassname\";// goodel.style.cssText += \"; left: \" + left + \"px; top: \" + top + \"px;\"; 其他方法 DOM 样式离线更新：尽量使用离线 DOM，而不是真实的网页 DOM 来改变元素样式。比如，操作 Document Fragment对象，完成后再把这个对象加入 DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。 使用 display: none 进行样式批量更新：先将元素设为 display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。 善用 position：position 属性为 absolute 或 fixed 的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。 将元素设置为不可见：只在必要的时候，才将元素的 display 属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden 的元素只对重绘有影响，不影响重排。 减少样式的更新频率：使用虚拟 DOM 脚本库，比如 React 等。 调节 js 运行帧率：使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染的频率。 慎用 table 布局：table 的单元格具有非常好的自适应特性，但是同时代价也很高，能不用就不用。如果非要使用 table ，给 table 添加 table-layout: fixed 属性，这个属性的目的是让后面单元格的宽度由表头的宽度来决定——减少布局的计算量。 可参考：网页性能管理详解 、 无线性能优化：Composite","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ice-io.github.io/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://ice-io.github.io/tags/HTML/"}]},{"title":"前端知识总结——CSS基础篇","slug":"前端知识总结——CSS基础篇","date":"2017-08-10T14:35:46.000Z","updated":"2017-09-07T07:52:08.098Z","comments":true,"path":"2017/08/10/前端知识总结——CSS基础篇/","link":"","permalink":"http://ice-io.github.io/2017/08/10/前端知识总结——CSS基础篇/","excerpt":"这一篇文章将回顾之前所学的CSS基础知识。","text":"这一篇文章将回顾之前所学的CSS基础知识。 认识CSS CSS，即Cascading Style Sheet，层叠样式表，用来修饰网页。 CSS语法h1{color:red;font-size:20px}包含选择器、属性、属性值，当然最好写成下面的样子方便阅读和维护： 1234h1 &#123; color: red; font-size: 20px;&#125; CSS注释 单行注释：/* 注释内容 */ 多行注释： 1234/* 注释 内容*/ 引入CSS 行内样式（通过标签的style属性）——[缺点：样式结构混在一起；冗余；] 内联样式（通过style标签写入CSS）——[缺点：冗余；] 行内样式（通过link标签引入CSS文件）——[解决了前两种方式的缺点] 但是，这三种方式，各有其应用场景。另外要注意@import引入方式的缺点： 范畴不同：link标签引入属于HTML，@import则属于CSS。 兼容性：@import不兼容旧版浏览器。 加载顺序：@import需要等到文档最后才加载。 脚本操作：@import不支持JavaScript的修改操作。 CSS中的选择器总共分为5大类： 基础选择器、关系选择器、伪类选择器、属性选择器、伪元素选择器。使用时注意选择器分组→→→将相同样式分组定义共用，简化代码。可参考：CSS选择器参考手册 基础选择器 通用选择器(*) 元素选择器(p) 类选择器(.class) id选择器(#id) 关系选择器 子代选择器(div&gt;p) 后代选择器(div p) 兄弟选择器(div~p 、div+p) 伪类选择器 :link :visited :hover :active :first-child :last-child :nth-child(n) :nth-lastchild(n) 伪元素选择器 ::before ::after ::first-letter ::first-line 属性选择器 选择器 描述 [attribute] 用于选取带有指定属性的元素 [attribute=value] 用于选取带有指定属性和值的元素 [attribute\\^=value] 匹配属性值以指定值开头的每个元素 [attribute$=value] 匹配属性值以指定值结尾的每个元素 [attribute*=value] 匹配属性值中包含指定值的每个元素 [attribute~=value] 用于选取属性值中包含指定词汇的元素 [attribute&#124;=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词 选择器的优化 现在我们知道了选择器有很多种，但是对于浏览器来说，解析每种选择器所耗费的时间并不是一样的。所以当我们使用选择器的时候也有必要了解如何才能写出最优选择器。 各种 CSS 选择器的效率由高至低排序如下： id选择器（#myid） 类选择器（.myclassname） 标签选择器（div,h1,p） 相邻选择器（h1 + p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（*） 属性选择器（a[rel=&quot;external&quot;]） 伪类选择器（a:hover,li:nth-child） 选择器的解读顺序是怎样的？ 一般来说，在具体的项目中，HTML 结构都比较复杂，所以关系选择器使用非常的普遍。对于关系选择器来说，我们的阅读习惯是从左到右，但是浏览器解读选择器，遵循的原则是从选择器的右边到左边读取。 如对于选择器.list .item .item-tt，浏览器先找的是.item-tt，然后继续向父级元素寻找.item，再找.list，这样才完成了最终的选择器匹配。所以如果路径链越短，效率也就相应有所提高。这里建议选择器的层级最多不要超过4层，如.demo .list .item .item-tt .tt-link就有5层了，可根据实际情况考虑缩短为4层以内，如.demo .item-tt .tt-link。 如何提高CSS选择器性能呢？ CSS选择器对性能的影响源于浏览器匹配选择器和文档元素时所消耗的时间，所以优化选择器的原则是应尽量避免使用消耗更多匹配时间的选择器。 可以通过以下几点来优化： 避免使用通用选择器 避免使用标签或 class 选择器来限制 id 选择器 避免使用标签限制 class 选择器 避免使用多层标签选择器。使用 class 选择器替换，减少css查找 避免使用子选择器 使用继承 CSS中的属性和值字体相关属性 font-family：定义文本的字体，如：font-family: arial; font-size：字体尺寸，如：font-size: 18px; font-style ：字体样式，如：font-style: italic; font-weight：字体的粗细，如：font-weight: bold; 文本相关属性 color：定义文字颜色，如：color: red; line-height：设置行高，如：line-height: 1.5; text-align：文本的水平对齐方式，如：text-aligin: center; text-decoration：文本的装饰效果，如：text-decoration: underline; text-indent：首行的缩进，如：text-indent: 2em; text-shadow：文本的阴影效果，如：text-shadow: 0 0 5px #ff0000; 列表属性 list-style：在一个声明中设置所有的列表属性 list-style-image：将图象设置为列表项标记 list-style-position：设置列表项标记的放置位置 list-style-type：设置列表项标记的类型 表格属性 border-collapse：是否合并表格边框 border-spacing：相邻单元格边框之间的距离 table-layout：设置表格的布局算法 盒子大小 width min-width max-width height min-height max-height box-sizing 盒子边框 border：简写模式，四边边框 border-width：边框宽度 border-style：边框样式，常用的为solid和dashed border-color：边框颜色 border-top：上边框 border-right：右边框 border-bottom：下边框 border-left：左边框 盒子内外边距 margin margin-top margin-right margin-bottom margin-left padding padding-top padding-right padding-bottom padding-left 盒子背景 background：总的简写形式，包括了下面各个单条属性 background-color：背景色 background-image：背景图片 background-position：背景图片起始位置 background-repeat：背景图片平铺方式 background-size：背景图片大小 background-clip：背景图片绘制区域 background-origin：背景图片的定位区域 盒子其他 overflow：指定当内容溢出其块级容器时,是否剪辑内容，渲染滚动条或显示内容 visibility：是否可见 border-radius：圆角 box-shadow：阴影 空间位置相关 display float clear position top right bottom left transform z-index opacity 动画相关 transition animation 可参考:CSS 参考 | MDN 、CSS 参考手册 | W3school 自定义字体 一般来说，网页上的字体使用的都是我们电脑里面的字体，比如我们常说的微软雅黑、宋体就是 windows 系统自带的字体。所以你可以看到网页的字体一般都比较中规中矩，不像平面设计那样各种新花样。但是我们在浏览一些网站时，还是可以发现一些非常酷炫和高端的字体。 那么如何实现自定义字体的效果呢？答案是 CSS 的 @font-face 。 @font-face 的语法规则如下： 123456@font-face &#123; font-family: &lt;fontFamily&gt;; /* 自定义的字体名称; */ src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*; /* 自定义的字体的存放路径、格式; */ [font-weight: &lt;weight&gt;]; /* 是否为粗体 */ [font-style: &lt;style&gt;]; /* 定义字体样式，如斜体 */&#125; 其取值说明如下： fontFamily：此值指的就是你自定义的字体名称，如font-family: myFirstFont。 source：此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝对路径。 format：此值表达自定义的字体的格式，用于帮助浏览器识别字体类型。 weight和style：这两个值大家一定很熟悉，weight 定义字体是否为粗体，style 主要定义字体样式，如斜体。 推荐：dafont字体 字体格式 TrueType (.ttf) Windows 和 Mac 系统最常用的字体格式，其最大的特点就是它是由一种数学模式来进行定义的基于轮廓技术的字体，这使得它们比基于矢量的字体更容易处理，保证了屏幕与打印输出的一致性。同时，这类字体和矢量字体一样可以随意缩放、旋转而不必担心会出现锯齿。 OpenType (.otf) OpenType 是一种可缩放字型（scalable font）电脑字体类型，采用 PostScript 格式，是美国微软公司与Adobe 公司联合开发，用来替代 TrueType 字型的新字型。这类字体的文件扩展名为.otf，类型代码是 OTTO。 Embedded Open Type (.eot) 嵌入字体格式（EOT）是微软开发的一种技术，允许 OpenType 字体嵌入到网页并可以下载至浏览器渲染。这些文件只在当前页活动的状态下，临时安装在用户的系统中。 Web Open Font Format (.woff) 相对于 TrueType 和 OpenType ，WOFF（Web开发字体格式）是一种专门为了 Web 而设计的字体格式标准，它并不复杂，实际上只是对于 TrueType / OpenType 等字体格式的封装，并针对网络使用加以优化：每个字体文件中含有字体以及针对字体的元数据（ Metadata ），字体文件被压缩，以便于网络传输，并且不包含任何加密或者 DRM 措施。 Scalable Vector Graphics Fonts (.svg) 顾名思义，就是使用SVG技术来呈现字体，还有一种 gzip 压缩格式的 SVG 字体 .svgz。 这么多字体带来的问题是浏览器的支持：目前现代浏览器基本都支持 .ttf、 .otf、 .woff 的字体格式。但需要注意的是 IE8以下仅支持 .eot 格式，而 .svg 目前只有 safari 支持。 自定义图标字体（iconfont） 我们经常会在网页中使用这些图标，以前主要是通过背景图去做的，每次换个颜色或改个大小就得重新切个图，所以维护使用比较繁琐。这样图标字体就应时而生，它提供了一种解决方案：把一些简单的图标制作成字体，然后让图标变成和文字一样可以通过 CSS 去改变颜色大小等。 对于使用图片的图标来说，iconfont 图标有许多优点： 灵活性：改变图标的颜色，背景色，大小都非常简单 兼容性：基本没有兼容性问题，在IE6，Android2.3都能够兼容 扩展性：替换图标很方便，新增图标也非常简单 高效性：iconfont有矢量特性，不会失真 轻便性：在使用上字体文件和普通的静态资源一样，既可以外链也可以内链，并且字体文件也可以使用gzip压缩推荐：Fontello CSS中的单位 pxpx 是 pixels（像素）的缩写，是一种绝对单位，用于屏幕显示器上，传统上一个像素对应于计算机屏幕上的一个点，而对于高清屏则对应更多。任何现代显示屏，不管是手机，平板，笔记本还是电视都是由成千上万的像素组成的，所以我们可以使用这些像素来定义长度。 %%（百分比）应该是我们最好理解的单位了，即相对于父元素。 如果对 html 元素设置 font-size 为百分比值，则是以浏览器默认的字体大小16px为参照计算的（所有浏览器的默认字体大小都为 16px），如62.5%即等于10px（62.5% * 16px = 10px）。 emem 也是一种相对单位，既然是相对单位，那么肯定有一个参照值。不过其参照值并不是固定不变的，而是不同的属性有不同的参照值。 对于字体大小属性（font-size）来说，em 的计算方式是相对于父元素的字体大小，1em 等于父元素设置的字体大小。如果父元素没有设置字体大小，则继续往父级元素查找，直到有设置大小的，如果都没有设置大小，则使用浏览器默认的字体大小。 在(border, width, height, padding, margin, line-height)这些属性中，使用em单位的计算方式是参照该元素的 font-size，1em 等于该元素设置的字体大小。同理如果该元素没有设置，则一直向父级元素查找，直到找到，如果都没有设置大小，则使用浏览器默认的字体大小。 rem和 em 一样，rem 也是一种相对单位，不过不一样的是 rem 是相对于根元素 html 的 font-size 来计算的，所以其参照物是固定的。（rem的r就是表示root，虽然rem相对em进步了很多，但是由于是新技术，不支持IE8以下（包括IE8）,不过幸喜的是移动端可以放心使用） 由于 rem 是基于跟元素 html 的 font-size 来计算的，所以如果改变 html 的 font-size 值，那么所有使用的 rem 单位的大小都会随着改变，这对于移动端适应各种屏幕大小来说还是有点作用的。 vw, vh, vmin, vmax这四个单位属于 v 系单位，它们也是相对单位，是基于视窗大小（浏览器用来显示内容的区域大小）来计算的。 网页中我们很多时候都需要用到满屏，或者屏幕大小的一半等，尤其是移动端，屏幕大小各式各样，而这个时候我们现有的单位就显得有点捉襟见肘，于是就诞生了这四个单位。 vw：基于视窗的宽度计算，1vw 等于视窗宽度的百分之一 vh：基于视窗的高度计算，1vh 等于视窗高度的百分之一 vmin：基于vw和vh中的最小值来计算，1vmin 等于最小值的百分之一 vmax：基于vw和vh中的最大值来计算，1vmax 等于最大值的百分之一 单位运算除了设置以上的单位之外，我们还可以使用 calc 来进行单位运算，单位运算时可以使用各种单位进行加减乘除运算。简单示例如下： 12345.box &#123; height: calc(50vh - 20px); /* 50% 的视窗高度减掉20px */ width: calc(100% / 3); /* 三分之一的父容器宽度 */ background: red;&#125; CSS中的颜色 颜色关键词如 red，green，gray 等，除此之外，还有两个关键词可用，分别是 transparent 和 currentColor。 RGB表示使用红-绿-蓝模式来定义颜色。 十六进制十六进制颜色表现形式为： #RRGGBB 和 #RGB RGBa在 rgb 的基础上，还可以添加一个 alpha 透明度表示半透明值，这样就构成了我 rgba，其函数表示为：rgb(red, green, blue, alpha)，其中 alpha 参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。 hsl除了使用红-绿-蓝的模式定义颜色之外，还可以通过 hue（色调）、saturation（饱和度）、lightness（亮度）模式定义颜色，其语法为：hsl(hue, saturation, lightness) 。 CSS中的盒模型HTML文档中的每个元素在渲染的时候都会被描绘成一个矩形盒子，而盒模型正是用来表示每个元素盒子所占用空间大小的模型。 在我们现实生活中，描述一个矩形直接用宽和高即可。但是在CSS中主要通过四个部分来描述，分别为：margin（外边距），border（边框），padding（内边距），content（内容区域）。如下图： 盒模型计算方式 一般来说，默认的盒模型实际占用空间计算模式为： 水平空间大小 = margin(左右) + border(左右) + padding(左右) + width 垂直空间大小 = margin(上下) +border(上下) + padding(上下) + height 因为外边距(margin)为元素之间的距离，所以如果扣除它，则一个元素的实际大小就是 border + padding + width/height 。 这种计算模式在对于非 px 为单位的宽高设置时，会带来非常大的计算困扰。如下： 1234.box &#123;width: 50%;border: 1px solid #ccc;&#125; 我们想要的肯定是50%，但是实际的大小却是 50% + 2px ，这多出的 2px 就很让人无奈了，于是为了不破坏这 50% 的宽度，往往得再内嵌一层元素用来设置 border ，就成了下面这样： 123456.box &#123;width: 50%;&#125;.box .box-inner &#123;border: 1px solid #ccc;&#125; 这种解决方式显然不太科学，至少导致了 HTML 结构的臃肿，而 box-sizing 属性的出现就解决了这个问题，它就是用来改变元素宽高的计算方式。 box-sizing 属性有两个常用的取值 content-box 和 border-box 。 如为 content-box （这也是默认值）则实际宽度为上面所说的计算方式：实际宽高 = border + padding + width/height 。 如为 border-box 则是另一种计算方式，其实际宽高就是设置的 width/height 。 了解盒模型的计算方式是非常重要的，现在的网页，尤其是移动端的页面，需要适应于不同的屏幕大小，所以一般都会提前设置所有元素的盒模型都为 border-box 模式，以方便以后宽高的计算。代码设置如下： 123* &#123; box-sizing: border-box;&#125; 盒模型相关属性 上面已经说了 box-sizing 属性可以控制元素宽高的计算方式，除此之外，盒模型还有下面几个相关属性需要掌握： width(包括min-width, max-width)：宽 height(包括min-height, max-height)：高 padding：内边距 border：边框 margin：外边距上面五大属性，除了 width 和 height 以外，padding、border 和margin 属性都是由四边组成的，每边都可以设置自己的单独值，还可以简写。 我们先说下盒模型的四边，方向分别为上、下、左、右，而 CSS 中表示就分别是 top、bottom、left、right，如下图表示： 首先，我们可以单独给每个方向设置各自的margin，分别对应我们下面四个属性： margin-top：top 方向单个值 margin-right：right 方向单个值 margin-bottom：bottom 方向单个值 margin-left：left 方向单个值 很显然，如果四个方向都有值的话，上面四个每个都要写一次是一件多么费力的事，于是我们又有了一条总的属性 margin margin：a b c d; 表示四个方向的值 margin: 10px; 表示四个方向的值都是10px 123456789101112/* 简写之前 */.box &#123;margin-top: 10px;margin-right: 20px;margin-bottom: 30px;margin-left: 40px;&#125;/* 简写之后 */.box &#123;margin: 10px 20px 30px 40px; /* 注意顺序以top开始，顺时针方向 */&#125; 这种取值模式其实并不是 margin 所独有的，同样 padding 也是按照这个模式来的。而且是一模一样的，而 border 相对来说还要更复杂点，border的简写，其简写模式为：border: 1px solid #ccc;。 border 的简写其实是由 border-width，border-style，border-color 三个属性组合而成的。1px 就是 border-width，solid 就是 border-style，#ccc 就是 border-color。 而这三个属性，它们如果单独来写，其取值模式就和margin是一样的了，都可以设置1-4个值，如： 12345.box &#123;border-color: #f00 #ccc #ccc; /* top left和right bottom */border-width: 2px 1px; /* top和bottom left和right*/border-style: solid; /* all */&#125; 除此之外，border当然也有表示方向的属性，如border-left: 1px solid #f00;，则表示左边框为1px红色的实线。同样还有border-top，border-right，border-bottom。而方向又可以和边框属性结合，如border-top-width，border-top-style，border-top-color。 所以，如果我们要设置不一样的边框，一般可以先设置个默认一样的，然后再通过单边的，或者通过border-width，border-style，border-color去特殊设置 。 CSS中元素的显示与隐藏 display属性 所有的后代元素都隐藏 元素隐藏后不再占用空间 visibility属性 元素所占的空间位置不变，可理解为元素透明了 如子元素设为visibility:visible，则该子元素依然可见 overflow属性 规定了当内容元素溢出父容器时的展现形式 裁剪内容，使用滚动条来显示或直接显示超出部分 CSS中的背景简写(推荐)： background 分步写： background-color background-image background-repeat background-position background-size CSS中的图片图片作为网页必不可少的一部分，在网页中占据着非常重要地位。一般来说，有以下两种方式来使用图片： 通过 img 元素直接使用 通过 background-image（背景图片）的形式使用 这两种形式的区别在于，前者一般具有实际含义（如产品图片，相册图片等），而后者一般用于装饰效果。 目前网页中常用的图片大概有如下几种格式，它们有着各自的显著特点，被应用在各种不同的场景： jpg/jpeg：由于其色彩还原度比较好，所以一般色彩丰富的图片均采用该格式，如宣传图、产品图、相册图等等。 png：由于其对透明度的良好支持，所以一般用于透明图片，如 logo 图、图标图等。 gif：由于其对动画的支持，所以一般用来实现动效图片，如 loading 加载动画、一些搞笑图片等。 ico 格式属于图标文件，主要用于网址前面的标识图标。 webp 格式是由 google 研发的图片格式，它既具备高压缩率，又具备透明度以及动画的特性。目前各个大互联网公司都有在使用该格式，其带来的效果也非常显著。但是该格式有个明显的缺陷：目前浏览器端只有 google 浏览器支持。 WebP 的优势 PNG 转 WebP 的压缩率要高于 PNG 原图压缩率，同样支持有损与无损压缩 转换后的 WebP 体积大幅减少，图片质量也得到保障（同时肉眼几乎无法看出差异） 转换后的 WebP 支持 Alpha 透明和 24-bit 颜色数，不存在 PNG8 色彩不够丰富和在浏览器中可能会出现毛边的问题 WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。 关于网页媒体文件可参考：网络媒体教程 | W3school 关于WebP可参考：WebP 探寻之路 、WebP 相对于 PNG、JPG 有什么优势？ 图片优化通过HTTP Archieve统计显示，图片内容已经占到了互联网内容总量的65%左右。如此多的图片，当然占用了很多流量及时间，所以从性能优化的角度看，图片绝对是优化的热点和重点之一。可参考：前端图片优化机制 雪碧图在网站开发中，我们经常会使用一些背景图片来点缀效果，如一些形象生动的小图标。这种背景图片一多，网络请求就多了。这样为了减少网络请求，我们把一些小的背景图合并在一个大的图中，然后通过 CSS 的背景定位技术去使用。我们把这种技术叫做 CSS Sprite，也叫雪碧图，还叫 CSS 精灵。 雪碧图的应用原理通过上面讲述，我们知道雪碧图是一张大的合并图，每个小图标其实只是截取大图的一部分来显示。如下图所示，我们有一张带有各种表情图标的雪碧图，其中每个表情图标都占领着相应的位置。 假如我们需要显示开心表情的这一个图标，我们需要计算开心图标在合并图中相应的位置和其图标的大小。以雪碧图的左上角为坐标中心，我们得出开心表情刚好在坐标的原点，即 X 轴0像素，Y 轴0像素的位置，且我们可以得出图标的宽高均为96像素。 因此我们设置这个图标元素的背景图片为这张雪碧图，背景位置为图标在雪碧图中的坐标，这样开心的图标就显示出来了。 12345678.happy &#123; display:inline-block; width: 96px; height: 96px; background-image: url(sprite.png); /* 设置背景图片 */ background-repeat: no-repeat; /* 设置为不平铺 */ background-position: 0 0; /* 设置图标位置 */&#125; 假如我们还要使用到哭泣的表情。同理所得，计算出哭泣的图标的位置在雪碧图的 X 轴向右192像素， Y 轴向下96像素。 12345678.cry &#123; display:inline-block; width: 96px; height: 96px; background-image: url(sprite.png); /* 设置背景图片 */ background-repeat: no-repeat; /* 设置为不平铺 */ background-position: -192px -96px; /* 设置图标位置 */&#125; 关于坐标的问题，可以这么理解：我们定义了一个视口，固定在大图的左上角，也就是（0，0），当我们想看到哪张小图的时候，就挪动大图使其移动到视口处。 雪碧图的制作制作雪碧图的方式有许多，大概有如下几种方法： 使用 photoshop 等图片编辑工具 在线工具 目前有许多在线合成雪碧图的站点，只需要将图片上传上去，便可以根据设置，生成想要的雪碧图以及对应的 CSS 样式文件，如 spritegen、css sprites generator。 甚至我们合好的图片，也可以通过 spritecow 来帮我们完成对应的 CSS 定位。 构建工具 除了上面两种，我们还可以通过如webpack, fis3, gulp等构建工具来完成雪碧图生成工作。可参考：webpack 自动雪碧图生成 、fis3 CssSprite图片合并 。 雪碧图与字体图标优劣 雪碧图的优势： 图标更美观 由于 iconfont 的图标只能设置单色，而雪碧图的图标由于是图片，所以能展现出更为美观的图标效果。 制作成本更低 iconfont 的制作较为麻烦，需要设计师按照规范，一一制作图标的 svg 文件。而雪碧图的制作只需合并图片即可，在制作成本上更低。 雪碧图的劣势： 高清屏下会失真（第三章会介绍） 在 2x 的设备像素比的屏幕上，如果要达到和文字一样的清晰度，图片的宽度需要实际显示大小的两倍，否则看起来会比较模糊。 雪碧图不方便变化 雪碧图本质上是一张静态的图片，因此无法灵活地通过样式去动态改变图片图标的颜色和其他效果。 CSS中的渐变背景在定义背景图片时，除了使用正常的图片之外，我们还可以通过 CSS3 的 gradient 去创造渐变背景图。同比使用图像的方案，使用 CSS3 gradient 来实现可以减少带宽和页面加载时间。 目前浏览器可以支持两种类型的渐变： 线性渐变 (linear)，通过 linear-gradient 函数定义 径向渐变 (radial)，通过 radial-gradient 函数定义 线性渐变 (linear-gradient) 线性渐变，即沿着一个方向线性的进行着颜色之间的平滑过渡的一个渐变过程。 为了创建一个线性渐变，你必须至少定义两种颜色，同时你也可以设置一个方向或一个角度。其标准语法如下： background: linear-gradient([ &lt;angle&gt; | to &lt;side-or-corner&gt;], color-stop, ..., color-stop); angle：表示线性渐变的角度，该角度是指水平线和渐变线之间的角度，以顺时针方向计算。换句话说，0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。 side-or-corner：表示方向关键词（top、right、bottom、left、left top、top right、bottom right 或 left bottom）。这个参数值可以省略，当省略不写的时候其取值为“to bottom”。 color-stop：表示渐变的色标，每个色标包含一种颜色和一个位置，位置可以被指定为线长度的百分比或一个绝对长度。为实现期望的效果，可以指定任意多个色标。 径向渐变 (radial-gradient)不同于线性渐变，径向渐变是一种由指定渐变的中心按照设定的大小，向外成圆型或椭圆形扩散的渐变。其标准语法如下： background: radial-gradient(position, shape size, color-stop, ..., color-stop); position：指定渐变中心的位置，可用百分比指定径向渐变圆心的坐标值，或者用长度值指定径向渐变圆心的坐标值，也可以设置left, right, top, bottom, center等位置值 shape：定义渐变的形状，取值如下： circle 指定圆形的径向渐变 ellipse 指定椭圆形的径向渐变，默认值 size：定义了渐变的大小，取值如下： closest-side：指定径向渐变的半径长度为从圆心到离圆心最近的边 closest-corner：指定径向渐变的半径长度为从圆心到离圆心最近的角 farthest-side：指定径向渐变的半径长度为从圆心到离圆心最远的边 farthest-corner：指定径向渐变的半径长度为从圆心到离圆心最远的角 color-stop：跟线性渐变的色标一样。 默认情况下，渐变中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。 可参考：使用CSS渐变 | MDN CSS简写 CSS 规范定义简写属性的目的在于将那些关于同一主题的常见属性的定义集中在一起。如我们已经说过的margin、padding、border等。 字体相关属性 font 相关属性用于设置字体，主要由以下几个属性组成： font-family：字体家族 font-size：字体大小 line-height：行高 font-weight：字体粗细 font-style：字体样式 font-variant：变体 其简写语法为： font: size/line-height weight style variant family; 圆角属性border-radius 的取值其实和 margin 也差不多，不过它描述的是角，顺序如下（top-left，top-right，bottom-right，bottom-left） 。 可参考：border-radius | MDN 背景相关属性简写1234567891011/* 简写前 */.bg &#123; background-color: #fff; background-image: url(images/bg.png); background-repeat: no-repeat; background-position: bottom right;&#125;/* 简写后 */.bg &#123; background: #fff url(images/bg.png) no-repeat bottom right;&#125; 但是 CSS3 时代又加入了 background-size、background-origin、background-clip 及多个值，整体上比之前复杂了很多，但是没关系，这些新加的属性你可以单独写（先建议单独写，因为可能这些新的属性还有些浏览器兼容问题）。 1234.bg &#123; background: #fff url(images/bg.png) no-repeat bottom right; background-size: cover;&#125; 动画相关属性transition用于过渡动画，跟background差不多，transition属性也是由几个属性组成，如下： transition-property：应用过渡效果的CSS属性名称 transition-duration：过渡效果花费的时间 transition-timing-function：过渡效果的时间曲线 transition-delay：过渡效果何时开始 其简写语法为：transition: property duration timing-function delay; animation用于帧动画，在属性组成上，只是比transition多了几个而已。 animation-name：@keyframes 动画的名称 animation-duration：动画完成一个周期所花费的秒或毫秒 animation-timing-function：动画的速度曲线 animation-delay：动画何时开始 animation-iteration-count：动画被播放的次数 animation-direction：动画是否在下一周期逆向地播放 animation-play-state：动画是否正在运行或暂停 animation-fill-mode：动画时间之外的状态 其简写语法为：animation: name duration timing-function delay iteration-count direction play-state fill-mode; 值简写 除了属性可以通过组合的形式进行简写，一些满足条件的值也可以进行适当的“偷工减料”。 一般来说以0+单位出现的值，都可以直接用0，省略单位，如0px可直接写成0（但0deg不允许去掉 deg ） 同样一般小于1的小数的都可以省略前面的0，如0.3s可以直接写.3s 颜色值如果采用十六进制，表示红绿蓝的每两位都一样的话，可以省略一位。如#336699，则可省略为#369 样式计算样式包括浏览器默认样式、继承的样式、声明的样式，最后表现出的样式是按照这三种样式的叠加规则来展示的。优先级由高到低为：声明样式——浏览器默认样式——继承样式。这也是层叠样式表（CSS）这个名字的由来。 样式优先级 style &gt; id选择器 &gt; 类选择器（属性、伪类） &gt; 元素选择器（伪元素） &gt; 通用选择器 在关系选择器中，比较优先级应该先从优先级最高的选择器开始比较。 !important表示最高级别。 得到的结论大概如下： !important &gt; style &gt; id选择器 &gt; 类选择器(伪类，属性) &gt; 元素选择器（伪元素） &gt; * &gt; 浏览器默认 &gt; 继承 可参考：优先级 | MDN 常见继承的属性 文本相关属性都可以继承 1color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、letter-spacing、word-spacing、white-space、word-break、overflow-wrap、line-height、direction、text-indent、text-align、text-shadow 列表相关属性 1list-style-image、list-style-position、list-style-type、list-style 表格相关属性 1border-collapse、border-spacing visibility 和 cursor 常见非继承属性 盒模型相关属性 1margin、border、padding、height、min-height、max-height、width、min-width、max-width、box-sizing 布局类属性 1display、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align 系列类 1background 系列、transform 系列、transtion 系列、animation 系列、flexbox 系列、grid 系列 浏览器兼容 首先浏览器有很多种，每种浏览器会存在一定的差异，其次每个浏览器都有不同的版本，版本之间也存在必然的差异，而我们做出来的页面则需要各个浏览器以及不同版本表现一致，所以必然存在兼容问题。 一般来说兼容问题我们可以分两步走：第一步是确定浏览器是否支持，第二步是如果表现不一致，怎么去修复。 浏览器是否支持 一般来说，由于技术的不断改进和发展，大概存在以下几种问题： 新技术在老版本的浏览器总是不支持的（如ie8以下对 CSS3 支持几乎是空白） 由于新技术刚出现时，可能还没有完全定稿标准化，所以各个新浏览器一般都是先试探性的使用前缀的办法使用 同样的技术在不同的浏览器上可能表现也不一样。 对于这些问题，我们可以查阅 Can I use ，里面提供了各种浏览器支持情况。 在查阅 Can I use 的时候，我们可以看到有些版本的右上角标有-符号，这就标识该版本得使用前缀，目前我们常见的前缀有-webkit（webkit内核浏览器）、-ms（ie/edge）、-moz（火狐浏览器） 如何针对修复 如果问题出现了，我们怎么针对某些浏览器进行特定的修复而不影响到其他正常的浏览器。 这个时候就可以参考浏览器hack详细，里面提供了针对各种浏览器单独写样式的很多方法（不一定所有办法都可以，但是你可以挑选一个可以的） CSS重置现在我们已经知道了，某些元素即使我们不对它声明样式，浏览器也会有些默认的样式，如 h1、p。 那么问题来了，浏览器有那么多（Chrome，Firefox，IE 等），每个浏览器的默认样式是否一致呢？ 很可惜，这个答案是否定的。 纠正重置 由于各个浏览器的默认样式有些差异，所以我们开始 CSS 的第一步应该是要消除这些差异，让表现一致。毕竟我们的最终目标就是得给用户看到一致的页面，不论用户使用什么浏览器。 这方面我们有开源的 normalize.css，它就是为了消除各个浏览器默认样式之间的差异而生的。 清零重置 虽然我们通过 normalize.css 消除了各浏览器默认样式的差异，但是我们日常开发中也有些不需要浏览器的默认样式的（毕竟默认的样式还是比较粗糙的），这样就构成了我们第二次的重置——清零重置。 如一些元素的 margin ，我们实际排版的时候都是跟着设计稿效果图走的，这种默认外边距反而有点碍事，所以先清为零：12345678910h1, h2, h3, h4, h5, h6, p, figure, form, blockquote &#123; margin: 0;&#125;ul, ol, li, dl, dd &#123; margin: 0; padding: 0;&#125;ul, ol &#123; list-style: none outside none;&#125; 又如列表类元素，实际使用中，我们几乎不需要前面的那个 list-style-type（圆点或数字等）所以也得清除掉：1234567ul, ol, li, dl, dd &#123; margin: 0; padding: 0;&#125;ul, ol &#123; list-style: none outside none;&#125; 再如 table，网页上的表格边框几乎全是合并处理的，而且单元格的内边距还得根据内容的多少来具体设置，所以也得先设置下，方便以后好用：1234567table &#123; border-collapse: collapse; border-spacing: 0;&#125;td, th &#123; padding: 0;&#125; 除此之外，设置所有元素的 box-sizing 都为 border-box，提供一个全局的 clearfix 类等等。12345678910* &#123; box-sizing: border-box;&#125;.clearfix::before, .clearfix::after &#123; content: \"\"; display: table;&#125;.clearfix::after &#123; clear: both;&#125; 可参考：归零重置Eric Meyer’s “Reset CSS” 2.0 结合两者，可参考：Sandal inline-block简单分析相信大家对这个属性并不陌生，根据名字inline-block我们就可以大概猜出它是结合了inline和block两者的特性于一身，简单的说：设置了inline-block属性的元素既拥有了block元素可以设置width和height的特性，又保持了inline元素不换行的特性。 以前我们做横向菜单列表的时候，我们可以通过li和float:left两者来实现，现在可以通过li和display:inline-block。 inline-block的问题 默认情况下，inline元素之间有空隙出现，所以结合了inline和block属性的inline-block属性自然也有这个特点。那这些空隙是什么呢，它们是空白符！ 要去除空白符产生的间隙，首先要理解空白符归根结底是个字符，通过设置font-size属性可以控制产生的间隙的大小。 inline-block的应用 inline-block的特点是结合inline和block两种属性的特性，可以设置width和height，并且元素保持行内排列的特性。基于这一点，所有行内排列并且可以设置大小的场景都是我们可以考虑使用inline-block的应用场景。 网页头部菜单 网页头部的菜单就是典型的横向排列并且需要设置大小的应用，在inline-block之前，实现菜单基本都是用float属性来实现，float属性会造成高度塌陷，需要清除浮动等问题，使用inline-block实现就不需要在意这样的问题。 内联块元素 一切需要行内排列并且可设置大小的需求就可以用inline-block来实现。例如使用a标签做按钮时，需要设置按钮的大小，我们就可以使用inline-block来实现。 布局 inline-block也可以用于常见的布局，使用它就不需要去注意float属性布局带来的问题。 相比于使用float所带来的问题，使用inline-block所需要注意的点主要是空白符带来的问题，这一点也可以很方便的解决。 CSS动画CSS3制作动画的几个属性：变形(transform)、转换(transition)和动画(animation)。 transform主要包括以下几种：旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix。 参考：CSS3 Transform transition主要包含四个属性值： 执行变换的属性:transition-property 变换延续的时间:transition-duration 在延续时间段、变换的速率变化:transition-timing-function 变换延迟时间:transition-delay 参考：CSS3 Transition animation主要有以下几种： animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction animation-play-state 参考：CSS3 Animation 单行超过使用省略 white-space:nowrap overflow:hidden text-overflow:ellipsis","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ice-io.github.io/tags/CSS/"}]},{"title":"前端知识总结——HTML基础篇","slug":"前端知识总结——HTML基础篇","date":"2017-08-01T14:07:50.000Z","updated":"2017-09-07T07:51:13.933Z","comments":true,"path":"2017/08/01/前端知识总结——HTML基础篇/","link":"","permalink":"http://ice-io.github.io/2017/08/01/前端知识总结——HTML基础篇/","excerpt":"从之前的不懂，到现在可以用HTML5和canvas制作一个小游戏，收获是很多的。但是，学习是一个循序渐进的过程，学而时习之，不亦说乎嘛。","text":"从之前的不懂，到现在可以用HTML5和canvas制作一个小游戏，收获是很多的。但是，学习是一个循序渐进的过程，学而时习之，不亦说乎嘛。 HTML基础结构1234567891011&lt;DOCTYPE html&gt; &lt;!--文档声明，告诉浏览器应该使用哪种规范来解析--&gt;&lt;html&gt; &lt;!--根元素，所有的元素都是其子元素--&gt; &lt;head&gt; &lt;!--head元素，包含网页的基本信息和元数据--&gt; &lt;meta charset='utf-8'&gt; &lt;!--meta元素，存放元数据，由name和http-equiv两个属性--&gt; &lt;title&gt;我是网页标题&lt;/title&gt; &lt;!--title元素，表示网页标题--&gt; &lt;/head&gt; &lt;body&gt; &lt;!--body元素，存放页面内容--&gt; &lt;h1&gt;我是内容标题&lt;/h1&gt; &lt;p&gt;我是段落&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 深入了解head元素 head元素包含网页的常规信息和元数据。 其子元素主要为三类： 描述网页基本信息 —— meta元素 指向网页渲染所需要的文件链接 —— link元素和script元素 厂商自定 —— meta元素 meta元素神通广大 meta常用于定义页面的说明，关键字，最后修改日期，和其它的元数据。这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎和其它网络服务。 meta元素共有两个属性，分别是http-equiv属性和name属性。 name属性 主要用于描述网页，比如网页的关键词，叙述等。与之对应的属性值为content，content中的内容是对name填入类型的具体描述，便于搜索引擎抓取。 meta标签中name属性语法格式是： &lt;meta name=&quot;参数&quot; content=&quot;具体的描述&quot;&gt; 取值包括：keywords(关键字)、description(网站内容的描述)、 viewport(移动端的窗口)、robots(定义搜索引擎爬虫的索引方式)、author(作者)、generator(网页制作软件)、copyright(版权)、revisit-after(搜索引擎爬虫重访时间)、renderer(双核浏览器渲染方式)。 http-equiv属性 相当于HTTP的作用，比如说定义些HTTP参数啥的。 meta标签中http-equiv属性语法格式是： &lt;meta http-equiv=&quot;参数&quot; content=&quot;具体的描述&quot;&gt; 取值包括： content-Type(设定网页字符集)(推荐使用HTML5的方式)、X-UA-Compatible(浏览器采取何种版本渲染当前页面)、cache-control(指定请求和响应遵循的缓存机制)、expires(网页到期时间)、refresh(自动刷新并指向某页面)、Set-Cookie(cookie设定)。 可参考 ：HTML meta标签总结与属性使用介绍 HTML注释 程序员圈子里面有个非常经典的笑话：“当我写下这段代码的时候，只有我和上帝能看懂。现在，只有上帝能了。” 就如有些人看文章需要做笔记一样，写代码最好也需要做笔记，这个笔记就是注释。注释主要用来解释代码的功能或逻辑，可以辅助阅读代码，当然注释内容本身是不会在浏览器中显示的。大家务必养成注释的习惯，这样即利于你日后阅读，也利于团队小伙伴阅读，否则，你的代码真的只有上帝才能看懂。 HTML注释的语法为：&lt;!-- 注释写这里 --&gt; HTML属性 为了表示元素的一些特征，我们可以在开始标签中添加一些属性。 属性特性 一般属性都具有以下特征： 每个属性之间或与元素名之间都有一个空格隔开 属性名后面紧跟等号 属性值使用双引号包裹但也有一些属性只有属性名，没有属性值，这种属性我们称之为布尔属性。除此之外，我们还可以自定义属性来存储我们的一些数据以便JavaScript使用。可参考HTML data-* 属性 属性分类 属性有很多种，从使用来说大概可以分为三类： 可以用于每个元素的全局属性，如class属性 可用于某一类元素的，如form表单相关元素的name、value属性 只用于某一个元素的，如alt属性只用于img元素 属性参考 HTML 全局属性|W3school HTML 全局属性|MDN HTML 属性参考 常用基本元素 标题元素 &lt;h1&gt; &lt;h2&gt; &lt;h3&gt; &lt;h4&gt; &lt;h5&gt; &lt;h6&gt;标签用来定义标题，其大小依次减小。&lt;h1&gt;为最大的标题，&lt;h6&gt;为最小的标题。 段落元素 &lt;p&gt;标签定义段落，每一个&lt;p&gt;标签默认都另起一行。 图片元素 &lt;img&gt;标签用来在网页中嵌入图片，该标签没有结束标签。（如这种只有一个标签的元素都可以称之为“空元素（empty element）”。 &lt;img&gt;标签有两个必需的属性：src属性 和 alt属性。其中src属性为图片地址，alt属性为如果图片加载失败显示的替换文字。 链接元素 &lt;a&gt;标签定义超链接，用于网页之间的跳转（从一个网页到另一个网页），它有一个重要的属性href，用来指定链接的目标。如果需要新标签页打开，则要添加另一个属性target。 列表元素 列表分为无序列表及有序列表两种，其中无序列表标签为&lt;ul&gt;，有序列表标签为&lt;ol&gt;，其直接的子元素标签为&lt;li&gt;(不能是其他标签)。 div元素 &lt;div&gt;标签用来分割为独立的、不同的部分，每一个&lt;div&gt;标签默认都另起一行。 span元素 &lt;span&gt;标签被用来组合文档中的行内元素。 换行元素 &lt;br&gt;标签可插入一个简单的换行符，它是个空元素，没有结束标签，不包含任何内容。 HTML字符实体预留字符 在 HTML 中，某些字符是预留的不能直接使用，如小于号（&lt;）和大于号（&gt;），直接使用会误认为它们是标签。所以如果我们希望正确地显示预留字符，那必须在 HTML 源代码中使用字符实体（character entities），如可以使用&amp;lt;表示小于号（&lt;），&amp;gt;表示大于号（&gt;）。 常用字符实体如下 显示结果 描述 实体名称 实体编号 空格 &amp;nbsp; &amp;#160; &lt; 小于号 &amp;lt; &amp;#60; &gt; 大于号 &amp;gt; &amp;#62; &amp; 和号 &amp;amp; &amp;#38; © 版权 &amp;copy; &amp;#169; × 乘号 &amp;times; &amp;#215; HTML表单表单元素本身是指&lt;form&gt;，不过它也有一个更广泛的概念，指构成表单的所有元素。首先就&lt;form&gt;元素本身来说，主要有两个属性： action：表示表单数据所提交到的处理地址（如果不知道处理地址，可先用#表示） method：表示提交内容的方式，默认取值为 get，可以设置为 post 下面正式介绍一些常用的表单元素 &lt;input&gt;元素 &lt;input&gt;元素跟&lt;img&gt;元素一样，不需要闭合标签。其常见属性如下： 12345678910111213type：必备属性，常见取值如下： text：文本输入框 password：密码输入框 search：搜索框 number：数字输入框 radio：单选按钮 checkbox：复选框 hidden：隐藏域（页面不可见，用来保存数据等） file： 上传文件 button：普通按钮 submit：提交按钮 reset：重置按钮placeholder：如为输入框时，可设置该属性，在输入框中灰色显示提示信息 &lt;textarea&gt;元素 用于多行文本输入，我们常用的评论输入框也是这个。 可以通过 cols 和 rows 属性来规定 textarea 的尺寸，不过等我们学了 CSS 之后，更好的办法是使用 CSS 的 height 和 width 属性来控制其尺寸。 &lt;select&gt;元素 用于创建选项菜单，默认只能选择一个值，可通过设置属性multiple=”multiple” 来实现多选（很少很少使用多选）。 其选项为&lt;option&gt;元素，常用有两个属性： `value`：表示选中该选项的值。 `selected`：表示默认选中。 &lt;button&gt;元素 &lt;button&gt;元素用来定义按钮，跟 input 定义的按钮不同，这个是有闭合标签的。同样也可以通过设置 type 属性来实现提交按钮和重置按钮，不过不建议这么做。一般对于提交与重置按钮，我们建议使用 input 来定义，对于普通按钮可以使用 button。 &lt;label&gt;元素 &lt;label&gt;元素用于关联表单元素的标题，可直接包裹表单元素，也可以通过设置其 for 属性关联到表单元素的 id 属性，这样点击 label 标题上关联的表单元素就 可以自动获取焦点，提升用户体验。示例如下： 1234&lt;!-- 包裹表单元素 --&gt;&lt;label&gt;用户名：&lt;input type=\"text\"&gt;&lt;/label&gt;&lt;!-- 使用for属性关联表单元素的id属性 --&gt;&lt;label for=\"username\"&gt;用户名：&lt;/label&gt;&lt;input type=\"text\" id=\"username\"&gt; 可参考：HTML Form浅析之表单属性","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://ice-io.github.io/tags/HTML/"}]}]}