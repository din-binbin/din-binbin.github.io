{"meta":{"title":"Thinking Coding","subtitle":null,"description":null,"author":"ice","url":"http://ice-io.github.io"},"pages":[{"title":"about","date":"2017-08-25T11:54:41.000Z","updated":"2017-08-25T11:57:04.322Z","comments":true,"path":"about/index.html","permalink":"http://ice-io.github.io/about/index.html","excerpt":"","text":"About Me"},{"title":"分类","date":"2017-08-25T13:26:44.000Z","updated":"2017-08-25T13:27:15.951Z","comments":true,"path":"categories/index.html","permalink":"http://ice-io.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-08-25T13:24:35.000Z","updated":"2017-08-25T13:25:42.461Z","comments":true,"path":"tags/index.html","permalink":"http://ice-io.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端知识总结——jQuery","slug":"前端知识总结——jQuery","date":"2017-09-13T10:51:45.000Z","updated":"2017-09-13T18:45:46.719Z","comments":true,"path":"2017/09/13/前端知识总结——jQuery/","link":"","permalink":"http://ice-io.github.io/2017/09/13/前端知识总结——jQuery/","excerpt":"学了JavaScript的基础知识后，有必要了解一下“影响一代人的jQuery”。","text":"学了JavaScript的基础知识后，有必要了解一下“影响一代人的jQuery”。 jQuery简介在全球的网站中，差不多有60%的网站使用了jQuery。它是一个JavaScript库，可以让我们更方便的使用JavaScript。 引入jQueryjQuery其实也是一个JavaScript文件，因此引入方式和引用js文件一样。 本地文件 CDN引入 jQuery中的$1$===jQuery $就是jQuery，是一个函数，准确来说，是一个构造函数，会将DOmain对象转为jquery对象，具有特定的额外方法。 jQuery里的选择器jQuery实现了CSS的选择器，包括基本选择器、组合选择器和其他选择器。 基本选择器 $(tag) $(#id) $(.class) $(*) 组合选择器 $(selector1,selector2) $(selector1 selector2) $(selector1&gt;selector2) $(selector1+selector2) 其他选择器 $(selector:first-child) $(selector:last-child) $(selector:eq(index)) $([attrbute=value]) jQuery里的遍历123456789101112131415161718192021// 获取父元素$('#id').parent();// 获取所有父元素和祖先元素$('#id').parents();// 使用.eq()函数获取相应元素$('#id').parents().eq(0);$('#id').parents().eq(1);// 使用.parents(selector)来精准查找$('#id').parents('.fat');$('#id').parents('.oldest');// 获取所有兄弟元素$('#id').siblings();// 使用selector来精准查找$('#id').siblings('.class');// 使用.children()获取子元素$('#id').children();// 使用.find('*')获取所有子元素$('#id').find('*');// 使用.find(selector)精准获取子孙元素$('#id').find('.class'); jQuery添加和删除DOM append/appendTo 在被选元素的结尾插入内容 prepend/prependTo 在被选元素的开头插入内容 after/insertAfter 在被选元素之后插入内容 before/insertBefore 在被选元素之前插入内容 empty() 删除其所有子元素 remove() 删除元素，包括子元素和元素本身 jQuery事件监听jQuery事件包括： 触发事件的目标元素 触发的事件名称 事件触发时的回调 事件对象 jQuery事件对象，是对原生事件对象的封装，做了浏览器兼容处理，并且增加了好用的属性和方法。 1234$('a').on('click',function()&#123; console.log(event.target); return false; // 既阻止默认事件，且阻止事件冒泡&#125;) 事件委托（事件代理）一般来说我们要给某个元素绑定事件，都会直接绑定在该元素上，但是这种直接的处理会有以下问题： 通过 JS 新添加的 li 元素并没有该事件绑定，所以点击无效 元素如果比较多的话，比喻有200个 li ，那每个 li 都绑定一个事件，性能是非常低的 那么如何解决这些问题呢？这就需要事件委托（或叫事件代理）。 件委托简单来说就是利用事件冒泡，只指定一个事件处理程序，用来管理某一类型的所有事件。 1234567// 要点击的元素是 todo-item// 但是我们把事件绑定在父元素 todo-list 上，实现事件委托// html 结构为：ul#todo-list&gt;li.todo-item*5$('#todo-list').on('click', '.todo-item', function() &#123; $(this).toggleClass('done');&#125;) 上述代码是用jQuery完成的，可能本质不太明显，下面再看看JavaScript原生的事件委托： 1234567891011var todoList = document.getElementById(\"todo-list\");todoList.addEventListener(\"click\", function (e) &#123; var target = e.target; // 检查事件源 target 是否为 todo-item if (target &amp;&amp; target.nodeName.toUpperCase() == 'LI' &amp;&amp; target.classList.contains('todo-item')) &#123; target.classList.toggle('done') &#125; else &#123; console.log('我不是 todo-item '); &#125;&#125;); 注：因为事件委托是依赖于事件冒泡的，所以没有事件冒泡的事件是不能使用事件委托的。 综上，事件委托的优点有如下几点： 管理的函数变少，不需要为每个元素都添加事件监听函数。 可以动态的增加和修改元素，无需因为元素的改动而修改事件绑定。 Javascript和DOM节点之间的关联变少，降低了循环引用的导致内存泄漏的可能性。 事件委托的缺点： 如果绑定监听器的父元素和目标元素的层级相距较远，那么在冒泡过程中会消耗一定的时间。 jQuery的隐式迭代和链式调用隐式迭代对于原生 JS 来说，一般我们设置某类元素的样式，都得使用循环设置，而 jQuery 在使用的时候则无需考虑这点，简单示例如下： 12345678910// 设置 .primary 元素的文字颜色为 #188eee// 原生 JSvar primary = document.getElementsByClassName('primary');for(var i = 0, len = primary.length; i &lt; len; i++) &#123; primary[i].style.color = '#188eee';&#125;// jQuery$('.primary').css('color', '#188eee'); 这是因为 jQuery 的方法内部存在隐式迭代，它会对匹配到的所有元素进行循环遍历，执行相应的方法；无需我们再手动地进行循，方便我们使用。 除了隐式迭代外，jQuery 还提供了 each()方法，方便有需要的时候调用。比喻要对每个元素做不同的处理： 123$(\"li\").each(function(i)&#123; $(this).addClass('item-'+i); &#125;); 链式调用从前我们要对某个元素进行一系列操作，只能一个一个来，而 jQuery 提供了链式操作： 123456789101112131415// 原始版$('div').hide(); //隐藏页面上所有的div元素$('div').text('new content'); //更新所有div元素内的文本$('div').addClass(\"updatedContent\"); //在所有的div元素上添加值为updatedContent的class属性$('div').show(); //显示页面上所有的div元素// 重写版，链式$('div').hide().text('new content').addClass(\"updatedContent\").show();// 缩进版$('div') .hide() .text('new content') .addClass(\"updatedContent\") .show(); 其原理就是每个方法的最后都返回了 this 对象，我们可以使用一份简单的代码演示下： 12345678910111213141516171819202122232425// 定义类function Person(opt) &#123; this.name = opt.name; this.age = opt.age&#125;// 定义 getName 方法Person.prototype.getName = function() &#123; console.log(this.name); return this; // 返回 this 对象&#125;// 定义 sayHello 方法Person.prototype.sayHello = function() &#123; console.log('hello the world'); return this; // 返回 this 对象&#125;// 新建一个叫 next 的 Person 类var next = new Person(&#123; name: 'next'&#125;);// 链式调用 getName 和 sayHello 方法next.getName().sayHello(); jQuery源码解析可参考：jQuery源码分析系列","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ice-io.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://ice-io.github.io/tags/jQuery/"}]},{"title":"前端知识总结——JavaScript基础","slug":"前端知识总结——JavaScript基础","date":"2017-09-10T09:01:29.000Z","updated":"2017-09-13T10:49:13.161Z","comments":true,"path":"2017/09/10/前端知识总结——JavaScript基础/","link":"","permalink":"http://ice-io.github.io/2017/09/10/前端知识总结——JavaScript基础/","excerpt":"知道了HTML、CSS，已经可以做出很多精美漂亮的页面了，但是这还远远不够，因为缺少与数据和用户交互的逻辑，这就需要学习脚本语言JavaScript。","text":"知道了HTML、CSS，已经可以做出很多精美漂亮的页面了，但是这还远远不够，因为缺少与数据和用户交互的逻辑，这就需要学习脚本语言JavaScript。 认识JavaScriptJavaScript是目前主流浏览器唯一支持的脚本语言，它可以实现： 修改页面样式和内容 制作工具 开发游戏 其他等 JavaScript引入JavaScript的引入和CSS类似，包括行内引入、&lt;script&gt;标签内嵌、文件外链。分别如下： 行内引入 1onclick=alert(\"hello\"); 标签内嵌 123&lt;script&gt; window.onload=alert(\"载入完成\");&lt;/script&gt; 外链引入 1&lt;script src=\"index.js\"&gt;&lt;/script&gt; 这三种方式的引入和CSS的三种引入方法类似，各有特点，因根据实际情况选择引入方式。 JavaScript注释12345678910111213141516171819// 我是单行注释alert(\"hello\"); // 我还可以写在这/*我是多行注释我是多行注释我是多行注释*/alert(\"world\");//下面是一个文档注释/** *这是一个函数 *@param &#123;string&#125; name 名称 */function eat(name)&#123; alert(\"eat\"+name)&#125; JavaScript文档注释规范（JSDoc）JSDoc 是一个根据 JavaScript 文件中注释信息，生成 JavaScript 应用程序或模块的API文档的工具。可以使用 JSDoc 标记如：命名空间，类，方法，方法参数等。从而使开发者能够轻易地阅读代码，掌握代码定义的类和其属性和方法，从而降低维护成本，和提高开发效率。 JSDoc 注释规则JSDoc注释一般应该放置在方法或函数声明之前，它必须以/**开始，以便由JSDoc解析器识别。其他任何以/*，/***或者超过3个星号的注释，都将被JSDoc解析器忽略。如下所示： 123/*** 一段简单的 JSDoc 注释。*/ JSDoc 的注释效果假如我们有一段这样的代码，没有任何注释，看起来是不是有一定的成本。 123456789101112function Book(title, author) &#123; this.title=title; this.author=author;&#125;Book.prototype=&#123; getTitle:function()&#123; return this.title; &#125;, setPageNum:function(pageNum)&#123; this.pageNum=pageNum; &#125;&#125;; 使用了 JSDoc 注释该代码后，代码的可阅读性就大大的提高了： 1234567891011121314151617181920212223242526/** * Book类，代表一个书本. * @constructor * @param &#123;string&#125; title - 书本的标题. * @param &#123;string&#125; author - 书本的作者. */function Book(title, author) &#123; this.title=title; this.author=author;&#125;Book.prototype=&#123; /** * 获取书本的标题 * @returns &#123;string|*&#125; 返回当前的书本名称 */ getTitle:function()&#123; return this.title; &#125;, /** * 设置书本的页数 * @param pageNum &#123;number&#125; 页数 */ setPageNum:function(pageNum)&#123; this.pageNum=pageNum; &#125;&#125;; 常用注释语法 @constructor 构造函数声明注释（明确一个函数是某个类的构造函数） @param 参数注释（参数标签可表示一个参数的参数名、参数类型和参数描述的注释） 123456/** * @param &#123;String&#125; wording 需要说的句子 */function say(wording) &#123; console.log(wording);&#125; @return 返回值注释（如果函数没有显示指定返回值可不写） 123/* * @return &#123;Number&#125; 返回值描述 */ @example 示例注释（用于表示示例代码,通常示例的代码会另起一行编写） 1234/* * @example * multiply(3, 2); */ @overview 对当前代码文件的描述 @copyright 代码的版权信息 @author &lt;name&gt; [&lt;emailAddress&gt;] 代码的作者信息 @version 当前代码的版本。 可参考：JSDoc 文档 JavaScript变量变量是一切编程语言的基石。 JavaScript中变量的语法12// var 是关键字var 变量名; 变量名规则： 区分大小写 首字母必须是字幕、_或$ 非关键字和保留字 示例： 1234var name=\"bottle\";var price=49;var diameter=6.7;var isKeepWarm=true; 上述代码可改为： 1234var name=\"bottle\", price=49, diameter=6.7, isKeepWarm=true; 注意定义变量时的局部变量、全局变量问题： 123456789// 局部变量function add()&#123; var a=1;&#125;// 全局变量function add2()&#123; a=1;&#125; 保留字和关键字在 javaScript 中，保留字和关键字不能够用作标识符，也就是不能用作变量或者函数的名称。 关键字ECMA-262 描述了一组具有特定用途的关键字,这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等。根据规定，关键字是语言保留的，不能用作标识符即用作变量名或函数名。如下： break case catch continue default delete do else finally for function if in instanceof new return switch this throw try typeof var void while with 保留字ECMA-262 还描述了另外一组保留字,有些保留字可能还没有任何特定的用途，但它们有可能在将来用作关键字。如下： boolean abstract byte char class const debugger double export enum extends final float goto implements import let int interface long native package private protected public short static super synchronized throws transient volatile 可参考：ECMAScript 关键字 数据类型简介JavaScript中，数据类型可分为： 基本数据类型 Number String Boolean Null undefined 复杂数据类型（引用数据类型） Object typeof操作符用来检测数据类型 123typeof 1; // Numbertypeof \"number\"; // Stringtypeof true; // Boolean Number 类型Number类型可以进行的常用操作包括: 加减乘除等运算 大小相等比较 String 类型String类型可以进行的常用操作包括: 通过&quot;+&quot;实现多个字符串的链接 通过.length查看字符串长度 通过[index]索引字符串（考虑到兼容性，可以使用charAt(index)方法来索引字符串） Boolean 类型取值包括： true false 当然了，一般都是通过隐性布尔值来使用的。如下： ! 操作符（取反操作符） 123456console.log(!1); //falseconsole.log(!!0); //falseconsole.log(!!NaN); //falseconsole.log(!!-3.14); //trueconsole.log(!null); //trueconsole.log(!undefined); //true Null 和 Undefined 类型通俗解释； Null —— 我有个袋子，里面是空的（typeof结果为 object） Undefined —— 我有个东西，但不知道是啥（typeof 结果为 undefined） Object 类型1234567891011121314151617// 对象字面量（声明方式）var bottle = &#123; name: 'bottle', price: 49, isKeepWarm: true&#125;// 获取对象的属性值console.log(bottle.name); // 'bottle'console.log(bottle[name]); // 'bottle'// 给对象属性赋值bottle.name = 'cup';// 特别名称的属性// 此时不能用'.'操作console.log(bottle[is keep warm]); Number类型与String类型之间的转换Number 类型作为 JS 的基本数据类型之一，被应用在程序中的各种场景，其重要性就如数字对于我们日常生活。 定义方式一般来说我们可以直接使用数值字面量格式来定义一个数字 12var num1=15;var num2=7; 数值类型 整数 十进制 1234// 十进制var int1=55; // 正数var int2=0; // 0var int3=-3; // 负数 八进制 123456// 八进制// 第一位必须是0，其余位的取值范围为0-7// 无效的八进制会直接忽略前面的0，解析为十进制var oct1=070; // 八进制的56（7*8 + 0）var oct2=079; // 无效的八进制数，9超过了8进制数的范围，解析为79var oct3=08; // 无效的八进制数，直接解析伪8 十六进制 1234// 十六进制// 前两位必须是0x，其余位的取值范围为 0~9 或 A~Fvar hexNum1 = 0xA; // 十六进制的10var hexNum2 = 0x1f; // 十六进制的31（1*16 + 15） 在进行算数计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制的数值。 浮点数浮点数其实就是我们通常所说的小数，所以一定有个小数点。 12var floatNum1 = 5.2;var floatNum2 = 3.14; 浮点数所占据的内存空间是整数的两倍。如果小数点后只有零或没有数字，为了节省内存空间，则该小数会被转化为整数 12var floatNum3 = 5.0; // 5var floatNum4 = 2.; // 2 进行算术运算时，浮点数不如整数精准，所以一般不要使用浮点数进行计算 12345var floatNum4 = 0.1;var floatNum5 = 0.2;// 0.1 + 0.2 不等于 0.3console.log(floatNum4 + floatNum5); // 0.30000000000000004 对极大极小的浮点数一般会采用e表示法 12var floatNum6 = 3.2e7；// 3.2×10（7次幂） var floatNum7 = 3.2e-7；// 3.2×10（-7次幂） NaNNaN 是 not a number 的简写，即非数字。它是一个特殊的值，这个数值用于表示一个本来要返回数值的操作数，结果未返回数值的情况。NaN 有两个不同寻常的特点： 任何涉及 NaN 的操作都会返回 NaN NaN 值与任何值都不相等，包括本身。 针对这两个特点，JS 提供了一个 isNaN()函数。该函数接受一个参数（可以是任何类型），而函数会帮我们确定这个参数是否“不是数值”。 12345console.log(isNaN(NaN)); // trueconsole.log(isNaN(10)); // falseconsole.log(isNaN(\"10\")); // false，可以被转成数值 10console.log(isNaN(\"blue\")); // trueconsole.log(isNaN(true)); // false，可以被转成数值 1 数值转换有三个函数可以把非数值转换为数值：Number()，parseInt()，parseFloat()。第一个可以用于任何数据类型，后两个则专门用于把字符串转化为数值。 1234567891011121314151617181920212223242526// Number()// 转换规则比较复杂，可详细参考下面的资料var numN1 = Number(\"Hello world!\"); // NaNvar numN2 = Number(\" \"); // 0 空字符串转为0var numN3 = Numberl(\"000011\"); // 11var numN4 = Number(true); // 1// parseInt()// 忽略小数点// 字符串会被转成数值var numI1 = parseInt(22.5); // 22var numI2 = parselnt (\"1234blue\") ; // 1234var numI3 = parselnt (\" \") ; // NaNvar numI4 = parselnt(\"70\"); //70（十进制数）var numI5 = parselnt (\"070\") ; // 56（八进制数）var numI6 = parselnt (\"0xA\") ; // 10（十六进制数）// parseFloat()// 字符串会被转成数值// 如果有多个小数点，则只去第一个，其余全部舍弃var numF1 = parseFloat (\"1234blue\") ; // 1234（整数）var numF2 = parseFloat(\"0xA\"); // 0var numF3 = parseFloat(\"22.5\"); // 22.5var numF4 = parseFloat(\"22.34.5\"); // 22.34var numF5 = parseFloat(\"0908.5\"); // 908.5var numF6 = parseFloat(\"3.125e7\"); // 31250000 可参考：JavaScript数值转换(非数值转换为数值) 数值范围由于内存的限制，JS 并不能保存所有的数值。我们可以使用 Number 对象的 MIN_VALUE 和 MAX_VALUE 属性表示（很少很少用到，大概知道就可以，真要用的时候可以再查阅）： Number.MIN_VALUE 为能表示的最小正数即最接近 0 的正数 (实际上不会变成 0)，它的近似值为 5 x 10-324。 Number.MAX_VALUE 为能表示的最大正数，它的近似值为 1.7976931348623157 x 10308 如果一个数值超过了最大能表示数值，则自动变成 Infinity 值（无穷数），我们可以使用 Number 对象的 isFinite() 来判断一个数是否是有限数，如果非有限数则为无穷数。 可参考：Number对象|MDN 数学函数JS 中内置了一个 Math 对象，它具有数学常数和函数的属性和方法。 123456789101112131415// 函数返回一个数字四舍五入后最接近的整数值。Math.round(3.4); // 3// 函数返回一个随机浮点数, 范围在[0，1)Math.random(); // 随机浮点数，每次都不一样// 函数返回一个数的平方根Math.sqrt(9); // 3// 函数返回给定的一组数字中的最大值Math.max(10, 20, 13, 18); // 20//sin 方法返回一个 -1 到 1 之间的数值，表示给定角度（单位：弧度）的正弦值。// Math.PI 表示圆周率，一个圆的周长和直径之比，约等于 3.14159.Math.sin(Math.PI / 2); // 1 可参考：Math对象|MDN 数组JavaScript中描述一组数据的数据类型。 数组介绍12345// 数组字面量（声明方式）var bottles = ['红','橙','黄','绿'];// Array 构造函数（声明方式）var bottles = new Array('红','橙','黄','绿'); 数组长度和索引12345// 数组长度console.log(bottles.length);// 数组索引console.log(bottles[0]); 数组的常用方法 push() 在数组末尾添加 pop() 在数组末尾删除 shift() 在数组开头删除 unshift() 在数组开头添加 slice() 该方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。原数组不会改变。参考：Array.prototype.slice() splice() 该方法通过删除现有元素或添加新元素来更改数组的内容。原数组会改变。参考：Array.prototype.splice() 对于 slice 来说，splice 的功能会更强大点，其区别主要在于： slice 不改变原数组，而 splice 则会改变 slice 的第二个参数为截至的索引值，而 splice 则表示要截取的个数 splice 还能用于增加元素，slice 则不可以 concat() 该方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。参考：Array.prototype.concat() 排序之 reverse() 该方法非常简单，没有任何参数，就是把数组的出现顺序调换下，第一个元素会成为最后一个，最后一个会成为第一个。 排序之 sort() sort()方法默认的排序是升序，但是我们也可以传入一个函数，指定其排序方式。参考：Array.prototype.sort() 排序之 随机排序 除了正常的升序降序之外，其实我们还经常使用到随机排序，如我们的抢红包，棋牌游戏中的洗牌都是随机排序的应用。 在使用随机排序的时候，我们得使用到一个随机函数 Math.random()。该函数返回一个浮点数, 其数字在范围[0，1)。 这样我们就可以使用该随机生成浮点数与0.5大小进行比较，那样结果可能大于或小于0，最后就得到了我们的随机排序。 123aHeight.sort(function()&#123; return 0.5 - Math.random();&#125;); 筛选之 every() every()方法用于测试数组的所有数据是否都通过了指定函数的测试，如果通过返回 true，否则 false。 12345var ageTest = aAge.every(function(item, index)&#123; return item &gt; 20;&#125;)console.log(ageTest); // false every()需要数组中的每个数据都满足该条件则返回 true，否则就是 false。参考：Array.prototype.every() 筛选之 some() 数组中只要有任何一个数据满足条件则返回 ture，如果一个数据都不满足则返回 false。参考：Array.prototype.some() 筛选之 includes() includes()方法用来判断当前数组是否包含某指定的值，如果是，则返回 true，否则返回 false。 筛选子 filter() 该方法返回所有满足条件数据组成的数组。参考：Array.prototype.filter() 遍历之 forEach() forEach()方法对数组的每个元素执行一次提供的函数，该方法没有返回值。参考：Array.prototype.forEach() 遍历之 map() map()方法创建一个新数组，其结果是该数组中的每个元素调用一个提供的函数。参考：Array.prototype.map() 关于数组对象，可参考：Array 函数函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。 函数定义123456789101112// 函数声明（定义方式）function fun1(arg)&#123; console.log('function'+arg);&#125;// 函数表达式（定义方式）var fun2 = function(arg)&#123; console.log('function'+arg);&#125;// 函数调用fun1('哈哈'); 函数声明与函数表达式的区别 JavaScript解释器中存在一种变量声明被提升（hoisting）的机制，也就是说变量（函数）的声明会被提升到当前作用域的最前面，即使写代码的时候是写在最后面，也还是会被提升至最前面。 作用域任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。 全局作用域 在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域： 最外层函数和在最外层函数外面定义的变量拥有全局作用域 123456789101112var authorName=\"山边小溪\";function doSomething()&#123; var blogName=\"梦想天空\"; function innerSay()&#123; alert(blogName); &#125; innerSay();&#125;alert(authorName); //山边小溪alert(blogName); //脚本错误doSomething(); //梦想天空innerSay() //脚本错误 所有末定义直接赋值的变量自动声明为拥有全局作用域 12345678function doSomething()&#123; var authorName=\"山边小溪\"; blogName=\"梦想天空\"; alert(authorName);&#125;doSomething(); //山边小溪alert(blogName); //梦想天空alert(authorName); //脚本错误 所有window对象的属性拥有全局作用域 局部作用域 局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域。 123456789function doSomething()&#123; var blogName=\"梦想天空\"; function innerSay()&#123; alert(blogName); &#125; innerSay();&#125;alert(blogName); //脚本错误innerSay(); //脚本错误 运算符算术表达式 + —— 加 - —— 减 * —— 乘 / —— 除 % —— 求余 ++ / -- —— 自增 / 自减 注意：前自增会先自增完，再计算整个表达式；而后自增则是先计算整个表达式，再自增。 赋值运算符 = —— 普通赋值 += —— 复合赋值 -= —— 复合赋值 *= —— 复合赋值 /= —— 复合赋值 %= —— 复合赋值 比较运算符 &gt; —— 大于 &lt; —— 小于 &gt;= —— 大于或等于 &lt;= —— 小于或等于 == / === —— 相等 / 严格相等（先类型转换再比较） != / !== —— 不想等 / 严格不想等（直接比较） 逻辑运算符 ! —— 逻辑非 &amp;&amp; —— 逻辑与 || —— 逻辑或 JavaScript 流程控制操作和控制数据的过程就是流程控制，主要分为循环和条件两种。 if 语句1234567if( 条件1 ) &#123; 执行代码1&#125; else if( 条件2 ) &#123; 执行代码2&#125; else &#123; 执行代码3&#125; 三元运算符1判断条件 ? ( 条件为真时执行代码 ) : ( 条件为假时执行代码 ) switch 语句1234567891011switch()&#123; case 满足1: 执行代码1; break; // 用break来打断switch语句的传递性 case 满足2: 执行代码2; break; ... default: 执行默认代码;&#125; 循环 while 1234// 先判断后执行while (条件)&#123; 循环代码;&#125; do-while 1234// 先执行后判断，因此会至少执行一次do &#123; 循环代码;&#125; while (条件); for 123for(初始化;判断表达式;每次循环后执行的代码)&#123; 循环代码;&#125; for-in 1234// 遍历对象属性for(变量 in 对象)&#123; 遍历执行代码;&#125; break 和 continue break —— 用于跳出循环 continue —— 用于跳过循环中的一个迭代 BOM 浏览器对象模型window对象 浏览器窗口相关信息 window.alert(&#39;弹出窗口&#39;); window.confirm(&#39;你确定吗？&#39;); window.prompt(&#39;请输入文字并确认&#39;); JavaScript的global对象（全局作用域） location 提供文档相关信息 location.host location.href location.hostname location.port location.pathname 导航 location.reload(true) —— 表示不缓存 location.reload() —— 刷新页面 location.assign() —— 跳转 navigator 客户端相关信息 userAgent —— 浏览器用户代理字符串 platform —— 系统平台 history 保存用户的上网记录 length —— 历史纪录数量 go() —— 跳转到指定历史记录 forward() —— 前进 back() —— 后退 DOM 文档对象模型通过DOM，可以将JavaScript和HTML、CSS练习起来，以增删元素，修改样式。即，DOM是针对HTML文档的一个应用程序编程接口（API）。 DOM节点 是一个对象 有十二种类型 常用节点类型 Element类型 HTML元素 属性（特别注意className） 创建、删除元素 nodeType:1; nodeName:元素的标签名; Text类型 data和nodeValue 创建文本节点 nodeType:3; nodeName:#text; Document类型 不是HTML元素 挂靠各种常用的api nodeType:9; nodeName:#document; DocumentFragment类型 nodeType:11; nodeName:#document-fragment; DOM查找 document.getElementById( ) 返回一个元素 document.getElementsByTagName( ) 返回一个类数组的HTML Collection，包含一组元素 HTML Collection是一个动态集合 document.getElementsByClassName( ) 返回一个类数组的HTML Collection，包含一组元素 document.querySelector( ) 接受参数为合法的CSS选择器只返回一个 document.querySelectorAll( ) 接受参数为合法的CSS选择器返回一组 DOM增删 insertBefore( ) 在之前添加 appendChild( ) 在之后追加 DocumentFragment 文档片段 作为仓库来使用（零碎节点放在一起再一次性添加） removeChild( ) 删除节点配合parentNode使用 DOM修改属性property和特性attribute 关联： 公认的attribute会映射到property 读写方式 property为&quot;.&quot;操作 attribute为getAttribute()、setAttribute() 特别的值（class、style） 属性只映射到Node节点，特性会映射到HTML结构 DOM修改 —— 样式1element.style.color='red'; 1- element.style='color:red;font-size:30px'; 12// 添加类名element.className='blue'; 12// 添加类名element.className=element.className+' red'; 12// 删除类名element.className=element.className.replace('red',''); 123// 添加类名element.classList.add('red');element.classList.add('blue'); 12// 删除类名element.classList.remove('red'); DOM修改 —— 内容 文本节点（使用不方便） innerHTML outerHTML DOM遍历 children/childNodes(子元素) parentNode/parentElement（父元素） previousElementSibling（前面的兄弟元素） nextElementSibling（后面的兄弟元素） 123456789101112131415//递归方法遍历function traversal(dom)&#123; var len=dom.length; var d=null; for(var i=0;i&lt;len;i++)&#123; d=dom[i]; console.log(d); if(d.children)&#123; traversal(d.children); &#125; &#125;&#125; JavaScript中的事件任何一门语言，事件无处不在。 事件模型 事件冒泡 点击按钮 —— 点击body —— 点击Document 事件捕获 点击Document —— 点击body —— 点击按钮 标准的事件模型 事件捕获 —— 处于目标 —— 事件冒泡(DOM事件流) 事件处理程序 添加 12// 添加事件div.addEventListener(type,handle,false); 作用域 删除12// 删除事件div.addEventListener(type,handle); 事件对象（event） 包含所有与事件相关的信息 冒泡（可通过event.stopPropagation()阻止冒泡） 事件的默认行为举个例子， &lt;a&gt; 元素，点击就会跳转到一个新的页面，这个就是浏览器自带的事件的默认行为。 有时候我们不想要这个行为，那么调用事件对象上的 preventDefault() 方法就能达成效果。 事件兼容性兼容性当然是指浏览器的兼容性，而浏览器的兼容性基本上是指 IE的兼容性 。当然，也不用为此沮丧，IE 的市场份额逐年下滑，胜利终将属于前端开发！ 事件模型 IE9 之前只支持事件冒泡，不支持事件捕获，也因此事件捕获在实际开发的过程当中使用的非常少。 addEventListener IE9 之前不支持 addEventListener 和 removeEventListener ，但是有对应的方法 attachEvent 和 detachEvent ，影响也不是很大。 事件对象 事件对象（IE9（不包括IE9） 之前的事件对象也不规范） 获取对象的方式不同 1234567elem.attachEvent('click', function (event) &#123; // 这种绑定方式，`event` 对象可以正确拿到&#125;);elem.onclick = function() &#123; var event = window.event; // 这种绑定方式，只能从 `window` 上拿&#125; 事件对象几个常用的属性和方法也不标准，但有对应的属性和实现相同的效果。 | 标准 | IE | 说明 || :—: | :—: | :— || stopPropagation() | cancelBubble | cancelBubble默认值为 false ，设为 true 可以取消事件冒泡 || preventDefault() | returnValue | 默认值为 true ，设置为 false 可以取消事件的默认行为 || target | srcElement | 这个好说，事件的目标元素。 | 跨浏览器的事件当然不能只局限于理论，而是要用于实战。我们的思路就是封装一个函数，让它的可以在所有的浏览器中正确的绑定事件，让使用者不用关注各个浏览器之间的差异，比如下面的 on 函数。 1234567891011121314151617181920212223242526272829303132333435363738/** * 修复事件对象不兼容的地方 */function fixEventObj(e) &#123; e.target = e.target || e.srcElement; e.preventDefault = e.preventDefault || function() &#123; e.returnValue = false; &#125;; e.stopPropagation = e.stopPropagation || function() &#123; e.cancelBubble = true; &#125;; return e;&#125;/** * 跨浏览器的绑定事件 */function on(elem, type, handle) &#123; if (elem.addEventListener) &#123; // 检测是否有标准方法 elem.addEventListener(type, handle, false); &#125; else if (elem.attachEvent) &#123; // 试图使用 `attachEvent` elem.attachEvent('on' + type, function(event) &#123; event = fixEventObj(event); handle.call(elem, event); // 使用 call 来改变 handle 的作用域，使其指向 elem &#125;); &#125; else &#123; // 兜底 elem['on' + type] = function() &#123; var event = fixEventObj(window.event); handle.call(elem, event); &#125; &#125;&#125;// 调用on(document.body, 'click', function(e) &#123; console.log('哈哈哈，好用！', e);&#125;); 绑定事件的历史演进我们在写兼容代码的时候，涉及到 DOM0 级和 DOM2 级事件处理。 12elem.onclick = function() &#123;&#125;; // dom 属性的绑定方式就是 DOM0 级elem.addEventListener(); // 这种就是 DOM2 级 DOM 也有版本演进，DOM0 和 DOM2 就是不同的版本，当然，版本啥的不是我们的重点，我们想探讨的是这两者的区别。 1234567// 这种方式只能绑定一个 handle// 当你试图绑定第二个时，就会覆盖上一个elem.onclick = function() &#123;&#125;; // 这种则可绑定任意个 handle// 在多人开发的项目中，这个特点非常重要，不同的伙伴给同一个元素绑定事件的几率很大的elem.addEventListener(); // 这种就是 DOM2 级 事件类型 鼠标类 click mousedown mouseup mouseenter（与子元素无关） mouseleave（与子元素无关） mouseover（与子元素有关） mouseout（与子元素有关） mousemove 键盘类 keydown keypress keyup UI类 load unload resize scroll keypress 和 keydown keypress 按字符集触发 keydown 按所有键都会触发 keypress 就是用来检测用户输了啥字符的，而 keydown 则是单纯的检测用户是否按了键盘上的按键，所以 keypress 常用。 keyCode是一个代码，与键盘上的一个键对应。在 keypress 事件中，这个 keyCode 还与 ASCII码对应，比如keyCode 等于 105 ，就是按了 i。","categories":[],"tags":[{"name":"-JavaScript","slug":"JavaScript","permalink":"http://ice-io.github.io/tags/JavaScript/"}]},{"title":"前端知识总结——HTML、CSS补充","slug":"前端知识总结——HTML、CSS补充","date":"2017-08-28T08:28:14.000Z","updated":"2017-09-10T08:57:30.934Z","comments":true,"path":"2017/08/28/前端知识总结——HTML、CSS补充/","link":"","permalink":"http://ice-io.github.io/2017/08/28/前端知识总结——HTML、CSS补充/","excerpt":"之前复习了差不多所有的HTML和CSS知识，但是学习永无止境，这篇文章再来补充一些知识。","text":"之前复习了差不多所有的HTML和CSS知识，但是学习永无止境，这篇文章再来补充一些知识。 HTML、CSS补充下面的内容，包括知识图谱、CSS规范、重构相关的知识。 HTML知识图谱 CSS知识图谱 CSS代码规范如果有一些代码洁癖，或者进入某个团队，然后发现大家的代码风格各不相同，维护代码时一团乱麻，这个时候一份统一的规范就很有用了。规范相对来说比较灵活，各个团队可以根据自己团队制定不同的规范，下面是一些规范推荐： 推荐使用的CSS代码规范 [译]谷歌 HTML/CSS 规范 CSS编码规范 网页重构经验 HTML整站结构设计 HTML结构的拆与合 CSS设计中的不变与可变 怎么命名class sheral——一个方便定制及扩展的UI组件库 重构优秀教程合集","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ice-io.github.io/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://ice-io.github.io/tags/HTML/"},{"name":"代码规范","slug":"代码规范","permalink":"http://ice-io.github.io/tags/代码规范/"},{"name":"重构","slug":"重构","permalink":"http://ice-io.github.io/tags/重构/"}]},{"title":"前端知识总结——CSS预处理","slug":"前端知识总结——CSS预处理","date":"2017-08-26T11:55:41.000Z","updated":"2017-09-10T08:56:24.110Z","comments":true,"path":"2017/08/26/前端知识总结——CSS预处理/","link":"","permalink":"http://ice-io.github.io/2017/08/26/前端知识总结——CSS预处理/","excerpt":"随着互联网的发展，网站复杂度日益加深，CSS语法能力不够。","text":"随着互联网的发展，网站复杂度日益加深，CSS语法能力不够。 CSS预处理CSS语法不够，促使开发人员去开发一套工具来补足对CSS的使用。 Sass {less} stylus 这三种CSS预处理器只是语法形式不一样，功能都差不多一样。包括：变量、逻辑运算、嵌套、mixin等。 Sass的嵌套CSS写法： 123456789101112/* CSS语法 */.link-list &#123; border-radius: 10px;&#125;.link-list .link-item &#123; text-decoration: none;&#125;.link-list .link-item:hover &#123; background-color: #188eee;&#125; 上面的写法多次用到了.link-list，如果改用Sass写法； 12345678910111213/* Sass语法 */.link-list &#123; border-radius: 10px; .link-item &#123; text-decoration: none; &amp;:hover &#123; background-color: #188eee; &#125; &#125;&#125; Sass写法通过嵌套省掉了多次调用.link-list。 可参考：Sass在线编译 Sass的变量当需要多次赋值同一颜色的时候，CSS写法如下： 123456789101112/* CSS语法 */.tt &#123; color: #188eee;&#125;.link &#123; color: #188eee;&#125;.btn &#123; background: #188eee;&#125; 颜色代码多次写入，且不利于后期修改。如果用Sass写法的话： 1234567891011121314/* Sass语法 */$blue: #188eee;.tt &#123; color: $blue;&#125;.link &#123; color: $blue;&#125;.btn &#123; background: $blue;&#125; 很明显，通过使用Sass的变量，可以更方便地编写CSS代码。 Sass的 mixin直接上代码观察； 12345678910111213141516/* Sass语法 */@mixin box-shadow($shadow) &#123; -moz-box-shadow: $shadow; -webkit-box-shadow: $shadow; box-shadow: $shadow;&#125;.box &#123; @include box-shadow(2px 4px #ccc);&#125;.header &#123; @include box-shadow(3px 4px #ccc);&#125; 以上代码转为CSS语法如下： 1234567891011121314/* CSS语法 */.box &#123; -moz-box-shadow: 2px 4px #ccc; -webkit-box-shadow: 2px 4px #ccc; box-shadow: 2px 4px #ccc;&#125;.header &#123; -moz-box-shadow: 3px 4px #ccc; -webkit-box-shadow: 3px 4px #ccc; box-shadow: 3px 4px #ccc;&#125; 方便之处一目了然，mixin的作用就是将一段常用的代码抽象为一种结构，再配合参数使用。 Sass里的循环还是一样，直接观察代码： 12345678/* Sass语法 */@for $i from 1 to 4 &#123; .item-#&#123;$i&#125; &#123; background-image: url(xxx/#&#123;$i&#125;.png); &#125;&#125; 转为CSS语法如下： 1234567891011121314/* CSS语法 */.item-1 &#123; background-image: url(xxx/1.png);&#125;.item-2 &#123; background-image: url(xxx/2.png);&#125;.item-3 &#123; background-image: url(xxx/3.png);&#125; Sass的参考文档 Sass Guide Sass官网 Sass中文 Sass 安装与编译 ruby sass 首先，Sass 是用 ruby 写的，所以你可以使用 ruby 来编译。具体的安装与编译可参考：Sass 安装 注：因为 ruby 的编译速度实在不怎么的，所以在项目中我们一般选择下面的 libsass。 libsass libsass 是一个用 C 语言实现的 Sass 解析器。特点是简单、速度快而且易于集成。但是 libsass 只是一个库，并不能直接使用，如果要实际使用还需要一个外壳来进行包装，如PHP，Node等，对于前端来说，优先选择的当然是用 Node 包裹的node-sass。 注：对于大项目来说，配置自动化 node-sass 编译才是最优选择。 其他编译 编辑器编译：一般来说，编辑器都会有相应的 Sass 编译插件，或默认就自带了 Sass 编译功能 在线编译：Sass meister 图形化编译工具：Koala 构建自动化编译：node-sass | npm","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ice-io.github.io/tags/CSS/"},{"name":"CSS预处理","slug":"CSS预处理","permalink":"http://ice-io.github.io/tags/CSS预处理/"}]},{"title":"前端知识总结——响应式设计","slug":"前端知识总结——响应式设计","date":"2017-08-24T15:20:49.000Z","updated":"2017-09-10T08:56:13.171Z","comments":true,"path":"2017/08/24/前端知识总结——响应式设计/","link":"","permalink":"http://ice-io.github.io/2017/08/24/前端知识总结——响应式设计/","excerpt":"随着移动互联网的发展，移动设备的增加，移动端的网页需求越来越大，响应式设计应运而生。","text":"随着移动互联网的发展，移动设备的增加，移动端的网页需求越来越大，响应式设计应运而生。 响应式 很久很久很久以前，每个人都只有一件衣服（ Website ），不管你有钱没钱大家每天都只穿这一件。后来有人发明了舞会（移动互联网），大家都争先恐后地想要参加，于是一个做「开发」的裁缝忽悠人们说进舞会最好订做一件专门的礼服（ Mobile Site ），大家想想也对，上班和出去哈皮都穿同一件衣服多无聊啊，舞会就要有舞会的样子。于是乎只要有点闲钱的人都做了礼服，他和原来那件叫做 Website 的衣服是完全不一样的，面子不一样，里子也不一样。 后来舞会的种类越来越多了，很多人被迫做了好多好多件礼服，于是又有一个叫做「前端」的裁缝站出来说你们每年要新做那么多衣服，多费钱啊，而且一出门钥匙啊皮夹子啊名片都要在不同衣服里换来换去多麻烦。你看，我们新发明了一个手艺叫做「Responsive Design」，只要把你原来那件衣服稍微那么一改，以后去哪个舞会都可以只穿这一件衣服，衣服的里子永远都差不多，但面子可以按照要求自适应不同的舞会。 同一个网页，根据显示器尺寸来展示适合浏览的页面，就叫响应式设计。 响应式设计包括； viewport media queries 内容布局 图片大小 viewportviewport，即为浏览器的可视区域。 可参考：移动前端开发之viewport的深入理解 retina 显示屏所谓“Retina”是一种显示技术，可以将更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度。这种分辨率在正常观看距离下足以使人肉眼无法分辨其中的单独像素，也被称为视网膜显示屏。 Retina 既不是指分辨率，也不是单独指PPI，而是指视觉效果。 手机显示器的像素密度达到或高于 300ppi 就不会再出现颗粒感（视线距离在35CM左右） 苹果电脑的 Retina 显示器像素密度只要超过 200ppi 就无法区分出单独的像素（视线距离在60CM左右） 可参考：4K 和 Retina 显示屏哪个分辨率更高 、 Retina屏幕 PPI（像素密度） 和 DPR（设备像素比）Pixels Per Inch（PPI）也叫像素密度，所表示的是每英寸所拥有的像素数量，PPI值越高，画面的细节就会越丰富。 物理像素：我们把分辨率的像素称之为物理像素或设备像素（如 iPhone 7 的物理像素为 750px * 1334px），它是显示设备中一个最微小的物理部件。 设备独立像素：CSS 的尺寸像素称之为设备独立像素（device-independent pixels 简称为“DIPs”）或 CSS 像素（如 iPhone 7 的设备独立像素为 375px * 667px），它是一个抽象的单位，主要使用在浏览器上，用来精确的度量（确定）Web页面上的内容。 devicePixelRatio（DPR）： 用来描述物理像素与设备独立像素的比例，其值等于 “物理像素 / 设备独立像素”。devicePixelRatio 值为 1 时就是我们的标准屏，值为 2 时则是我们俗称的 2 倍屏（2x），同样 3 就是 3 倍屏（3x）。 通过上面的说明，我们可以得到 iPhone 7 的 devicePixelRatio 为 2 （750px / 375px = 2），就是 2 倍屏。那么这个 2 倍屏跟我们普通的标准屏有什么区别呢？ 对一个标准屏来说，渲染一个 2px 2px 的盒子将会使用 2px 2px 物理像素，如我们的普通电脑屏；但是对于一个 2 倍屏来说，渲染一个 2px 2px 的盒子将会使用 （2px 2） （2px 2） 物理像素，如我们的 iPhone 4、5、6、7，如下图： 多倍屏带来的问题熟悉了这些概念之后，我们就要开始解决需要面临的问题了。由于 devicePixelRatio 不再是1，我们的物理像素与设备独立像素不再对等，所以在实际网页开发时面临了2个问题：图片虚化、1px边框变粗。 图片虚化 我们知道，位图（png, jpg, gif等）是由一个个像素点构成的，每个像素都具有特定的位置和颜色值，我们称之为位图像素，如下图： 当一个位图在标准屏显示时，一位图像素对应的就是一物理像素，这样就保证了一个完全保真的显示。但是当在 2 倍屏下时，它需要要放大四倍（宽高各两倍）来保持相同的物理像素的大小，这样就会丢失很多细节，造成失真的情形，也就是我们常说的图片虚化问题。如下图： 那么怎么解决该问题呢？说到底就是为了让一位图像素对应一物理像素，既然物理像素已经定了不能变，那么我们是否可以改变位图像素呢？答案是肯定的。 我们可以把要使用的图片扩大一倍，如要用的图片大小为 2px 2px，我们可以使用 4px 4px 的图片然后设置图片大小为 2px * 2px，这样对于2倍屏则正好，而标准屏则减少像素取样（一定程度上的浪费），如下图： 1px边框变粗 为了说明这个问题，我们先看一个1px demo，截图如下： 如果我们把上图与我们手机系统上的 1px 边框进行对比，如下图： 我们会发现，上面两个上下线条，下线条的粗细才是正确的，上线条就显得有点粗了。但是上线条我们是用纯正的 1px border生成的，而下线条我们实际是采用transform压缩了1px高度的一半模拟实现的，也就相当于 0.5px 的高度了。为什么会这样呢？ 这是因为在2倍屏时1 CSS 像素实际对应2个物理像素, 所以为了实现真正的 1px 粗细，我们得使用 0.5px 来模拟。目前除 ios8+ 可以直接使用 0.5px 单位外，其余皆得通过模拟的办法搞定。 具体实现办法有很多，大家可以参考：7种方法解决移动端Retina屏幕1px边框问题。 媒体查询（media queries）媒体查询，通俗地说就是感应一些设备信息来给开发使用。 语法示例： 12345@media screen and (min-width:768px) and (max-width:1024px) &#123; .demo&#123; color:red; &#125;&#125; @media —— 关键词 screen —— 媒体类型 and —— 逻辑操作符 min-width:768px —— 媒体条件 min-width —— 媒体属性 另外，这种方法也可以：&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; media=&quot;(min-width:1024px)&quot;&gt; 可参考：CSS媒体查询 响应式图片通俗地说就是根据设备来自动选择要展示的图片，大屏展示大图，小屏展示小图，以优化网络性能。代码示例如下： 123456&lt;img src=\"img/small.png\" srcset=\"img/large.png 960w, img/medium.png 640w,img/small.png 320w\" sizes=\"(max-width:414px) 100vw,640px\" alt=\"响应式图片\"&gt; sizes —— 表示需要图片的大小（相当于响应式查询） srcset —— 供选择的图片规格 注：srcset=&quot;img/large.png 960w, img/medium.png 640w,img/small.png 320w&quot;中的 w 是宽度描述符，当其存在的时候， src 属性就失效了，还有一种描述符 x ，表示几倍屏描述符。 使用时请注意响应式图片的兼容性问题。 比如现有一段代码； 123456&lt;img src=\"img/l.png\" alt=\"响应式图片\" srcset=\"img/xl.png 1920w, img/l.png 960w, img/m.png 480w, img/s.png 240w\" sizes=\"(max-width;768px) 100vw, 50vw\"&gt; 上述代码在iPhone7 plus竖屏时会选择哪张图片？ iPhone 7 plus 的设备宽度为414px，小于768px，所以使用100vw，然后因为它的DPR为3，所以需要的图片宽度为 414px * 3 = 1242px，没有正好的规格图片，所以先向上取，那么就是1920规格的 xl.png 。 响应式怎么实现要做一个好的响应式页面，最重要的是要处理好以下两点： 断点设置：可以先综合判断要实现各个平台断点，然后再针对一些特殊局部进行单独的断点 内容布局呈现：这个可能就比较繁琐，有些时候还得有一定的想象力 可参考：响应式及断点设置分析 响应式相关 整体布局 Flexbox Grid How to build a responsive grid system 内容处理相关 响应式导航解析 响应式图片101系列 图片滚动 响应式图表 响应式视频 工具相关 使用Chrome测试页面响应性 测试响应和设备特定可视窗口 媒体查询尺寸 常见CSS框架有时候为了提高开发效率，我们往往会使用一些前端的 CSS 框架。当框架的功能能够满足你的需求时，使用框架是一个不错的主意。 Bootstrap Bootstrap 是世界上最流行的前端基础框架之一，可用于构建响应式或移动端项目以及帮助你快速开发web应用。其在推出之后就广受追捧，并掀起了 UI 框架热。在许多有名的网站都能看到使用 Bootstrap 的身影，而在管理后台方面更是一骑绝尘成为首先框架。 Pure CSS Pure.css 是一套小型响应式 CS S模块，可用于所有 Web 项目，为原生 HTML 元素以及最常见的 UI 组件提供布局和样式。Pure.css 其代码十分精简，压缩后体积才3.8kb，十分适合移动端和响应式场景的开发。 WE UI WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。如果需要开发微信场景的 H5 页面，可以使用 WeUI 来使用微信风格的样式和提高样式开发效率。 还有许多优秀的 CSS 框架，在选择使用 CSS 框架前，我们需要先认真考虑自身使用场景和了解可选框架的提供的功能。只有选择适合的框架，我们才能事半功倍。当然即使你不直接使用框架，模仿学习框架设计架构思想对自己的学习成长也是非常有益的。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ice-io.github.io/tags/CSS/"},{"name":"响应式","slug":"响应式","permalink":"http://ice-io.github.io/tags/响应式/"}]},{"title":"前端知识总结——CSS动画","slug":"前端知识总结——CSS动画","date":"2017-08-23T08:59:21.000Z","updated":"2017-09-10T08:55:57.383Z","comments":true,"path":"2017/08/23/前端知识总结——CSS动画/","link":"","permalink":"http://ice-io.github.io/2017/08/23/前端知识总结——CSS动画/","excerpt":"学习了HTML和CSS的相关知识后，接下来继续复习——CSS动画。","text":"学习了HTML和CSS的相关知识后，接下来继续复习——CSS动画。 CSS动画通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。 CSS动画包括 补间动画 和 帧动画 。 补间动画：transition；帧动画：animation。 动画必备属性 transformtransform 本意是变形，变换之意，在 CSS 中使用该属性可对元素进行移动（translate）、旋转（rotate）、缩放（scale）、倾斜（skew）等效果。因其有着各种特效及优良的性能，所以成为动画的标配。 在学习之前，我们可以简单欣赏下几个案例： 翻转号码 翻转cube 欣赏之后再来学习transform的相关知识点吧。 translate 其语法为：transform: translate(tx[, ty])。其中 tx 表示 x 方向偏移，ty 表示 y 方向偏移，如果 ty 没有指定值则为0。可以分拆为：transform: translateX(tx) 或 transform: translateY(ty)。 简单示例如下（虚线框表示原先位置）： 123.box &#123; transform: translate(50px, 30px);&#125; 注：tx，ty 如果为百分比值的话，其参考计算的是元素本身的宽和高，而不是父元素的宽和高。所以经常使用该方法设置定位居中，代码如下：123456.demo &#123; position: absolute; top: 50%; /* 父元素高度的一半位置 */ left: 50%; /* 父元素宽度的一半位置 */ transform: translate(-50%, -50%); /* 元素本身的一半宽、高 */&#125; scale 其语法为：transform: scale(sx[, sy])。其中 sx 表示 x 方向的缩放比例，sy 表示 y 方向的缩放比例，如果 sy 没有指定值则与 sx 相等。同样也可以分拆为：transform: scaleX(sx) 和 transform: scaleY(sy)。 简单示例如下： 123.box &#123; transform: scale(1.2);&#125; rotate 其语法为：transform: rotate(angle)。angle 表示顺时针角度。 简单示例如下： 123.box &#123; transform: rotate(15deg);&#125; skew 其语法为：transform: skew(ax[, ay])。其中 ax 表示 x 方向的顺时针角度，ay 表示 y 方向的顺时针角度，如果 ay 没有指定值则 y 方向没有倾斜。 简单示例如下： 123.box &#123; transform: skew(30deg);&#125; 复合变换 上面几个变换，都可以自由组合形成更复杂的复合变换。 简单示例如下： 123.box &#123; transform: translate(30px) rotate(10deg) skew(0, 5deg);&#125; 变换中心点 默认上面所有的变换都是以元素的中心位置为参考原点的，不过我们可以通过属性 transform-origin 来改变参考原点。 其语法为：transform-origin: ox oy。其中 ox 表示 x 方向的位置，可使用 left、right、center、&lt;length&gt;、&lt;percentage&gt;；oy 表示 y 方向的位置，可使用top、bottom、center、&lt;length&gt;、&lt;percentage&gt;。如果只传入一个值，则另一个值默认为 50% 。 简单示例如下：123456789101112.box &#123; transform: rotate(15deg);&#125;.box-origin-top-left &#123; transform-origin: left top;&#125;.box-origin-right &#123; transform-origin: right; /* 设置一个值，则另一个为50% */&#125;.box-origin-px &#123; transform-origin: 200px 80%;&#125; 三维变换，可参考：CSS3 3D transform变换 、 Intro to CSS 3D transforms 继续了解transform可参考：深入浅出CSS Transform 、 理解CSS3 transform中的Matrix(矩阵) 缓动函数 ease —— 默认值，慢速开始，然后变快，然后慢速结束。 linear —— 以相同速度开始直至结束。 ease-in —— 慢速开始。 ease-out —— 慢速结束。 ease-in-out —— 慢速开始，慢速结束。 上面几种取值其实是cubic-bezier(n,n,n,n)函数的特殊值。 可参考：缓动函数速查表 、 cubic-bezier animation 动画 animation-name（名称） animation-duration（持续时间） animation-timing-function（缓动函数） animation-delay（延迟时间） animation-iteration-count（循环次数） animation-direction（运动方向） animation-fill-mode（动画开始和结束的帧样式） animation-play-state（动画状态：暂停 | 运行） 通过关键字@keyframes来定义关键帧，再通过animation-name属性来调用。 注：定义关键帧的时候，from相当于0% ，to相当于100% 。 transition 动画 和 animation 动画的比较 transition 动画 animation 动画 需要借助交互（如:hover,:active,add class） 既可自动也可交互 只能定义第一帧和最后一帧样式 可以控制多帧，还可以控制暂停播放 常见 CSS 动画库自从 CSS3 有了动画功能，从此 Web 页面就迈进“忽如一夜春风来，千页万页动画开”的盛况。 所以 CSS 动画除了是炫技之选更是一项基本技能，当然也就有无数前辈为之呕心沥血总结经验了。 Animate.css Animate.css 是最早的也是目前最流行和最易于使用的CSS动画库之一，其包含了60多款不同类型的 CSS 动画如晃动、闪动、淡出淡出效果等，如果你想快速的使用各种 CSS 动画特效的话，你可以选择它。 Magic CSS3 Animation Magic CSS3 Animations 是一个特殊效果的 CSS 动画库，你可以免费用于你的 Web 项目，简单的引用 CSS 样式：magic.css 或 magic.min.css （压缩版）即可。该项目提供了一个特别酷的演示应用程序。与 animate.css 相比，Magic CSS3 Animation 的大小适中，它的特色动画，如魔法效果，愚蠢的效果和炸弹效果十分出众和特别。 Hover CSS Hover.css 是一个 CSS 动画库，专为您的网站中的按钮和其他 UI 元素而设计。它具有非常好的2D转换，以及许多其他精心制作的动画。 Effeckt Effeckt.css 是一个集合了众多新鲜而又实用的的 CSS/jQuery 动画效果，这些都适用于网站或是移动 APP 的网页，比如一些 AJAX 弹出框动画、菜单动画、图片标题展示等等，这些特效动画都能给你的网站提升一定用户体验，而且简单实用。 Single Element CSS Spinners 在页面中，我们时常需要使用 gif 图片来实现比较炫酷的 loading 动画。Single Element CSS Spinners是一个CSS螺旋加载动画的集合。使用Single Element CSS Spinners 来替代 gif 来实现螺旋加载动画，不仅减少了请求图片的次数，同时还能够通过代码来灵活地修改动画的参数。 注：一般不建议全部拿来使用，而是使用哪个动画效果就拷贝对应的样式。 动画性能优化CSS3 动画给 Web 的用户体验带来了巨大提升，本文将尝试从浏览器渲染的角度，来解析动画优化的原理及其技巧。为大家提供一些动画性能优化的参考。 60fps与设备刷新率 目前大多数设备的屏幕刷新率为60fps（Frame per Second），即每秒60帧。因此，如果在页面中有一个动画或渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致，即每一帧要在16毫秒（1S/60 = 16.66ms）之内完成。如果无法完成，由于帧率的下降会导致内容在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。 浏览器渲染 简单来说，浏览器的渲染过程其实就是将页面转换成像素显示到屏幕上，大致有如下几个步骤： Javascript操作： 一般来说，我们会使用 JavaScript 来实现一些交互操作。比如用往页面里添加一些元素，切换显示隐藏等 style 样式计算： 该过程根据 CSS 选择器，获取每个元素匹配的 CSS 样式并计算其最终应用样式 Layout 布局：该过程计算元素要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 &lt;body&gt; 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局是经常发生的。 Paint 绘制：本质上就是填充像素的过程。包括绘制文字、颜色、图像、边框和阴影等。也就是绘制元素所有的可视效果。 Composite 渲染层合并：在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。 如果我们需要提高动画的性能，需要做的就是减少浏览器在动画运行时所需要做的工作。当 CSS 在进行动画时，其不同属性值引起的改变，重新渲染可能会有三种执行路径： A：layout -&gt; paint -&gt; composite B：paint -&gt; composite C：composite 很明显，最短路径的 C 动画性能是最高的，所以我们在使用动画的时候就得考虑使用什么属性，以尽量减少执行路径。 动画属性 CSS 的属性大致分为三类：布局类（layout），绘制类（paint），合成类（composite）。 重排（reflow） 由元素的布局类属性改变所触发的行为过程，我们称为 reflow，也叫做 relayout（重新布局）。当某个节点 reflow 时会重新计算节点的尺寸和位置，还可能会引起其它节点的 reflow。该系列属性的改变，会执行路径 A 进行重新渲染，所以性能是最差的。（这充分说明，重排会引起重绘）。触发重排的属性如下： 盒子模型相关属性会触发重布局：width、height、padding、margin、display、border-width、border、min-height 定位属性及浮动也会触发重布局：top、bottom、left、right、position、float、clear 改变节点内部文字结构也会触发重布局：text-align、overflow、font-weight、font-family、line-height、vertival-align、white-space、font-size 重绘 绘制类属性改变触发节点重新绘制其可视效果的过程，我们称为 repaint。该系列属性的改变，会执行路径 B，所以性能一般。触发重绘的属性如下： color、border-style、border-radius、visibility、text-decoration、background、background-image、background-position、background-repeat、background-size、outline-color、outline、outline-style、outline-width、box-shadow 上面的属性由于不会修改节点的大小和位置，因此不会触发重排，其只是改变了节点内部的渲染效果，所以只会进行重绘以下的步骤。 composite 目前只有两个属性属于 composite 类： transform、opactiy 该系列属性的改变，会执行路径 C，所以性能最佳。 动画性能优化技巧 减少动画元素 减少动画元素，是动画性能优化中首先需要完成的。通过审查页面动画 DOM 元素结构，去除不必要的动画元素，减少元素的数量，相应地会减少布页面局和绘制的时间。 尽量使用 fixed、absolute 定位 对于动画元素，尽量使用用 fixed、absolute 定位方式，避免影响到其他节点重排。 尽量只改变transform和opacity 能用 transform、opacity 优先使用，其属性的改变不会发生重排和重绘。如位移操作的，可以使用translate 来实现，渐隐渐现效果可以使用 opacity 属性来实现。 恰当开启硬件加速效果 对动画元素应用transform: translate3d(0, 0, 0)、will-change: transform 等来开启硬件加速。通常开启硬件加速可以让动画变得更加流畅。但这里需注意，在不需要的时候需去掉避免过多的内存消耗。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ice-io.github.io/tags/CSS/"},{"name":"CSS动画","slug":"CSS动画","permalink":"http://ice-io.github.io/tags/CSS动画/"}]},{"title":"前端知识总结——HTML、CSS进阶","slug":"前端知识总结——HTML、CSS进阶","date":"2017-08-21T07:24:58.000Z","updated":"2017-09-10T08:56:35.878Z","comments":true,"path":"2017/08/21/前端知识总结——HTML、CSS进阶/","link":"","permalink":"http://ice-io.github.io/2017/08/21/前端知识总结——HTML、CSS进阶/","excerpt":"了解了HTML和CSS的基础知识后，就可以继续深入HTML和CSS的博大精深了。","text":"了解了HTML和CSS的基础知识后，就可以继续深入HTML和CSS的博大精深了。 HTML+CSS布局这里引入一下古老的table布局方法：用表格定义天然的区块再填入内容来布局。缺点如下： 加载慢，需等到表格加载完才显示。 HTML语义化 表格之后，布局主要是div + CSS —— 导致div标签被滥用。 HTML语义化 方便团队开发 有利于SEO 对屏幕阅读软件友好 HTML 语义当然不仅仅只是几个 HTML 语义标签。HTML 就是文档，最开始的《Web 简史》中我们有提到过，万维网的雏形是一个文档共享系统，万维网就是一个放大版的文档共享系统。只是随着 Web 的发展，各种酷炫的页面和应用层出不穷，倒是让新入行的小伙伴忽略了，HTML 的本质其实是文档（document）。视觉上的各种酷炫会给人以视觉冲击，但对机器来说，并没有什么用，它们更看重的是语义，这样才能更好地解析内容。这也是为什么样式会从结构里面分离出来的原因之一。 可参考：深入理解HTML5标签 让 IE8 支持 HTML5 语义化标签HTML5是 HTML 最新的修订版本，于2014年10月由万维网联盟（W3C）完成标准制定。而 IE8 面世时间为2009年3月19日，时间相差如此之大，所以 IE8 作为比较古老的浏览器，不支持 HTML 5 引入的语义化标签（如 header、nav、menu、section、article 等）。 默认情况下 IE8 对 HTML5 标签的处理 在 IE8 里面，未定义的标签——IE8 不认识所有新引入的 HTML5 标签，所以定义样式是不会生效。 如何让 IE8 支持 HTML5 标签虽然默认不支持，但是我们可以通过 JS 使用 document.createElement 来“欺骗” IE 的 CSS 引擎，让它知道某个标签的存在，具体做法如下： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;HTML5 test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; document.createElement('section'); &lt;/script&gt; &lt;style&gt; section &#123; color: red; &#125; &lt;/style&gt; &lt;section&gt; Hello! &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 借助html5shiv.js让IE8支持更多的HTML5特性 其实不只是 IE8 ， IE6-9、 Safari 4.x (以及 iPhone 3.x)、还有Firefox 3.x 等等，对 HTML5 的支持都不完善。所以有了一个库html5shiv.js 来做统一处理，shiv 意为用作武器的小刀（实际上是一个拼写错误，应该为 shim），在机械工程中的专业释义为垫片，比喻给那些老旧的浏览器加个垫片，让它们基本能用。可参考：html5shiv.js 显示类型-display在HTML的元素显示时，有的是块级元素，有的是行内元素。 比如块级： display:block; display:table; display:list-item; 特征： 每个元素另起一行； 可设置宽高、行高、上下边距、左右边距。 比如行内： display:inline; display:inline-block; 特征： 和其他行内元素同一行； 不可设置宽高、行高、上下边距，可设置左右边距。 这并非是由HTML定义的，而是由默认的css定义的，这也就意味着我们更改元素的显示类型display。 除了上述属性，display还有flex、grid属性，以及inline-block、inline-flex、inline-grid，后面再详细回顾。 视觉格式化模型（visual formatting model）前面我们已经学习了盒模型（box model），知道了元素会被渲染成一个个盒子。那么这些盒子在屏幕上的位置又是怎么放置的呢？这就是我们现在要学习的——CSS 视觉格式化模型(visual formatting model)。视觉格式化模型是 CSS 布局的一个基础理论体系。 盒子的位置摆放 默认情况下，盒子按照元素在 HTML 中的先后位置从左至右自上而下一个接着一个排列摆放。 在图中我们可以看到，有些元素的盒子被渲染为完整的一行，如h1、p、div；而有些元素的盒子则被渲染为水平排列，直到该行被占满然后换行，如span、a、strong。 这是因为不同的盒子使用的是不同的格式化上下文（formatting context）来布局，每个格式化上下文都拥有一套不同的渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。（就如我们参加结婚喜宴一样，有父母长辈席，好友席，同事席，甚至前男/女朋友席等，不同的身份坐到对应位置即可。） 格式化上下文（formatting context） 我们常见的两个格式化上下文分别为：块格式化上下文（block formatting context 简称 BFC）和行内格式化上下文（inline formatting context 简称 IFC） BFC 块级盒（block-level boxes） 当元素的 CSS 属性 display 的计算值为 block，list-item，table，flex 或 grid 时，它是块级元素。视觉上呈现为块，竖直排列。典型的如 &lt;div&gt; 元素，&lt;p&gt; 元素等都是块级元素。 每个块级元素至少生成一个块级盒，称为主要块级盒(principal block-level box)。一些元素，比如&lt;li&gt;，生成额外的盒来放置项目符号，不过多数元素只生成一个主要块级盒。 块级盒参与 BFC，被渲染为完整的一个新行。 渲染规则 默认根元素（html 元素）会创建一个 BFC，其块级盒子元素将会按照如下规则进行渲染： 块级盒会在垂直方向，一个接一个地放置，每个盒子水平占满整个容器空间 块级盒的垂直方向距离由上下 margin 决定，同属于一个 BFC 中的两个或以上块级盒的相接的 margin 会发生重叠 BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此 计算 BFC 的高度时，浮动元素也参与计算 除此之外，还有其他方法可以创建一个新的 BFC，具体可参看：块格式化上下文 | MDN。除此之外，flexbox 布局和 grids 布局中的 item 都会创建一个新的 BFC。 可参考：CSS之BFC详解 IFC 行内级盒（inline-level boxes） 当元素的 CSS 属性 display 的计算值为 inline，inline-block，inline-table，inline-flex 或 inline-grid 时，它是行内级元素。视觉上它将内容与其它行内级元素排列为一行，直到该行被占满然后换行。典型的如段落内容，文本或图片，都是行内级元素。 注：由于目前几乎所有资料都将行内元素当做行内级元素，所以前面的课程我们也遵循这个美丽的错误。严格来说，行内元素不包括 inline-block 的，行内级元素才包括。我们要理解其中的区别，知晓这个美丽的错误。 行内级元素生成行内级盒，参与行内格式化上下文（inline formatting context），被渲染为水平排列, 直到当行被占满然后换行。 每一行排列的行内级盒都可以看做由一个匿名的行盒包裹，如下图（使用了两种灰色背景色来模拟）： 渲染规则 当块容器盒（block container box）不包括任何块级盒（block-level boxes）时，就会创建一个行内格式化上下文（IFC）。（一般来说一个块级盒也是一个块容器盒） IFC 中的行内级盒将会按照如下规则进行渲染（规则有点多，大概主要点就是行盒，折行机制，水平对齐方式，垂直高度及垂直对齐方式）： 盒子一个接一个地水平摆放，当容器宽度不够时就会换行 在水平方向上，这些盒的外边距、边框、内边距所占用的空间都会被计算，但行内盒的垂直的border，padding 与 margin 都不会撑开行盒的高度 在垂直方向上，这些盒可能会以不同形式来对齐，可通过 vertical-align 来设置，默认对齐为 baseline 每一行将生成一个行盒（line box），包括该行所有的盒子，行盒的宽度是由包含块和存在的浮动来决定 行盒一般左右边都贴紧其包含块，但是会因为浮动盒（float 元素）的存在而发生变化。浮动盒会位于包含块边缘与行盒边缘之间，这样行盒的可用宽度就小于包含块的宽度 当所有盒的总宽度小于行盒的宽度，那么行盒中的水平方向排版由 text-align 属性来决定 当所有盒的总宽度超过一个行盒时，就会形成多个行盒，多个行盒相互之间垂直方向不能分离，不能重叠 当一个行内盒超过行盒的宽度时，它会被分割成多个盒，这些盒被分布在多个行盒里。如果一个行内盒不能被分割（比如只包含单个字符，或word-breaking机制被禁用，或该行内框受white-space属性值为nowrap或pre的影响），那么这个行内盒将溢出这个行盒 当一个行内盒发生分割时，分割处的 margin, border和 padding不会有任何视觉效果（或者其他任何分裂，只要是有多个行盒） 行盒的高度由内部元素中实际高度最高的元素计算出来。每个行盒的高度由于内容不一样，所以高度也可能不一样 在一个行盒中，当他包含的内部容器的高度小于行盒的高度的时候，内部容器的垂直位置可由自己的 vertical-align 属性来确定 注：在 IFC 的环境中，是不能存在块级元素的，如果将块级元素插入到 IFC 中，那么此 IFC 将会被破坏掉变成 BFC，而块级元素前的元素或文本和块级元素后的元素或文本将会各自自动产生一个匿名块盒其包围。 其他格式化上下文 除此之外，还有一些其他不同类型的盒子，如下： 表格布局：可以创建一个表格包裹盒(table wrapper box)，包括了表格盒(table box)及任何标题盒(caption boxes)。 多列布局：可以在容器盒与内容之间创建列盒(column boxes) 弹性布局：将会创建一个弹性容器盒（flex container box） 网格布局：将会创建一个网格容器盒（grid container box） 而这些盒子也将采用不用的格式化上下文来渲染，如 table formatting context（table 布局）、flex formatting context（flexbox 布局）、grid formatting context（grid 布局）。 可参考：视觉格式化模型 | MDN 定位方案上面我们所讨论的BFC、IFC其实都是常规流（normal flow）中盒子的摆放。但实际上我们有三种定位方案，分别为： 常规流（normal flow）：盒一个接一个排列，不同的盒子采用不同的格式化上下文渲染。 浮动（float）：盒将从常规流里提出来，放在当前盒的旁边。 绝对定位(absolute positioning)：盒将脱离常规流，其坐标是绝对的（通过 top / bottom / left / right 来设置）。 常规流（normal flow） 默认盒的定位方案就是常规流，但是如果触发了以下任何一个条件，将不会使用常规流： position 的值非 static 或 relative float 的值非 none 在常规流中，不同的盒子将采用不同的格式化上下文渲染，也就是上面所讲的部分。 浮动（float） 对于浮动定位方案, 盒称为浮动盒（floating boxes）。它位于当前行的开头或末尾。这导致常规流环绕在它的周边，除非设置 clear 属性。 要使用浮动定位方案，元素 CSS 属性 position 必须为 static 或 relative，然后 float 不为 none 。如果 float 设为 left, 则浮动定位到当前位置的开始位置，如果设为 right, 则浮动定位到当前位置的最后位置。 绝对定位（absolute position） 如果元素的属性 position 不是 static 或 relative， 那它就是绝对定位元素。 对于绝对定位方案，盒从常规流中被移除，不影响常规流的布局。 它的定位相对于它的包含块，定位坐标可通过属性 top、bottom、left、right 来设置 。 固定定位元素(fixed positioned element)也是绝对定位元素，它的包含块是视口。当页面滚动时它固定在屏幕上，因为视口没有移动。 float 及如何清除浮动元素浮动最开始的目的，就是实现文字环绕元素的效果 float的取值包括，none | left | right 。 浮动带来的问题：父元素高度塌陷。 如何清除浮动 清除浮动主要是为了解决由于浮动元素脱离文流导致的元素重叠或者父元素高度坍塌的问题，而这两个问题分别对应了需要清除浮动的两种种情况：清除前面兄弟元素浮动和闭合子元素浮动（解决父元素高度坍塌）。 清除前面兄弟元素浮动 清除前面兄弟元素浮动很简单，只需要在不想受到浮动元素影响的元素上使用 clear:both 即可。 在 CSS2 以前，clear 的原理为自动增加元素的上外边距（margin-top）值，使之最后落在浮动元素的下面。在 CSS2.1 中引入了一个清除区域（clearance）——在元素上外边距之上增加的额外间距，使之最后落在浮动元素的下面。 所以如果需要设置浮动元素与 clear 元素的间距，得设置浮动的元素的 margin-bottom，而不是 clear 元素的 margin-top。 闭合子元素浮动 我们知道，在计算页面排版的时候，如果没有设置父元素的高度，那么该父元素的高度是由他的子元素高度撑开的。但是如果子元素是设置了浮动，脱离了文档流，那么父元素计算高度的时候就会忽略该子元素，甚至当所有子元素都是浮动的时候，就会出现父元素高度为 0 的情况，这就是所谓的父元素高度坍塌问题。 为了能让父元素正确包裹子元素的高度，不发生坍塌，我们需要闭合子元素的浮动。 一般我们有两种办法可以用来闭合子元素浮动： 给最后一个元素设置 clear: both 给父元素新建一个 BFC(块格式化上下文) 方法一：由于我们最后一个元素使用 clear:both，所以该元素就能不受浮动元素影响出现在父元素的最底部，而父元素计算高度的时候需要考虑到这个正常元素的位置，所以高度自然包裹到了最底部，也就没有了坍塌。 对于这个方法，以前我们是利用新增一个空元素（&lt;b&gt; 或 &lt;span&gt; 或 &lt;div&gt; 等）来实现的，如下： 1234&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;span class=\"clear-box\"&gt;&lt;/span&gt;&lt;/div&gt; 123456.box &#123; float: left;&#125;.clear-box &#123; clear: both;&#125; 虽然这种办法比较直观，但是不是很优雅，因为增加了一个无用的空白标签，比较冗余而且不方便后期维护（一般不太建议使用该办法）。所以后期有了通过父元素的伪元素（::after）实现的著名 clearfix 方法，代码如下： 123&lt;div class=\"container clearfix\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/div&gt; 12345.clearfix::after &#123; content:\"\"; display:table; clear: both;&#125; 方法二：该方法的原理是：父元素在新建一个 BFC 时，其高度计算时会把浮动子元素的包进来。下面这些都可以创建一个 BFC： 根元素或其它包含它的元素 浮动 (元素的 float 不是 none) 绝对定位的元素 (元素具有 position 为 absolute 或 fixed) 内联块 inline-blocks (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) 块元素具有overflow ，且值不是 visible display: flow-root 虽然有这么多方法可用，可我们常用的就是 overflow: hidden，代码如下： 123&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/div&gt; 123456.container &#123; overflow: hidden;&#125;.box &#123; float: left;&#125; float 布局常见的float布局有，两栏布局、三栏布局、流动布局。 两栏布局：一栏固定宽度并设置浮动，另一栏可设置宽度并浮动，也可不设置宽度不浮动。 三栏布局：三栏均设置宽度并浮动。 流动布局：最外层容器设置margin左右值为auto；中间一栏设置左右margin值以给左右两栏预留位置；三栏均设置浮动，并且左右两栏根据margin-left来调整位置使其在中间栏的margin上。（左边栏为margin-left:-100%;右边栏为margin-left:-margin值。） 网格布局系统参考：960网格布局官网 960s是网格布局系统的鼻祖，当然随着技术的发展，基于它又发展了很多其他的网格布局系统，但是思想是想通的，无非是整体多少宽度分成几分，间距是多少，如何组合等。为什么是12列呢？因为12可以被2，3，4，6整除，这样做等分的时候是非常方便的。 position 属性position —— 设置元素的定位方式。四种取值： static（静态） relative（相对）—— 相对于自己的位置偏移 absolute（绝对）—— 相对于非static最近的父元素偏移 fixed（固定）—— 一般来说相对于视窗偏移 z-index 属性 网页正常文档流排版可以理解为在一个平面立面里面，元素占据空间，依次排列，互不覆盖。但是当页面中元素设置了定位属性的时候，难免会出现元素之间相互重叠的情况。 z-index 属性用于指定已定位元素在垂直于页面方向的排列顺序，其属性值有2种：auto（默认值）和整数。这里有2个需要注意的点： z-index 属性只对定位元素元素生效，也就是 position 属性不为 static 的元素。 除了默认值 auto， z-index 可以设置为任意整数，正数，0，负数都可以。 一般情况下，z-index 值进行比较有下面2条规则： 数值大的在上面(auto 数值上相当于0)。 数值相同的，在 HTML 结构中排后面的在上面。 层叠规则 默认HTML结构顺序。 position（非static值）元素高于其他元素。 position（非static值）元素之间先通过z-index值判断。 如果z-index相同则按照HTML结构顺序。 层叠上下文 上面说到，z-index 默认值 auto 数值上等于0，那设置了 z-index:0 和 默认的 z-index:auto; 有没有区别呢？ 答案是有区别的。区别在于设置了 z-index 属性为整数值(包括0)的元素，自身会创建一个层叠上下文。而创建一个层叠上下文之后，其子元素的层叠顺序就相对于父元素计算，不会与外部元素比较。即并不是所有情况 z-index 值大的元素都会在上面，我们在进行 z-index 比较的时候要留意其祖先元素有没有建立独立的层叠上下文，z-index 只有在同一个层叠上下文中比较才有意义。 另外，对定位元素设置 z-index 属性不是唯一创建层叠上下文的方法，具有下面属性的元素都会创建层叠上下文（具体可参看：层叠上下文 | MDN）： 根元素 (HTML) z-index 值不为 &quot;auto&quot;的 绝对/相对定位 一个 z-index 值不为 &quot;auto&quot;的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex opacity 属性值小于 1 的元素 transform 属性值不为 &quot;none&quot;的元素， mix-blend-mode 属性值不为 &quot;normal&quot;的元素， filter值不为“none”的元素， perspective值不为“none”的元素， isolation 属性被设置为 &quot;isolate&quot;的元素， position: fixed 在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考这篇文章） -webkit-overflow-scrolling 属性被设置 &quot;touch&quot;的元素 可参考：深入理解CSS中的层叠上下文和层叠顺序 、理解CSS的 z-index属性 。 flexbox 布局当给父元素设置display:flex属性后，其直接子元素会形成一个flexbox布局模型，可以非常容易的去排列子元素。父元素成为flex container，子元素称为flex item。 flex container 属性： flex-direction(主轴方向) : row | row-reverse | column | column-reverse flex-wrap(一条主轴排满后是否换行) : nowrap | wrap | wrap-reverse justify-content(主轴上的对齐方式) : flex-start | flex-end | center | space-between | space- around align-items(交叉轴的对齐方式) : stretch | flex-start | flex-end | center | baseline align-content(多根轴线对齐方式) : stretch | flex-start | flex-end | center | space-between | space-around flex item 属性： order(排列顺序) flex-grow(放大比例) flex-shrink(缩小比例) flex-basis(item所占主轴空间，会覆盖width) align-self(对齐方式，会覆盖align-items) 可参考：Flexbox playground 剩余空间分配相关属性 flexbox 布局中的子元素可以通过设置 flex 属性来改变其所分配到的空间大小。flex 属性包括了 flex-basis、 flex-grow、flex-shrink 。 flex-basis flex-basis 用来定义子元素的默认宽或高。如果父容器 flex-direction 属性的方向为水平方向则为宽度，如为垂直方向则为高度。相当于给子元素设置宽或高。如果同时设置了该属性与宽或高，则该属性权重大于宽或高的值。 flex-grow flex-grow 用来指定父容器多余空间的分配比率，默认值为0。如果子元素的宽度的总和超过父容器，flex-grow 将不生效。 flex-shrink flex-shrink 用来指定父容器空间不够时子元素的缩小比例，默认为1。如果一个 flexbox 项目的 flex-shrink 属性为0，则该元素不会被压缩。 关于flexbox布局，可参考：Flex布局教程：语法篇 、 Flex 布局教程：实例篇 grids 布局系统随着 CSS 的不断发展及完善，一种新的网格布局方式被纳入规范，它将会解决所有的网格问题，这就是我们要说的 CSS Grid Layout。 Grid Container：首先我们要设置父元素的布局为 grid，通过使用 display 属性给元素显式设置属性值grid或inline-grid，此时这个元素将自动变成网格容器，对应上图的Sheet1 Grid Item：Item 是 container 的直接子元素，如果不考虑单元格的合并跟下面的 cell 是一样的，如果有单元格合并，在该 item 可能包括几个cell，对应上图的一个个格子，如蓝色的 A1 Grid Lines：网格线分为水平线和垂直线，对应上图的橙色线条 Grid Track：就是由lines构成的水平和垂直空间，对应到上图的水平和垂直灰色区域，而对于table来说就是row和column Grid Cell：简单来说就是单元格了，对应到上图就是蓝色的A1，而对于table来说就是单元格 Grid Area：网格区域是由任意四条网格线组成的空间，可能由一个或多个单元格组成。对应到上图就是红色区域，相当于表格中的合并单元格之后的区域 网格系统基本属性 网格系统布局其实跟 flexbox 布局差不多，都是由父子元素构成的布局。所以属性分为父元素属性和子元素属性。 可参考：A Complete Guide to Grid 父元素（Grid Container）属性: 第一类：如何去定义一个网格系统，行列及间距等。 display：grid/inline-grid，定义使用网格系统 grid-template-columns：定义垂直栏 grid-template-rows：定义水平行 grid-template-areas：定义区域 grid-column-gap：定义垂直栏与垂直栏之间的间距，如上图的A与B之间的间距 grid-row-gap：定义水平行与水平行之间的间距，如上图的1与2之间的间距 grid-gap：上面两个栏与行间距的缩写 第二类：自动分配形式，当定义的行或列数量不够时，多出 item 的自动排列方式： grid-auto-columns：定义多出的 item 的自动column的宽度大小 grid-auto-rows：定义多出的 item 自动 row 的高度大小 grid-auto-flow：定义自动 item 是按照先水平方向排列还是垂直方向排列 分布对齐的方式（属性跟 flexbox 的有点像）。 justify-items：item 在水平行中的对齐方式 align-items：item 在垂直栏中的对齐方式 justify-content：整个水平行在 grid 范围的对齐方式，这里有个好用的 space-evenly 值，补足了以前flex的 space-around 和 space-between 的不足 align-content：整个垂直栏在 grid 范围的对齐方式 子元素（Grid Item）属性： 单元格所占格子多少 grid-column-start：item 的起始栏 grid-column-end：item 的结束栏 grid-column：起始栏和结束栏的简写 grid-row-start：item 的起始行 grid-row-end：item 的结束行 grid-row：起始行与结束行的简写 grid-area：item所在区域 单元格的自定义对齐方式，这个跟 flexbox 的 item 有点相似。 justify-self：自定义 item 的水平方向对齐方式 align-self：自定义 item 的垂直方向对齐方式 浏览器是如何渲染 HTML&amp;CSS 的 我们现在已经知道，使用 HTML &amp; CSS 可以搭建出一个漂亮的 Web 页面。那么浏览器到底是如何使用我们的 HTML &amp; CSS 渲染成我们在屏幕上所看到的页面呢？ 虽然具体渲染过程很复杂，但是还是可以将其分为几个关键路径，如下： 处理 HTML 标记并构建 DOM 树 处理 CSS 标记并构建 CSSOM 树 将 DOM 与 CSSOM 合并成一个渲染树 根据渲染树来布局，以计算每个节点的几何信息，再将各个节点绘制到屏幕上 构建 DOM 树 首先浏览器渲染页面前会根据 HTML 结构构建成对应的 DOM 树。以下面的 HTML 代码为例： 1234567891011&lt;html&gt; &lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; &lt;link href=\"style.css\" rel=\"stylesheet\"&gt; &lt;title&gt;Critical Path&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src=\"awesome-photo.jpg\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 其 DOM 树生成的流程如下图： 转换： 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。 令牌化： 浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，“”、“”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。 词法分析： 发出的令牌转换成定义其属性和规则的“对象”。 DOM 构建： 最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。 整个流程的最终输出就是我们这个简单页面的文档对象模型 (DOM)，如下图： 构建 CSSOM 树 在浏览器构建上面的 DOM 时，在文档的 head 部分遇到了一个 link 标记，该标记引用一个外部 CSS 样式表：style.css。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容： 1234567/* style.css */body &#123; font-size: 16px &#125;p &#123; font-weight: bold &#125;span &#123; color: red &#125;p span &#123; display: none &#125;img &#123; float: right &#125; 与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 过程，不过是为 CSS 而不是 HTML： CSS 字节转换成字符，接着转换成令牌和节点，最后挂靠到一个称为“CSS 对象模型”(CSSOM) 的树结构内： CSSOM 为何具有树结构？这是因为浏览器为页面上的任何对象计算最后一组样式时，都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式），然后通过应用更具体的规则（即规则“向下级联”）以递归方式优化计算的样式。 合并渲染树 接下来就是将 DOM 树与 CSSOM 树合并形成渲染树。渲染树会网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。 渲染树只包含渲染网页所需的节点，如display: none;的元素是不会出现在渲染树种的。 布局及绘制 有了渲染树，我们就可以进入“布局”阶段。到目前为止，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们尚未计算它们在设备视口内的确切位置和大小——这就是布局阶段，也称为自动重排。 为弄清每个对象在网页上的确切大小和位置，浏览器从渲染树的根节点开始进行遍历。让我们考虑下面这样一个简单的实例： 1234567891011&lt;html&gt; &lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; &lt;title&gt;Critial Path: Hello world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=\"width: 50%\"&gt; &lt;div style=\"width: 50%\"&gt;Hello world!&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 以上网页的正文包含两个嵌套 div：第一个（父）div 将节点的显示尺寸设置为视口宽度的 50%；而里面内嵌的第二个 div 将其宽度设置为其父项的 50%，即视口宽度的 25%。如下图： 布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素。 最后，既然我们知道了哪些节点可见、它们的计算样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素形成我们可见的页面。这一步通常称为绘制或栅格化。 重排与重绘一个页面渲染完毕后，随着用户的操作，或者数据变化，网页还会进行重新渲染。根据不同的触发条件，重新渲染分为两种情况：重排（reflow）和重绘（repaint）。 所有对元素视觉表现属性的修改，都会导致重绘（repaint）。比如修改了背景颜色、文字颜色等。 所有会触发元素布局发生变化的修改，都会导致重排（reflow）。比如窗口尺寸发生变化，删除、添加 DOM 元素，修改了影响元素盒子大小的 CSS 属性如 width、 height、 padding 等。 通常情况下，重排的影响更大，重排会导致文档局部或全部的重新运算：重新计算元素位置，大小。（改变一个元素的布局，可能会影响很多个元素的布局） 不管是重绘还是重排导致的重新渲染，都会阻塞浏览器。重新渲染的的过程中，JavaScript 会被阻塞，用户的交互行为也会被卡住。复杂的 CSS 动画甚至会拖慢 JavaScript 的运行速度。 导致重排和重绘的场景 CSS 属性改变,包括但不限于以下场景： 通过 display: none 隐藏 DOM 节点（导致重绘和重排） 通过 visibility: hidden 隐藏 DOM 节点 （导致重绘，因为它没有影响其它元素位置布局） CSS 动画 通过 JavaScript 添加样式，修改样式 可参考：CSS triggers（ 注：Composite （渲染层合并） 是 chrome 引入 GPU 加速带来的新概念。） 用户交互 对浏览器窗口进行缩放操作会导致重排 对 DOM 节点进行操作，添加、删除、更新 DOM 节点都会导致重排 光标 :hover 、进入文本输入框、修改浏览器的字体都会导致重排 最佳实践（减少重新渲染）所有的最佳实践都是围绕尽最大可能的降低重绘和重排的频率，来达到减少重新渲染的目的。 CSS 属性的读、写操作分开 浏览对 CSS 属性的连续修改做了优化，比如下面的连续修改两次 style，不会导致两次重新渲染： 12div.style.color = 'blue';div.style.marginTop = '30px'; 上面代码只会进行一次重新渲染。但是如果写的不好，则会触发两次重新渲染，如下： 123div.style.color = 'blue';var margin = parseInt(div.style.marginTop);div.style.marginTop = (margin + 10) + 'px'; 上面代码对 div 元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不重新渲染然后得到该元素的位置。 除此之外，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染： offsetTop/offsetLeft/offsetWidth/offsetHeight scrollTop/scrollLeft/scrollWidth/scrollHeight clientTop/clientLeft/clientWidth/clientHeight getComputedStyle() 通过 class 或者 csstext 来批量更新样式 上面对通过对 style 对 CSS 属性一个一个修改，其实更好的方式应该是通过 class 来批量化。 1234567891011// badvar left = 10;var top = 10;el.style.left = left + \"px\";el.style.top = top + \"px\";// goodel.className += \" theclassname\";// goodel.style.cssText += \"; left: \" + left + \"px; top: \" + top + \"px;\"; 其他方法 DOM 样式离线更新：尽量使用离线 DOM，而不是真实的网页 DOM 来改变元素样式。比如，操作 Document Fragment对象，完成后再把这个对象加入 DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。 使用 display: none 进行样式批量更新：先将元素设为 display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。 善用 position：position 属性为 absolute 或 fixed 的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。 将元素设置为不可见：只在必要的时候，才将元素的 display 属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden 的元素只对重绘有影响，不影响重排。 减少样式的更新频率：使用虚拟 DOM 脚本库，比如 React 等。 调节 js 运行帧率：使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染的频率。 慎用 table 布局：table 的单元格具有非常好的自适应特性，但是同时代价也很高，能不用就不用。如果非要使用 table ，给 table 添加 table-layout: fixed 属性，这个属性的目的是让后面单元格的宽度由表头的宽度来决定——减少布局的计算量。 可参考：网页性能管理详解 、 无线性能优化：Composite","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ice-io.github.io/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://ice-io.github.io/tags/HTML/"}]},{"title":"前端知识总结——CSS基础","slug":"前端知识总结——CSS基础","date":"2017-08-10T14:35:46.000Z","updated":"2017-09-10T08:55:30.067Z","comments":true,"path":"2017/08/10/前端知识总结——CSS基础/","link":"","permalink":"http://ice-io.github.io/2017/08/10/前端知识总结——CSS基础/","excerpt":"这一篇文章将回顾之前所学的CSS基础知识。","text":"这一篇文章将回顾之前所学的CSS基础知识。 CSS基础 CSS，即Cascading Style Sheet，层叠样式表，用来修饰网页。 CSS语法 h1{color:red;font-size:20px}包含选择器、属性、属性值，当然最好写成下面的样子方便阅读和维护： 1234h1 &#123; color: red; font-size: 20px;&#125; CSS注释 单行注释：/* 注释内容 */ 多行注释： 1234/* 注释 内容*/ 引入CSS 行内样式（通过标签的style属性）——[缺点：样式结构混在一起；冗余；] 内联样式（通过style标签写入CSS）——[缺点：冗余；] 行内样式（通过link标签引入CSS文件）——[解决了前两种方式的缺点] 但是，这三种方式，各有其应用场景。另外要注意@import引入方式的缺点： 范畴不同：link标签引入属于HTML，@import则属于CSS。 兼容性：@import不兼容旧版浏览器。 加载顺序：@import需要等到文档最后才加载。 脚本操作：@import不支持JavaScript的修改操作。 CSS中的选择器总共分为5大类： 基础选择器、关系选择器、伪类选择器、属性选择器、伪元素选择器。 使用时注意选择器分组——将相同样式分组定义共用，简化代码。可参考：CSS选择器参考手册 基础选择器 通用选择器(*) 元素选择器(p) 类选择器(.class) id选择器(#id) 关系选择器 子代选择器(div&gt;p) 后代选择器(div p) 兄弟选择器(div~p 、div+p) 伪类选择器 :link :visited :hover :active :first-child :last-child :nth-child(n) :nth-lastchild(n) 伪元素选择器 ::before ::after ::first-letter ::first-line 属性选择器 选择器 描述 [attribute] 用于选取带有指定属性的元素 [attribute=value] 用于选取带有指定属性和值的元素 [attribute\\^=value] 匹配属性值以指定值开头的每个元素 [attribute$=value] 匹配属性值以指定值结尾的每个元素 [attribute*=value] 匹配属性值中包含指定值的每个元素 [attribute~=value] 用于选取属性值中包含指定词汇的元素 [attribute&#124;=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词 选择器的优化 现在我们知道了选择器有很多种，但是对于浏览器来说，解析每种选择器所耗费的时间并不是一样的。所以当我们使用选择器的时候也有必要了解如何才能写出最优选择器。 各种 CSS 选择器的效率由高至低排序如下： id选择器（#myid） 类选择器（.myclassname） 标签选择器（div,h1,p） 相邻选择器（h1 + p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（*） 属性选择器（a[rel=&quot;external&quot;]） 伪类选择器（a:hover,li:nth-child） 选择器的解读顺序是怎样的？ 一般来说，在具体的项目中，HTML 结构都比较复杂，所以关系选择器使用非常的普遍。对于关系选择器来说，我们的阅读习惯是从左到右，但是浏览器解读选择器，遵循的原则是从选择器的右边到左边读取。 如对于选择器.list .item .item-tt，浏览器先找的是.item-tt，然后继续向父级元素寻找.item，再找.list，这样才完成了最终的选择器匹配。所以如果路径链越短，效率也就相应有所提高。这里建议选择器的层级最多不要超过4层，如.demo .list .item .item-tt .tt-link就有5层了，可根据实际情况考虑缩短为4层以内，如.demo .item-tt .tt-link。 如何提高CSS选择器性能呢？ CSS选择器对性能的影响源于浏览器匹配选择器和文档元素时所消耗的时间，所以优化选择器的原则是应尽量避免使用消耗更多匹配时间的选择器。 可以通过以下几点来优化： 避免使用通用选择器 避免使用标签或 class 选择器来限制 id 选择器 避免使用标签限制 class 选择器 避免使用多层标签选择器。使用 class 选择器替换，减少css查找 避免使用子选择器 使用继承 CSS中的属性和值字体相关属性 font-family：定义文本的字体，如：font-family: arial; font-size：字体尺寸，如：font-size: 18px; font-style ：字体样式，如：font-style: italic; font-weight：字体的粗细，如：font-weight: bold; 文本相关属性 color：定义文字颜色，如：color: red; line-height：设置行高，如：line-height: 1.5; text-align：文本的水平对齐方式，如：text-aligin: center; text-decoration：文本的装饰效果，如：text-decoration: underline; text-indent：首行的缩进，如：text-indent: 2em; text-shadow：文本的阴影效果，如：text-shadow: 0 0 5px #ff0000; 列表属性 list-style：在一个声明中设置所有的列表属性 list-style-image：将图象设置为列表项标记 list-style-position：设置列表项标记的放置位置 list-style-type：设置列表项标记的类型 表格属性 border-collapse：是否合并表格边框 border-spacing：相邻单元格边框之间的距离 table-layout：设置表格的布局算法 盒子大小 width min-width max-width height min-height max-height box-sizing 盒子边框 border：简写模式，四边边框 border-width：边框宽度 border-style：边框样式，常用的为solid和dashed border-color：边框颜色 border-top：上边框 border-right：右边框 border-bottom：下边框 border-left：左边框 盒子内外边距 margin margin-top margin-right margin-bottom margin-left padding padding-top padding-right padding-bottom padding-left 盒子背景 background：总的简写形式，包括了下面各个单条属性 background-color：背景色 background-image：背景图片 background-position：背景图片起始位置 background-repeat：背景图片平铺方式 background-size：背景图片大小 background-clip：背景图片绘制区域 background-origin：背景图片的定位区域 盒子其他 overflow：指定当内容溢出其块级容器时,是否剪辑内容，渲染滚动条或显示内容 visibility：是否可见 border-radius：圆角 box-shadow：阴影 空间位置相关 display float clear position top right bottom left transform z-index opacity 动画相关 transition animation 可参考:CSS 参考 | MDN 、CSS 参考手册 | W3school 自定义字体 一般来说，网页上的字体使用的都是我们电脑里面的字体，比如我们常说的微软雅黑、宋体就是 windows 系统自带的字体。所以你可以看到网页的字体一般都比较中规中矩，不像平面设计那样各种新花样。但是我们在浏览一些网站时，还是可以发现一些非常酷炫和高端的字体。 那么如何实现自定义字体的效果呢？答案是 CSS 的 @font-face 。 @font-face 的语法规则如下： 123456@font-face &#123; font-family: &lt;fontFamily&gt;; /* 自定义的字体名称; */ src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*; /* 自定义的字体的存放路径、格式; */ [font-weight: &lt;weight&gt;]; /* 是否为粗体 */ [font-style: &lt;style&gt;]; /* 定义字体样式，如斜体 */&#125; 其取值说明如下： fontFamily：此值指的就是你自定义的字体名称，如font-family: myFirstFont。 source：此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝对路径。 format：此值表达自定义的字体的格式，用于帮助浏览器识别字体类型。 weight和style：这两个值大家一定很熟悉，weight 定义字体是否为粗体，style 主要定义字体样式，如斜体。 推荐：dafont字体 字体格式 TrueType (.ttf) Windows 和 Mac 系统最常用的字体格式，其最大的特点就是它是由一种数学模式来进行定义的基于轮廓技术的字体，这使得它们比基于矢量的字体更容易处理，保证了屏幕与打印输出的一致性。同时，这类字体和矢量字体一样可以随意缩放、旋转而不必担心会出现锯齿。 OpenType (.otf) OpenType 是一种可缩放字型（scalable font）电脑字体类型，采用 PostScript 格式，是美国微软公司与Adobe 公司联合开发，用来替代 TrueType 字型的新字型。这类字体的文件扩展名为.otf，类型代码是 OTTO。 Embedded Open Type (.eot) 嵌入字体格式（EOT）是微软开发的一种技术，允许 OpenType 字体嵌入到网页并可以下载至浏览器渲染。这些文件只在当前页活动的状态下，临时安装在用户的系统中。 Web Open Font Format (.woff) 相对于 TrueType 和 OpenType ，WOFF（Web开发字体格式）是一种专门为了 Web 而设计的字体格式标准，它并不复杂，实际上只是对于 TrueType / OpenType 等字体格式的封装，并针对网络使用加以优化：每个字体文件中含有字体以及针对字体的元数据（ Metadata ），字体文件被压缩，以便于网络传输，并且不包含任何加密或者 DRM 措施。 Scalable Vector Graphics Fonts (.svg) 顾名思义，就是使用SVG技术来呈现字体，还有一种 gzip 压缩格式的 SVG 字体 .svgz。 这么多字体带来的问题是浏览器的支持：目前现代浏览器基本都支持 .ttf、 .otf、 .woff 的字体格式。但需要注意的是 IE8以下仅支持 .eot 格式，而 .svg 目前只有 safari 支持。 自定义图标字体（iconfont） 我们经常会在网页中使用这些图标，以前主要是通过背景图去做的，每次换个颜色或改个大小就得重新切个图，所以维护使用比较繁琐。这样图标字体就应时而生，它提供了一种解决方案：把一些简单的图标制作成字体，然后让图标变成和文字一样可以通过 CSS 去改变颜色大小等。 对于使用图片的图标来说，iconfont 图标有许多优点： 灵活性：改变图标的颜色，背景色，大小都非常简单 兼容性：基本没有兼容性问题，在IE6，Android2.3都能够兼容 扩展性：替换图标很方便，新增图标也非常简单 高效性：iconfont有矢量特性，不会失真 轻便性：在使用上字体文件和普通的静态资源一样，既可以外链也可以内链，并且字体文件也可以使用gzip压缩 推荐：Fontello CSS中的单位 px px 是 pixels（像素）的缩写，是一种绝对单位，用于屏幕显示器上，传统上一个像素对应于计算机屏幕上的一个点，而对于高清屏则对应更多。任何现代显示屏，不管是手机，平板，笔记本还是电视都是由成千上万的像素组成的，所以我们可以使用这些像素来定义长度。 % %（百分比）应该是我们最好理解的单位了，即相对于父元素。 如果对 html 元素设置 font-size 为百分比值，则是以浏览器默认的字体大小16px为参照计算的（所有浏览器的默认字体大小都为 16px），如62.5%即等于10px（62.5% * 16px = 10px）。 em em 也是一种相对单位，既然是相对单位，那么肯定有一个参照值。不过其参照值并不是固定不变的，而是不同的属性有不同的参照值。 对于字体大小属性（font-size）来说，em 的计算方式是相对于父元素的字体大小，1em 等于父元素设置的字体大小。如果父元素没有设置字体大小，则继续往父级元素查找，直到有设置大小的，如果都没有设置大小，则使用浏览器默认的字体大小。 在(border, width, height, padding, margin, line-height)这些属性中，使用em单位的计算方式是参照该元素的 font-size，1em 等于该元素设置的字体大小。同理如果该元素没有设置，则一直向父级元素查找，直到找到，如果都没有设置大小，则使用浏览器默认的字体大小。 rem 和 em 一样，rem 也是一种相对单位，不过不一样的是 rem 是相对于根元素 html 的 font-size 来计算的，所以其参照物是固定的。（rem的r就是表示root，虽然rem相对em进步了很多，但是由于是新技术，不支持IE8以下（包括IE8）,不过幸喜的是移动端可以放心使用） 由于 rem 是基于跟元素 html 的 font-size 来计算的，所以如果改变 html 的 font-size 值，那么所有使用的 rem 单位的大小都会随着改变，这对于移动端适应各种屏幕大小来说还是有点作用的。 vw, vh, vmin, vmax 这四个单位属于 v 系单位，它们也是相对单位，是基于视窗大小（浏览器用来显示内容的区域大小）来计算的。 网页中我们很多时候都需要用到满屏，或者屏幕大小的一半等，尤其是移动端，屏幕大小各式各样，而这个时候我们现有的单位就显得有点捉襟见肘，于是就诞生了这四个单位。 vw：基于视窗的宽度计算，1vw 等于视窗宽度的百分之一 vh：基于视窗的高度计算，1vh 等于视窗高度的百分之一 vmin：基于vw和vh中的最小值来计算，1vmin 等于最小值的百分之一 vmax：基于vw和vh中的最大值来计算，1vmax 等于最大值的百分之一 单位运算 除了设置以上的单位之外，我们还可以使用 calc 来进行单位运算，单位运算时可以使用各种单位进行加减乘除运算。简单示例如下： 12345.box &#123; height: calc(50vh - 20px); /* 50% 的视窗高度减掉20px */ width: calc(100% / 3); /* 三分之一的父容器宽度 */ background: red;&#125; CSS中的颜色 颜色关键词 如 red，green，gray 等，除此之外，还有两个关键词可用，分别是 transparent 和 currentColor。 RGB 表示使用红-绿-蓝模式来定义颜色。 十六进制 十六进制颜色表现形式为： #RRGGBB 和 #RGB RGBa 在 rgb 的基础上，还可以添加一个 alpha 透明度表示半透明值，这样就构成了我 rgba，其函数表示为：rgb(red, green, blue, alpha)，其中 alpha 参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。 hsl 除了使用红-绿-蓝的模式定义颜色之外，还可以通过 hue（色调）、saturation（饱和度）、lightness（亮度）模式定义颜色，其语法为：hsl(hue, saturation, lightness) 。 CSS中的盒模型HTML文档中的每个元素在渲染的时候都会被描绘成一个矩形盒子，而盒模型正是用来表示每个元素盒子所占用空间大小的模型。 在我们现实生活中，描述一个矩形直接用宽和高即可。但是在CSS中主要通过四个部分来描述，分别为：margin（外边距），border（边框），padding（内边距），content（内容区域）。如下图： 盒模型计算方式 一般来说，默认的盒模型实际占用空间计算模式为： 水平空间大小 = margin(左右) + border(左右) + padding(左右) + width 垂直空间大小 = margin(上下) +border(上下) + padding(上下) + height 因为外边距(margin)为元素之间的距离，所以如果扣除它，则一个元素的实际大小就是 border + padding + width/height 。 这种计算模式在对于非 px 为单位的宽高设置时，会带来非常大的计算困扰。如下： 1234.box &#123;width: 50%;border: 1px solid #ccc;&#125; 我们想要的肯定是50%，但是实际的大小却是 50% + 2px ，这多出的 2px 就很让人无奈了，于是为了不破坏这 50% 的宽度，往往得再内嵌一层元素用来设置 border ，就成了下面这样： 123456.box &#123;width: 50%;&#125;.box .box-inner &#123;border: 1px solid #ccc;&#125; 这种解决方式显然不太科学，至少导致了 HTML 结构的臃肿，而 box-sizing 属性的出现就解决了这个问题，它就是用来改变元素宽高的计算方式。 box-sizing 属性有两个常用的取值 content-box 和 border-box 。 如为 content-box （这也是默认值）则实际宽度为上面所说的计算方式：实际宽高 = border + padding + width/height 。 如为 border-box 则是另一种计算方式，其实际宽高就是设置的 width/height 。 了解盒模型的计算方式是非常重要的，现在的网页，尤其是移动端的页面，需要适应于不同的屏幕大小，所以一般都会提前设置所有元素的盒模型都为 border-box 模式，以方便以后宽高的计算。代码设置如下： 123* &#123; box-sizing: border-box;&#125; 盒模型相关属性 上面已经说了 box-sizing 属性可以控制元素宽高的计算方式，除此之外，盒模型还有下面几个相关属性需要掌握： width(包括min-width, max-width)：宽 height(包括min-height, max-height)：高 padding：内边距 border：边框 margin：外边距上面五大属性，除了 width 和 height 以外，padding、border 和margin 属性都是由四边组成的，每边都可以设置自己的单独值，还可以简写。 我们先说下盒模型的四边，方向分别为上、下、左、右，而 CSS 中表示就分别是 top、bottom、left、right，如下图表示： 首先，我们可以单独给每个方向设置各自的margin，分别对应我们下面四个属性： margin-top：top 方向单个值 margin-right：right 方向单个值 margin-bottom：bottom 方向单个值 margin-left：left 方向单个值 很显然，如果四个方向都有值的话，上面四个每个都要写一次是一件多么费力的事，于是我们又有了一条总的属性 margin margin：a b c d; 表示四个方向的值 margin: 10px; 表示四个方向的值都是10px 123456789101112/* 简写之前 */.box &#123;margin-top: 10px;margin-right: 20px;margin-bottom: 30px;margin-left: 40px;&#125;/* 简写之后 */.box &#123;margin: 10px 20px 30px 40px; /* 注意顺序以top开始，顺时针方向 */&#125; 这种取值模式其实并不是 margin 所独有的，同样 padding 也是按照这个模式来的。而且是一模一样的，而 border 相对来说还要更复杂点，border的简写，其简写模式为：border: 1px solid #ccc;。 border 的简写其实是由 border-width，border-style，border-color 三个属性组合而成的。1px 就是 border-width，solid 就是 border-style，#ccc 就是 border-color。 而这三个属性，它们如果单独来写，其取值模式就和margin是一样的了，都可以设置1-4个值，如： 12345.box &#123;border-color: #f00 #ccc #ccc; /* top left和right bottom */border-width: 2px 1px; /* top和bottom left和right*/border-style: solid; /* all */&#125; 除此之外，border当然也有表示方向的属性，如border-left: 1px solid #f00;，则表示左边框为1px红色的实线。同样还有border-top，border-right，border-bottom。而方向又可以和边框属性结合，如border-top-width，border-top-style，border-top-color。 所以，如果我们要设置不一样的边框，一般可以先设置个默认一样的，然后再通过单边的，或者通过border-width，border-style，border-color去特殊设置 。 CSS中元素的显示与隐藏 display属性 所有的后代元素都隐藏 元素隐藏后不再占用空间 visibility属性 元素所占的空间位置不变，可理解为元素透明了 如子元素设为visibility:visible，则该子元素依然可见 overflow属性 规定了当内容元素溢出父容器时的展现形式 裁剪内容，使用滚动条来显示或直接显示超出部分 CSS中的背景简写(推荐)： background 分步写： background-color background-image background-repeat background-position background-size CSS中的图片图片作为网页必不可少的一部分，在网页中占据着非常重要地位。一般来说，有以下两种方式来使用图片： 通过 img 元素直接使用 通过 background-image（背景图片）的形式使用 这两种形式的区别在于，前者一般具有实际含义（如产品图片，相册图片等），而后者一般用于装饰效果。 目前网页中常用的图片大概有如下几种格式，它们有着各自的显著特点，被应用在各种不同的场景： jpg/jpeg：由于其色彩还原度比较好，所以一般色彩丰富的图片均采用该格式，如宣传图、产品图、相册图等等。 png：由于其对透明度的良好支持，所以一般用于透明图片，如 logo 图、图标图等。 gif：由于其对动画的支持，所以一般用来实现动效图片，如 loading 加载动画、一些搞笑图片等。 ico 格式属于图标文件，主要用于网址前面的标识图标。 webp 格式是由 google 研发的图片格式，它既具备高压缩率，又具备透明度以及动画的特性。目前各个大互联网公司都有在使用该格式，其带来的效果也非常显著。但是该格式有个明显的缺陷：目前浏览器端只有 google 浏览器支持。 WebP 的优势 PNG 转 WebP 的压缩率要高于 PNG 原图压缩率，同样支持有损与无损压缩 转换后的 WebP 体积大幅减少，图片质量也得到保障（同时肉眼几乎无法看出差异） 转换后的 WebP 支持 Alpha 透明和 24-bit 颜色数，不存在 PNG8 色彩不够丰富和在浏览器中可能会出现毛边的问题 WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。 关于网页媒体文件可参考：网络媒体教程 | W3school 关于WebP可参考：WebP 探寻之路 、WebP 相对于 PNG、JPG 有什么优势？ 图片优化 通过HTTP Archieve统计显示，图片内容已经占到了互联网内容总量的65%左右。如此多的图片，当然占用了很多流量及时间，所以从性能优化的角度看，图片绝对是优化的热点和重点之一。可参考：前端图片优化机制 雪碧图在网站开发中，我们经常会使用一些背景图片来点缀效果，如一些形象生动的小图标。这种背景图片一多，网络请求就多了。这样为了减少网络请求，我们把一些小的背景图合并在一个大的图中，然后通过 CSS 的背景定位技术去使用。我们把这种技术叫做 CSS Sprite，也叫雪碧图，还叫 CSS 精灵。 雪碧图的应用原理 通过上面讲述，我们知道雪碧图是一张大的合并图，每个小图标其实只是截取大图的一部分来显示。如下图所示，我们有一张带有各种表情图标的雪碧图，其中每个表情图标都占领着相应的位置。 假如我们需要显示开心表情的这一个图标，我们需要计算开心图标在合并图中相应的位置和其图标的大小。以雪碧图的左上角为坐标中心，我们得出开心表情刚好在坐标的原点，即 X 轴0像素，Y 轴0像素的位置，且我们可以得出图标的宽高均为96像素。 因此我们设置这个图标元素的背景图片为这张雪碧图，背景位置为图标在雪碧图中的坐标，这样开心的图标就显示出来了。 12345678.happy &#123; display:inline-block; width: 96px; height: 96px; background-image: url(sprite.png); /* 设置背景图片 */ background-repeat: no-repeat; /* 设置为不平铺 */ background-position: 0 0; /* 设置图标位置 */&#125; 假如我们还要使用到哭泣的表情。同理所得，计算出哭泣的图标的位置在雪碧图的 X 轴向右192像素， Y 轴向下96像素。 12345678.cry &#123; display:inline-block; width: 96px; height: 96px; background-image: url(sprite.png); /* 设置背景图片 */ background-repeat: no-repeat; /* 设置为不平铺 */ background-position: -192px -96px; /* 设置图标位置 */&#125; 关于坐标的问题，可以这么理解：我们定义了一个视口，固定在大图的左上角，也就是（0，0），当我们想看到哪张小图的时候，就挪动大图使其移动到视口处。 雪碧图的制作 制作雪碧图的方式有许多，大概有如下几种方法： 使用 photoshop 等图片编辑工具 在线工具 目前有许多在线合成雪碧图的站点，只需要将图片上传上去，便可以根据设置，生成想要的雪碧图以及对应的 CSS 样式文件，如 spritegen、css sprites generator。 甚至我们合好的图片，也可以通过 spritecow 来帮我们完成对应的 CSS 定位。 构建工具 除了上面两种，我们还可以通过如webpack, fis3, gulp等构建工具来完成雪碧图生成工作。可参考：webpack 自动雪碧图生成 、fis3 CssSprite图片合并 。 雪碧图与字体图标优劣雪碧图的优势： 图标更美观 由于 iconfont 的图标只能设置单色，而雪碧图的图标由于是图片，所以能展现出更为美观的图标效果。 制作成本更低 iconfont 的制作较为麻烦，需要设计师按照规范，一一制作图标的 svg 文件。而雪碧图的制作只需合并图片即可，在制作成本上更低。 雪碧图的劣势： 高清屏下会失真（第三章会介绍） 在 2x 的设备像素比的屏幕上，如果要达到和文字一样的清晰度，图片的宽度需要实际显示大小的两倍，否则看起来会比较模糊。 雪碧图不方便变化 雪碧图本质上是一张静态的图片，因此无法灵活地通过样式去动态改变图片图标的颜色和其他效果。 CSS中的渐变背景在定义背景图片时，除了使用正常的图片之外，我们还可以通过 CSS3 的 gradient 去创造渐变背景图。同比使用图像的方案，使用 CSS3 gradient 来实现可以减少带宽和页面加载时间。 目前浏览器可以支持两种类型的渐变： 线性渐变 (linear)，通过 linear-gradient 函数定义 径向渐变 (radial)，通过 radial-gradient 函数定义 线性渐变 (linear-gradient)，即沿着一个方向线性的进行着颜色之间的平滑过渡的一个渐变过程。为了创建一个线性渐变，你必须至少定义两种颜色，同时你也可以设置一个方向或一个角度。其标准语法如下： background: linear-gradient([ &lt;angle&gt; | to &lt;side-or-corner&gt;], color-stop, ..., color-stop); angle：表示线性渐变的角度，该角度是指水平线和渐变线之间的角度，以顺时针方向计算。换句话说，0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。 side-or-corner：表示方向关键词（top、right、bottom、left、left top、top right、bottom right 或 left bottom）。这个参数值可以省略，当省略不写的时候其取值为“to bottom”。 color-stop：表示渐变的色标，每个色标包含一种颜色和一个位置，位置可以被指定为线长度的百分比或一个绝对长度。为实现期望的效果，可以指定任意多个色标。 径向渐变 (radial-gradient)，不同于线性渐变，径向渐变是一种由指定渐变的中心按照设定的大小，向外成圆型或椭圆形扩散的渐变。其标准语法如下： background: radial-gradient(position, shape size, color-stop, ..., color-stop); position：指定渐变中心的位置，可用百分比指定径向渐变圆心的坐标值，或者用长度值指定径向渐变圆心的坐标值，也可以设置left, right, top, bottom, center等位置值 shape：定义渐变的形状，取值如下： circle 指定圆形的径向渐变 ellipse 指定椭圆形的径向渐变，默认值 size：定义了渐变的大小，取值如下： closest-side：指定径向渐变的半径长度为从圆心到离圆心最近的边 closest-corner：指定径向渐变的半径长度为从圆心到离圆心最近的角 farthest-side：指定径向渐变的半径长度为从圆心到离圆心最远的边 farthest-corner：指定径向渐变的半径长度为从圆心到离圆心最远的角 color-stop：跟线性渐变的色标一样。 默认情况下，渐变中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。 可参考：使用CSS渐变 | MDN CSS中容器按比例缩放 一般在响应式中，我们会要求视频的宽高比为16：9或4：3，这么一来就比较头大了。当用户改变浏览器宽度的时候（改变高度不考虑），视频的宽度变了，那么高度也得根据我们要求的16：9或4：3改变。 有人给出了巧妙的解决方案：提供一个容器，设置容器的高度为0，再设置padding-bottom为56.25%（9:16）（因为padding的百分比是按照容器宽度计算的，所以由padding来撑开容器高度，而不是height，保证了容器的宽高比例），最后设置视频绝对定位，其宽高为容器的100%。 12345678910111213.wrap&#123; height: 0; padding-bottom: 56.25%; /* 16:9 */ position: relative; width: 100%;&#125;.wrap .video&#123; position: absolute; left: 0; top: 0; width: 100%; height: 100%;&#125; CSS简写 CSS 规范定义简写属性的目的在于将那些关于同一主题的常见属性的定义集中在一起。如我们已经说过的margin、padding、border等。 字体相关属性 font 相关属性用于设置字体，主要由以下几个属性组成： font-family：字体家族 font-size：字体大小 line-height：行高 font-weight：字体粗细 font-style：字体样式 font-variant：变体 其简写语法为： font: size/line-height weight style variant family; 圆角属性border-radius 的取值其实和 margin 也差不多，不过它描述的是角，顺序如下（top-left，top-right，bottom-right，bottom-left） 。 可参考：border-radius | MDN 背景相关属性简写 1234567891011/* 简写前 */.bg &#123; background-color: #fff; background-image: url(images/bg.png); background-repeat: no-repeat; background-position: bottom right;&#125;/* 简写后 */.bg &#123; background: #fff url(images/bg.png) no-repeat bottom right;&#125; 但是 CSS3 时代又加入了 background-size、background-origin、background-clip 及多个值，整体上比之前复杂了很多，但是没关系，这些新加的属性你可以单独写（先建议单独写，因为可能这些新的属性还有些浏览器兼容问题）。 1234.bg &#123; background: #fff url(images/bg.png) no-repeat bottom right; background-size: cover;&#125; 动画相关属性 transition用于过渡动画，跟background差不多，transition属性也是由几个属性组成，如下： transition-property：应用过渡效果的CSS属性名称 transition-duration：过渡效果花费的时间 transition-timing-function：过渡效果的时间曲线 transition-delay：过渡效果何时开始 其简写语法为：transition: property duration timing-function delay; animation用于帧动画，在属性组成上，只是比transition多了几个而已。 animation-name：@keyframes 动画的名称 animation-duration：动画完成一个周期所花费的秒或毫秒 animation-timing-function：动画的速度曲线 animation-delay：动画何时开始 animation-iteration-count：动画被播放的次数 animation-direction：动画是否在下一周期逆向地播放 animation-play-state：动画是否正在运行或暂停 animation-fill-mode：动画时间之外的状态 其简写语法为：animation: name duration timing-function delay iteration-count direction play-state fill-mode; 值简写 除了属性可以通过组合的形式进行简写，一些满足条件的值也可以进行适当的“偷工减料”。 一般来说以0+单位出现的值，都可以直接用0，省略单位，如0px可直接写成0（但0deg不允许去掉 deg ） 同样一般小于1的小数的都可以省略前面的0，如0.3s可以直接写.3s 颜色值如果采用十六进制，表示红绿蓝的每两位都一样的话，可以省略一位。如#336699，则可省略为#369 样式计算样式包括浏览器默认样式、继承的样式、声明的样式，最后表现出的样式是按照这三种样式的叠加规则来展示的。优先级由高到低为：声明样式——浏览器默认样式——继承样式。这也是层叠样式表（CSS）这个名字的由来。 样式优先级 style &gt; id选择器 &gt; 类选择器（属性、伪类） &gt; 元素选择器（伪元素） &gt; 通用选择器 在关系选择器中，比较优先级应该先从优先级最高的选择器开始比较。 !important表示最高级别。 得到的结论大概如下： !important &gt; style &gt; id选择器 &gt; 类选择器(伪类，属性) &gt; 元素选择器（伪元素） &gt; * &gt; 浏览器默认 &gt; 继承 可参考：优先级 | MDN 常见继承的属性 文本相关属性都可以继承 1color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、letter-spacing、word-spacing、white-space、word-break、overflow-wrap、line-height、direction、text-indent、text-align、text-shadow 列表相关属性 1list-style-image、list-style-position、list-style-type、list-style 表格相关属性 1border-collapse、border-spacing visibility 和 cursor 常见非继承属性 盒模型相关属性 1margin、border、padding、height、min-height、max-height、width、min-width、max-width、box-sizing 布局类属性 1display、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align 系列类 1background 系列、transform 系列、transtion 系列、animation 系列、flexbox 系列、grid 系列 浏览器兼容 首先浏览器有很多种，每种浏览器会存在一定的差异，其次每个浏览器都有不同的版本，版本之间也存在必然的差异，而我们做出来的页面则需要各个浏览器以及不同版本表现一致，所以必然存在兼容问题。 一般来说兼容问题我们可以分两步走：第一步是确定浏览器是否支持，第二步是如果表现不一致，怎么去修复。 浏览器是否支持 一般来说，由于技术的不断改进和发展，大概存在以下几种问题： 新技术在老版本的浏览器总是不支持的（如ie8以下对 CSS3 支持几乎是空白） 由于新技术刚出现时，可能还没有完全定稿标准化，所以各个新浏览器一般都是先试探性的使用前缀的办法使用 同样的技术在不同的浏览器上可能表现也不一样。 对于这些问题，我们可以查阅 Can I use ，里面提供了各种浏览器支持情况。 在查阅 Can I use 的时候，我们可以看到有些版本的右上角标有-符号，这就标识该版本得使用前缀，目前我们常见的前缀有-webkit（webkit内核浏览器）、-ms（ie/edge）、-moz（火狐浏览器） 如何针对修复 如果问题出现了，我们怎么针对某些浏览器进行特定的修复而不影响到其他正常的浏览器。这个时候就可以参考浏览器hack详细，里面提供了针对各种浏览器单独写样式的很多方法（不一定所有办法都可以，但是你可以挑选一个可以的） CSS重置现在我们已经知道了，某些元素即使我们不对它声明样式，浏览器也会有些默认的样式，如 h1、p。那么问题来了，浏览器有那么多（Chrome，Firefox，IE 等），每个浏览器的默认样式是否一致呢？很可惜，这个答案是否定的。 纠正重置 由于各个浏览器的默认样式有些差异，所以我们开始 CSS 的第一步应该是要消除这些差异，让表现一致。毕竟我们的最终目标就是得给用户看到一致的页面，不论用户使用什么浏览器。这方面我们有开源的 normalize.css，它就是为了消除各个浏览器默认样式之间的差异而生的。 清零重置 虽然我们通过 normalize.css 消除了各浏览器默认样式的差异，但是我们日常开发中也有些不需要浏览器的默认样式的（毕竟默认的样式还是比较粗糙的），这样就构成了我们第二次的重置——清零重置。如一些元素的 margin ，我们实际排版的时候都是跟着设计稿效果图走的，这种默认外边距反而有点碍事，所以先清为零： 12345678910h1, h2, h3, h4, h5, h6, p, figure, form, blockquote &#123; margin: 0;&#125;ul, ol, li, dl, dd &#123; margin: 0; padding: 0;&#125;ul, ol &#123; list-style: none outside none;&#125; 又如列表类元素，实际使用中，我们几乎不需要前面的那个 list-style-type（圆点或数字等）所以也得清除掉： 1234567ul, ol, li, dl, dd &#123; margin: 0; padding: 0;&#125;ul, ol &#123; list-style: none outside none;&#125; 再如 table，网页上的表格边框几乎全是合并处理的，而且单元格的内边距还得根据内容的多少来具体设置，所以也得先设置下，方便以后好用： 1234567table &#123; border-collapse: collapse; border-spacing: 0;&#125;td, th &#123; padding: 0;&#125; 除此之外，设置所有元素的 box-sizing 都为 border-box，提供一个全局的 clearfix 类等等。 12345678910* &#123; box-sizing: border-box;&#125;.clearfix::before, .clearfix::after &#123; content: \"\"; display: table;&#125;.clearfix::after &#123; clear: both;&#125; 可参考：归零重置Eric Meyer’s “Reset CSS” 2.0 结合两者，可参考：Sandal inline-block简单分析相信大家对这个属性并不陌生，根据名字inline-block我们就可以大概猜出它是结合了inline和block两者的特性于一身，简单的说：设置了inline-block属性的元素既拥有了block元素可以设置width和height的特性，又保持了inline元素不换行的特性。以前我们做横向菜单列表的时候，我们可以通过li和float:left两者来实现，现在可以通过li和display:inline-block。 inline-block的问题 默认情况下，inline元素之间有空隙出现，所以结合了inline和block属性的inline-block属性自然也有这个特点。那这些空隙是什么呢，它们是空白符！要去除空白符产生的间隙，首先要理解空白符归根结底是个字符，通过设置font-size属性可以控制产生的间隙的大小。 inline-block的应用 inline-block的特点是结合inline和block两种属性的特性，可以设置width和height，并且元素保持行内排列的特性。基于这一点，所有行内排列并且可以设置大小的场景都是我们可以考虑使用inline-block的应用场景。 网页头部菜单 网页头部的菜单就是典型的横向排列并且需要设置大小的应用，在inline-block之前，实现菜单基本都是用float属性来实现，float属性会造成高度塌陷，需要清除浮动等问题，使用inline-block实现就不需要在意这样的问题。 内联块元素 一切需要行内排列并且可设置大小的需求就可以用inline-block来实现。例如使用a标签做按钮时，需要设置按钮的大小，我们就可以使用inline-block来实现。 布局 inline-block也可以用于常见的布局，使用它就不需要去注意float属性布局带来的问题。 相比于使用float所带来的问题，使用inline-block所需要注意的点主要是空白符带来的问题，这一点也可以很方便的解决。 CSS动画CSS3制作动画的几个属性：变形(transform)、转换(transition)和动画(animation)。 transform主要包括以下几种：旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix。 参考：CSS3 Transform transition主要包含四个属性值： 执行变换的属性:transition-property 变换延续的时间:transition-duration 在延续时间段、变换的速率变化:transition-timing-function 变换延迟时间:transition-delay 参考：CSS3 Transition animation主要有以下几种： animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction animation-play-state 参考：CSS3 Animation 单行超过使用省略 white-space:nowrap overflow:hidden text-overflow:ellipsis","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ice-io.github.io/tags/CSS/"}]},{"title":"前端知识总结——HTML基础","slug":"前端知识总结——HTML基础","date":"2017-08-01T14:07:50.000Z","updated":"2017-09-10T08:55:01.941Z","comments":true,"path":"2017/08/01/前端知识总结——HTML基础/","link":"","permalink":"http://ice-io.github.io/2017/08/01/前端知识总结——HTML基础/","excerpt":"从之前的不懂，到现在可以用HTML5和canvas制作一个小游戏，收获是很多的。但是，学习是一个循序渐进的过程，学而时习之，不亦说乎嘛。","text":"从之前的不懂，到现在可以用HTML5和canvas制作一个小游戏，收获是很多的。但是，学习是一个循序渐进的过程，学而时习之，不亦说乎嘛。 HTML基础1234567891011&lt;DOCTYPE html&gt; &lt;!--文档声明，告诉浏览器应该使用哪种规范来解析--&gt;&lt;html&gt; &lt;!--根元素，所有的元素都是其子元素--&gt; &lt;head&gt; &lt;!--head元素，包含网页的基本信息和元数据--&gt; &lt;meta charset='utf-8'&gt; &lt;!--meta元素，存放元数据，由name和http-equiv两个属性--&gt; &lt;title&gt;我是网页标题&lt;/title&gt; &lt;!--title元素，表示网页标题--&gt; &lt;/head&gt; &lt;body&gt; &lt;!--body元素，存放页面内容--&gt; &lt;h1&gt;我是内容标题&lt;/h1&gt; &lt;p&gt;我是段落&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 深入了解head元素 head元素包含网页的常规信息和元数据。 其子元素主要为三类： 描述网页基本信息 —— meta元素 指向网页渲染所需要的文件链接 —— link元素和script元素 厂商自定 —— meta元素 meta元素神通广大 meta常用于定义页面的说明，关键字，最后修改日期，和其它的元数据。这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎和其它网络服务。meta元素共有两个属性，分别是http-equiv属性和name属性。 name属性 主要用于描述网页，比如网页的关键词，叙述等。与之对应的属性值为content，content中的内容是对name填入类型的具体描述，便于搜索引擎抓取。 meta标签中name属性语法格式是： &lt;meta name=&quot;参数&quot; content=&quot;具体的描述&quot;&gt; 取值包括：keywords(关键字)、description(网站内容的描述)、 viewport(移动端的窗口)、robots(定义搜索引擎爬虫的索引方式)、author(作者)、generator(网页制作软件)、copyright(版权)、revisit-after(搜索引擎爬虫重访时间)、renderer(双核浏览器渲染方式)。 http-equiv属性 相当于HTTP的作用，比如说定义些HTTP参数啥的。 meta标签中http-equiv属性语法格式是： &lt;meta http-equiv=&quot;参数&quot; content=&quot;具体的描述&quot;&gt; 取值包括： content-Type(设定网页字符集)(推荐使用HTML5的方式)、X-UA-Compatible(浏览器采取何种版本渲染当前页面)、cache-control(指定请求和响应遵循的缓存机制)、expires(网页到期时间)、refresh(自动刷新并指向某页面)、Set-Cookie(cookie设定)。 可参考 ：HTML meta标签总结与属性使用介绍 HTML注释 程序员圈子里面有个非常经典的笑话：“当我写下这段代码的时候，只有我和上帝能看懂。现在，只有上帝能了。”就如有些人看文章需要做笔记一样，写代码最好也需要做笔记，这个笔记就是注释。注释主要用来解释代码的功能或逻辑，可以辅助阅读代码，当然注释内容本身是不会在浏览器中显示的。大家务必养成注释的习惯，这样即利于你日后阅读，也利于团队小伙伴阅读，否则，你的代码真的只有上帝才能看懂。 HTML注释的语法为：&lt;!-- 注释写这里 --&gt; HTML属性 为了表示元素的一些特征，我们可以在开始标签中添加一些属性。 属性特性 一般属性都具有以下特征： 每个属性之间或与元素名之间都有一个空格隔开 属性名后面紧跟等号 属性值使用双引号包裹但也有一些属性只有属性名，没有属性值，这种属性我们称之为布尔属性。除此之外，我们还可以自定义属性来存储我们的一些数据以便JavaScript使用。可参考HTML data-* 属性 属性分类 属性有很多种，从使用来说大概可以分为三类： 可以用于每个元素的全局属性，如class属性 可用于某一类元素的，如form表单相关元素的name、value属性 只用于某一个元素的，如alt属性只用于img元素 属性参考 HTML 全局属性|W3school HTML 全局属性|MDN HTML 属性参考 常用基本元素 标题元素 &lt;h1&gt; &lt;h2&gt; &lt;h3&gt; &lt;h4&gt; &lt;h5&gt; &lt;h6&gt;标签用来定义标题，其大小依次减小。&lt;h1&gt;为最大的标题，&lt;h6&gt;为最小的标题。 段落元素 &lt;p&gt;标签定义段落，每一个&lt;p&gt;标签默认都另起一行。 图片元素 &lt;img&gt;标签用来在网页中嵌入图片，该标签没有结束标签。（如这种只有一个标签的元素都可以称之为“空元素（empty element）”。 &lt;img&gt;标签有两个必需的属性：src属性 和 alt属性。其中src属性为图片地址，alt属性为如果图片加载失败显示的替换文字。 链接元素 &lt;a&gt;标签定义超链接，用于网页之间的跳转（从一个网页到另一个网页），它有一个重要的属性href，用来指定链接的目标。如果需要新标签页打开，则要添加另一个属性target。 列表元素 列表分为无序列表及有序列表两种，其中无序列表标签为&lt;ul&gt;，有序列表标签为&lt;ol&gt;，其直接的子元素标签为&lt;li&gt;(不能是其他标签)。 div元素 &lt;div&gt;标签用来分割为独立的、不同的部分，每一个&lt;div&gt;标签默认都另起一行。 span元素 &lt;span&gt;标签被用来组合文档中的行内元素。 换行元素 &lt;br&gt;标签可插入一个简单的换行符，它是个空元素，没有结束标签，不包含任何内容。 HTML字符实体预留字符： 在 HTML 中，某些字符是预留的不能直接使用，如小于号（&lt;）和大于号（&gt;），直接使用会误认为它们是标签。所以如果我们希望正确地显示预留字符，那必须在 HTML 源代码中使用字符实体（character entities），如可以使用&amp;lt;表示小于号（&lt;），&amp;gt;表示大于号（&gt;）。 常用字符实体如下 显示结果 描述 实体名称 实体编号 空格 &amp;nbsp; &amp;#160; &lt; 小于号 &amp;lt; &amp;#60; &gt; 大于号 &amp;gt; &amp;#62; &amp; 和号 &amp;amp; &amp;#38; © 版权 &amp;copy; &amp;#169; × 乘号 &amp;times; &amp;#215; HTML表单表单元素本身是指&lt;form&gt;，不过它也有一个更广泛的概念，指构成表单的所有元素。首先就&lt;form&gt;元素本身来说，主要有两个属性： action：表示表单数据所提交到的处理地址（如果不知道处理地址，可先用#表示） method：表示提交内容的方式，默认取值为 get，可以设置为 post 下面正式介绍一些常用的表单元素 &lt;input&gt;元素 &lt;input&gt;元素跟&lt;img&gt;元素一样，不需要闭合标签。其常见属性如下： 12345678910111213type：必备属性，常见取值如下： text：文本输入框 password：密码输入框 search：搜索框 number：数字输入框 radio：单选按钮 checkbox：复选框 hidden：隐藏域（页面不可见，用来保存数据等） file： 上传文件 button：普通按钮 submit：提交按钮 reset：重置按钮placeholder：如为输入框时，可设置该属性，在输入框中灰色显示提示信息 &lt;textarea&gt;元素 用于多行文本输入，我们常用的评论输入框也是这个。 可以通过 cols 和 rows 属性来规定 textarea 的尺寸，不过等我们学了 CSS 之后，更好的办法是使用 CSS 的 height 和 width 属性来控制其尺寸。 &lt;select&gt;元素 用于创建选项菜单，默认只能选择一个值，可通过设置属性multiple=&quot;multiple&quot;来实现多选（很少很少使用多选）。其选项为&lt;option&gt;元素，常用有两个属性：`value`：表示选中该选项的值。 `selected`：表示默认选中。 &lt;button&gt;元素 &lt;button&gt;元素用来定义按钮，跟 input 定义的按钮不同，这个是有闭合标签的。同样也可以通过设置 type 属性来实现提交按钮和重置按钮，不过不建议这么做。一般对于提交与重置按钮，我们建议使用 input 来定义，对于普通按钮可以使用 button。 &lt;label&gt;元素 &lt;label&gt;元素用于关联表单元素的标题，可直接包裹表单元素，也可以通过设置其 for 属性关联到表单元素的 id 属性，这样点击 label 标题上关联的表单元素就 可以自动获取焦点，提升用户体验。示例如下： 1234&lt;!-- 包裹表单元素 --&gt;&lt;label&gt;用户名：&lt;input type=\"text\"&gt;&lt;/label&gt;&lt;!-- 使用for属性关联表单元素的id属性 --&gt;&lt;label for=\"username\"&gt;用户名：&lt;/label&gt;&lt;input type=\"text\" id=\"username\"&gt; 可参考：HTML Form浅析之表单属性","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://ice-io.github.io/tags/HTML/"}]}]}