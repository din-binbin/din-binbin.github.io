{"meta":{"title":"Thinking Coding","subtitle":null,"description":null,"author":"ice","url":"http://ice-io.github.io"},"pages":[{"title":"about","date":"2017-08-25T11:54:41.000Z","updated":"2017-08-25T11:57:04.322Z","comments":true,"path":"about/index.html","permalink":"http://ice-io.github.io/about/index.html","excerpt":"","text":"About Me"},{"title":"分类","date":"2017-08-25T13:26:44.000Z","updated":"2017-08-25T13:27:15.951Z","comments":true,"path":"categories/index.html","permalink":"http://ice-io.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-08-25T13:24:35.000Z","updated":"2017-08-25T13:25:42.461Z","comments":true,"path":"tags/index.html","permalink":"http://ice-io.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端知识总结——CSS","slug":"前端知识总结——CSS基础篇","date":"2017-08-26T14:35:46.000Z","updated":"2017-08-31T07:09:29.202Z","comments":true,"path":"2017/08/26/前端知识总结——CSS基础篇/","link":"","permalink":"http://ice-io.github.io/2017/08/26/前端知识总结——CSS基础篇/","excerpt":"这一篇文章将回顾之前所学的CSS基础知识。","text":"这一篇文章将回顾之前所学的CSS基础知识。 认识CSS CSS，即Cascading Style Sheet，层叠样式表，用来修饰网页。 CSS语法h1{color:red;font-size:20px}包含选择器、属性、属性值，当然最好写成下面的样子方便阅读和维护： 1234h1 &#123; color: red; font-size: 20px;&#125; CSS注释 单行注释：/* 注释内容 */ 多行注释： 1234/* 注释 内容*/ 引入CSS 行内样式（通过标签的style属性）——[缺点：样式结构混在一起；冗余；] 内联样式（通过style标签写入CSS）——[缺点：冗余；] 行内样式（通过link标签引入CSS文件）——[解决了前两种方式的缺点] 但是，这三种方式，各有其应用场景。另外要注意@import引入方式的缺点： 范畴不同：link标签引入属于HTML，@import则属于CSS。 兼容性：@import不兼容旧版浏览器。 加载顺序：@import需要等到文档最后才加载。 脚本操作：@import不支持JavaScript的修改操作。 CSS中的选择器总共分为5大类： 基础选择器、关系选择器、伪类选择器、属性选择器、伪元素选择器。使用时注意选择器分组→→→将相同样式分组定义共用，简化代码。可参考：CSS选择器参考手册 基础选择器 通用选择器(*) 元素选择器(p) 类选择器(.class) id选择器(#id) 关系选择器 子代选择器(div&gt;p) 后代选择器(div p) 兄弟选择器(div~p 、div+p) 伪类选择器 :link :visited :hover :active :first-child :last-child :nth-child(n) :nth-lastchild(n) 伪元素选择器 ::before ::after ::first-letter ::first-line 属性选择器 选择器 描述 [attribute] 用于选取带有指定属性的元素 [attribute=value] 用于选取带有指定属性和值的元素 [attribute\\^=value] 匹配属性值以指定值开头的每个元素 [attribute$=value] 匹配属性值以指定值结尾的每个元素 [attribute*=value] 匹配属性值中包含指定值的每个元素 [attribute~=value] 用于选取属性值中包含指定词汇的元素 [attribute&#124;=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词 选择器的优化 现在我们知道了选择器有很多种，但是对于浏览器来说，解析每种选择器所耗费的时间并不是一样的。所以当我们使用选择器的时候也有必要了解如何才能写出最优选择器。 各种 CSS 选择器的效率由高至低排序如下： id选择器（#myid） 类选择器（.myclassname） 标签选择器（div,h1,p） 相邻选择器（h1 + p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（*） 属性选择器（a[rel=&quot;external&quot;]） 伪类选择器（a:hover,li:nth-child） 选择器的解读顺序是怎样的？ 一般来说，在具体的项目中，HTML 结构都比较复杂，所以关系选择器使用非常的普遍。对于关系选择器来说，我们的阅读习惯是从左到右，但是浏览器解读选择器，遵循的原则是从选择器的右边到左边读取。 如对于选择器.list .item .item-tt，浏览器先找的是.item-tt，然后继续向父级元素寻找.item，再找.list，这样才完成了最终的选择器匹配。所以如果路径链越短，效率也就相应有所提高。这里建议选择器的层级最多不要超过4层，如.demo .list .item .item-tt .tt-link就有5层了，可根据实际情况考虑缩短为4层以内，如.demo .item-tt .tt-link。 如何提高CSS选择器性能呢？ CSS选择器对性能的影响源于浏览器匹配选择器和文档元素时所消耗的时间，所以优化选择器的原则是应尽量避免使用消耗更多匹配时间的选择器。 可以通过以下几点来优化： 避免使用通用选择器 避免使用标签或 class 选择器来限制 id 选择器 避免使用标签限制 class 选择器 避免使用多层标签选择器。使用 class 选择器替换，减少css查找 避免使用子选择器 使用继承 CSS中的属性和值字体相关属性 font-family：定义文本的字体，如：font-family: arial; font-size：字体尺寸，如：font-size: 18px; font-style ：字体样式，如：font-style: italic; font-weight：字体的粗细，如：font-weight: bold; 文本相关属性 color：定义文字颜色，如：color: red; line-height：设置行高，如：line-height: 1.5; text-align：文本的水平对齐方式，如：text-aligin: center; text-decoration：文本的装饰效果，如：text-decoration: underline; text-indent：首行的缩进，如：text-indent: 2em; text-shadow：文本的阴影效果，如：text-shadow: 0 0 5px #ff0000; 列表属性 list-style：在一个声明中设置所有的列表属性 list-style-image：将图象设置为列表项标记 list-style-position：设置列表项标记的放置位置 list-style-type：设置列表项标记的类型 表格属性 border-collapse：是否合并表格边框 border-spacing：相邻单元格边框之间的距离 table-layout：设置表格的布局算法 盒子大小 width min-width max-width height min-height max-height box-sizing 盒子边框 border：简写模式，四边边框 border-width：边框宽度 border-style：边框样式，常用的为solid和dashed border-color：边框颜色 border-top：上边框 border-right：右边框 border-bottom：下边框 border-left：左边框 盒子内外边距 margin margin-top margin-right margin-bottom margin-left padding padding-top padding-right padding-bottom padding-left 盒子背景 background：总的简写形式，包括了下面各个单条属性 background-color：背景色 background-image：背景图片 background-position：背景图片起始位置 background-repeat：背景图片平铺方式 background-size：背景图片大小 background-clip：背景图片绘制区域 background-origin：背景图片的定位区域 盒子其他 overflow：指定当内容溢出其块级容器时,是否剪辑内容，渲染滚动条或显示内容 visibility：是否可见 border-radius：圆角 box-shadow：阴影 空间位置相关 display float clear position top right bottom left transform z-index opacity 动画相关 transition animation 可参考:CSS 参考 | MDN 、CSS 参考手册 | W3school 自定义字体 一般来说，网页上的字体使用的都是我们电脑里面的字体，比如我们常说的微软雅黑、宋体就是 windows 系统自带的字体。所以你可以看到网页的字体一般都比较中规中矩，不像平面设计那样各种新花样。但是我们在浏览一些网站时，还是可以发现一些非常酷炫和高端的字体。 那么如何实现自定义字体的效果呢？答案是 CSS 的 @font-face 。 @font-face 的语法规则如下： 123456@font-face &#123; font-family: &lt;fontFamily&gt;; /* 自定义的字体名称; */ src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*; /* 自定义的字体的存放路径、格式; */ [font-weight: &lt;weight&gt;]; /* 是否为粗体 */ [font-style: &lt;style&gt;]; /* 定义字体样式，如斜体 */&#125; 其取值说明如下： fontFamily：此值指的就是你自定义的字体名称，如font-family: myFirstFont。 source：此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝对路径。 format：此值表达自定义的字体的格式，用于帮助浏览器识别字体类型。 weight和style：这两个值大家一定很熟悉，weight 定义字体是否为粗体，style 主要定义字体样式，如斜体。 推荐：dafont字体 字体格式 TrueType (.ttf) Windows 和 Mac 系统最常用的字体格式，其最大的特点就是它是由一种数学模式来进行定义的基于轮廓技术的字体，这使得它们比基于矢量的字体更容易处理，保证了屏幕与打印输出的一致性。同时，这类字体和矢量字体一样可以随意缩放、旋转而不必担心会出现锯齿。 OpenType (.otf) OpenType 是一种可缩放字型（scalable font）电脑字体类型，采用 PostScript 格式，是美国微软公司与Adobe 公司联合开发，用来替代 TrueType 字型的新字型。这类字体的文件扩展名为.otf，类型代码是 OTTO。 Embedded Open Type (.eot) 嵌入字体格式（EOT）是微软开发的一种技术，允许 OpenType 字体嵌入到网页并可以下载至浏览器渲染。这些文件只在当前页活动的状态下，临时安装在用户的系统中。 Web Open Font Format (.woff) 相对于 TrueType 和 OpenType ，WOFF（Web开发字体格式）是一种专门为了 Web 而设计的字体格式标准，它并不复杂，实际上只是对于 TrueType / OpenType 等字体格式的封装，并针对网络使用加以优化：每个字体文件中含有字体以及针对字体的元数据（ Metadata ），字体文件被压缩，以便于网络传输，并且不包含任何加密或者 DRM 措施。 Scalable Vector Graphics Fonts (.svg) 顾名思义，就是使用SVG技术来呈现字体，还有一种 gzip 压缩格式的 SVG 字体 .svgz。 这么多字体带来的问题是浏览器的支持：目前现代浏览器基本都支持 .ttf、 .otf、 .woff 的字体格式。但需要注意的是 IE8以下仅支持 .eot 格式，而 .svg 目前只有 safari 支持。 自定义图标字体（iconfont） 我们经常会在网页中使用这些图标，以前主要是通过背景图去做的，每次换个颜色或改个大小就得重新切个图，所以维护使用比较繁琐。这样图标字体就应时而生，它提供了一种解决方案：把一些简单的图标制作成字体，然后让图标变成和文字一样可以通过 CSS 去改变颜色大小等。 对于使用图片的图标来说，iconfont 图标有许多优点： 灵活性：改变图标的颜色，背景色，大小都非常简单 兼容性：基本没有兼容性问题，在IE6，Android2.3都能够兼容 扩展性：替换图标很方便，新增图标也非常简单 高效性：iconfont有矢量特性，不会失真 轻便性：在使用上字体文件和普通的静态资源一样，既可以外链也可以内链，并且字体文件也可以使用gzip压缩推荐：Fontello CSS中的单位 pxpx 是 pixels（像素）的缩写，是一种绝对单位，用于屏幕显示器上，传统上一个像素对应于计算机屏幕上的一个点，而对于高清屏则对应更多。任何现代显示屏，不管是手机，平板，笔记本还是电视都是由成千上万的像素组成的，所以我们可以使用这些像素来定义长度。 %%（百分比）应该是我们最好理解的单位了，即相对于父元素。 如果对 html 元素设置 font-size 为百分比值，则是以浏览器默认的字体大小16px为参照计算的（所有浏览器的默认字体大小都为 16px），如62.5%即等于10px（62.5% * 16px = 10px）。 emem 也是一种相对单位，既然是相对单位，那么肯定有一个参照值。不过其参照值并不是固定不变的，而是不同的属性有不同的参照值。 对于字体大小属性（font-size）来说，em 的计算方式是相对于父元素的字体大小，1em 等于父元素设置的字体大小。如果父元素没有设置字体大小，则继续往父级元素查找，直到有设置大小的，如果都没有设置大小，则使用浏览器默认的字体大小。 在(border, width, height, padding, margin, line-height)这些属性中，使用em单位的计算方式是参照该元素的 font-size，1em 等于该元素设置的字体大小。同理如果该元素没有设置，则一直向父级元素查找，直到找到，如果都没有设置大小，则使用浏览器默认的字体大小。 rem和 em 一样，rem 也是一种相对单位，不过不一样的是 rem 是相对于根元素 html 的 font-size 来计算的，所以其参照物是固定的。（rem的r就是表示root，虽然rem相对em进步了很多，但是由于是新技术，不支持IE8以下（包括IE8）,不过幸喜的是移动端可以放心使用） 由于 rem 是基于跟元素 html 的 font-size 来计算的，所以如果改变 html 的 font-size 值，那么所有使用的 rem 单位的大小都会随着改变，这对于移动端适应各种屏幕大小来说还是有点作用的。 vw, vh, vmin, vmax这四个单位属于 v 系单位，它们也是相对单位，是基于视窗大小（浏览器用来显示内容的区域大小）来计算的。 网页中我们很多时候都需要用到满屏，或者屏幕大小的一半等，尤其是移动端，屏幕大小各式各样，而这个时候我们现有的单位就显得有点捉襟见肘，于是就诞生了这四个单位。 vw：基于视窗的宽度计算，1vw 等于视窗宽度的百分之一 vh：基于视窗的高度计算，1vh 等于视窗高度的百分之一 vmin：基于vw和vh中的最小值来计算，1vmin 等于最小值的百分之一 vmax：基于vw和vh中的最大值来计算，1vmax 等于最大值的百分之一 单位运算除了设置以上的单位之外，我们还可以使用 calc 来进行单位运算，单位运算时可以使用各种单位进行加减乘除运算。简单示例如下： 12345.box &#123; height: calc(50vh - 20px); /* 50% 的视窗高度减掉20px */ width: calc(100% / 3); /* 三分之一的父容器宽度 */ background: red;&#125; CSS中的颜色 颜色关键词如 red，green，gray 等，除此之外，还有两个关键词可用，分别是 transparent 和 currentColor。 RGB表示使用红-绿-蓝模式来定义颜色。 十六进制十六进制颜色表现形式为： #RRGGBB 和 #RGB RGBa在 rgb 的基础上，还可以添加一个 alpha 透明度表示半透明值，这样就构成了我 rgba，其函数表示为：rgb(red, green, blue, alpha)，其中 alpha 参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。 hsl除了使用红-绿-蓝的模式定义颜色之外，还可以通过 hue（色调）、saturation（饱和度）、lightness（亮度）模式定义颜色，其语法为：hsl(hue, saturation, lightness) 。 CSS中的盒模型HTML文档中的每个元素在渲染的时候都会被描绘成一个矩形盒子，而盒模型正是用来表示每个元素盒子所占用空间大小的模型。 在我们现实生活中，描述一个矩形直接用宽和高即可。但是在CSS中主要通过四个部分来描述，分别为：margin（外边距），border（边框），padding（内边距），content（内容区域）。如下图： 盒模型计算方式 一般来说，默认的盒模型实际占用空间计算模式为： 水平空间大小 = margin(左右) + border(左右) + padding(左右) + width 垂直空间大小 = margin(上下) +border(上下) + padding(上下) + height 因为外边距(margin)为元素之间的距离，所以如果扣除它，则一个元素的实际大小就是 border + padding + width/height 。 这种计算模式在对于非 px 为单位的宽高设置时，会带来非常大的计算困扰。如下： 1234.box &#123;width: 50%;border: 1px solid #ccc;&#125; 我们想要的肯定是50%，但是实际的大小却是 50% + 2px ，这多出的 2px 就很让人无奈了，于是为了不破坏这 50% 的宽度，往往得再内嵌一层元素用来设置 border ，就成了下面这样： 123456.box &#123;width: 50%;&#125;.box .box-inner &#123;border: 1px solid #ccc;&#125; 这种解决方式显然不太科学，至少导致了 HTML 结构的臃肿，而 box-sizing 属性的出现就解决了这个问题，它就是用来改变元素宽高的计算方式。 box-sizing 属性有两个常用的取值 content-box 和 border-box 。 如为 content-box （这也是默认值）则实际宽度为上面所说的计算方式：实际宽高 = border + padding + width/height 。 如为 border-box 则是另一种计算方式，其实际宽高就是设置的 width/height 。 了解盒模型的计算方式是非常重要的，现在的网页，尤其是移动端的页面，需要适应于不同的屏幕大小，所以一般都会提前设置所有元素的盒模型都为 border-box 模式，以方便以后宽高的计算。代码设置如下： 123* &#123; box-sizing: border-box;&#125; 盒模型相关属性 上面已经说了 box-sizing 属性可以控制元素宽高的计算方式，除此之外，盒模型还有下面几个相关属性需要掌握： width(包括min-width, max-width)：宽 height(包括min-height, max-height)：高 padding：内边距 border：边框 margin：外边距上面五大属性，除了 width 和 height 以外，padding、border 和margin 属性都是由四边组成的，每边都可以设置自己的单独值，还可以简写。 我们先说下盒模型的四边，方向分别为上、下、左、右，而 CSS 中表示就分别是 top、bottom、left、right，如下图表示： 首先，我们可以单独给每个方向设置各自的margin，分别对应我们下面四个属性： margin-top：top 方向单个值 margin-right：right 方向单个值 margin-bottom：bottom 方向单个值 margin-left：left 方向单个值 很显然，如果四个方向都有值的话，上面四个每个都要写一次是一件多么费力的事，于是我们又有了一条总的属性 margin margin：a b c d; 表示四个方向的值 margin: 10px; 表示四个方向的值都是10px 123456789101112/* 简写之前 */.box &#123;margin-top: 10px;margin-right: 20px;margin-bottom: 30px;margin-left: 40px;&#125;/* 简写之后 */.box &#123;margin: 10px 20px 30px 40px; /* 注意顺序以top开始，顺时针方向 */&#125; 这种取值模式其实并不是 margin 所独有的，同样 padding 也是按照这个模式来的。而且是一模一样的，而 border 相对来说还要更复杂点，border的简写，其简写模式为：border: 1px solid #ccc;。 border 的简写其实是由 border-width，border-style，border-color 三个属性组合而成的。1px 就是 border-width，solid 就是 border-style，#ccc 就是 border-color。 而这三个属性，它们如果单独来写，其取值模式就和margin是一样的了，都可以设置1-4个值，如： 12345.box &#123;border-color: #f00 #ccc #ccc; /* top left和right bottom */border-width: 2px 1px; /* top和bottom left和right*/border-style: solid; /* all */&#125; 除此之外，border当然也有表示方向的属性，如border-left: 1px solid #f00;，则表示左边框为1px红色的实线。同样还有border-top，border-right，border-bottom。而方向又可以和边框属性结合，如border-top-width，border-top-style，border-top-color。 所以，如果我们要设置不一样的边框，一般可以先设置个默认一样的，然后再通过单边的，或者通过border-width，border-style，border-color去特殊设置 。 CSS中元素的显示与隐藏 display属性 所有的后代元素都隐藏 元素隐藏后不再占用空间 visibility属性 元素所占的空间位置不变，可理解为元素透明了 如子元素设为visibility:visible，则该子元素依然可见 overflow属性 规定了当内容元素溢出父容器时的展现形式 裁剪内容，使用滚动条来显示或直接显示超出部分 CSS中的背景简写(推荐)： background 分步写： background-color background-image background-repeat background-position background-size CSS中的图片图片作为网页必不可少的一部分，在网页中占据着非常重要地位。一般来说，有以下两种方式来使用图片： 通过 img 元素直接使用 通过 background-image（背景图片）的形式使用 这两种形式的区别在于，前者一般具有实际含义（如产品图片，相册图片等），而后者一般用于装饰效果。 目前网页中常用的图片大概有如下几种格式，它们有着各自的显著特点，被应用在各种不同的场景： jpg/jpeg：由于其色彩还原度比较好，所以一般色彩丰富的图片均采用该格式，如宣传图、产品图、相册图等等。 png：由于其对透明度的良好支持，所以一般用于透明图片，如 logo 图、图标图等。 gif：由于其对动画的支持，所以一般用来实现动效图片，如 loading 加载动画、一些搞笑图片等。 ico 格式属于图标文件，主要用于网址前面的标识图标。 webp 格式是由 google 研发的图片格式，它既具备高压缩率，又具备透明度以及动画的特性。目前各个大互联网公司都有在使用该格式，其带来的效果也非常显著。但是该格式有个明显的缺陷：目前浏览器端只有 google 浏览器支持。 WebP 的优势 PNG 转 WebP 的压缩率要高于 PNG 原图压缩率，同样支持有损与无损压缩 转换后的 WebP 体积大幅减少，图片质量也得到保障（同时肉眼几乎无法看出差异） 转换后的 WebP 支持 Alpha 透明和 24-bit 颜色数，不存在 PNG8 色彩不够丰富和在浏览器中可能会出现毛边的问题 WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。 关于网页媒体文件可参考：网络媒体教程 | W3school 关于WebP可参考：WebP 探寻之路 、WebP 相对于 PNG、JPG 有什么优势？ 图片优化通过HTTP Archieve统计显示，图片内容已经占到了互联网内容总量的65%左右。如此多的图片，当然占用了很多流量及时间，所以从性能优化的角度看，图片绝对是优化的热点和重点之一。可参考：前端图片优化机制 雪碧图在网站开发中，我们经常会使用一些背景图片来点缀效果，如一些形象生动的小图标。这种背景图片一多，网络请求就多了。这样为了减少网络请求，我们把一些小的背景图合并在一个大的图中，然后通过 CSS 的背景定位技术去使用。我们把这种技术叫做 CSS Sprite，也叫雪碧图，还叫 CSS 精灵。 雪碧图的应用原理通过上面讲述，我们知道雪碧图是一张大的合并图，每个小图标其实只是截取大图的一部分来显示。如下图所示，我们有一张带有各种表情图标的雪碧图，其中每个表情图标都占领着相应的位置。 假如我们需要显示开心表情的这一个图标，我们需要计算开心图标在合并图中相应的位置和其图标的大小。以雪碧图的左上角为坐标中心，我们得出开心表情刚好在坐标的原点，即 X 轴0像素，Y 轴0像素的位置，且我们可以得出图标的宽高均为96像素。 因此我们设置这个图标元素的背景图片为这张雪碧图，背景位置为图标在雪碧图中的坐标，这样开心的图标就显示出来了。 12345678.happy &#123; display:inline-block; width: 96px; height: 96px; background-image: url(sprite.png); /* 设置背景图片 */ background-repeat: no-repeat; /* 设置为不平铺 */ background-position: 0 0; /* 设置图标位置 */&#125; 假如我们还要使用到哭泣的表情。同理所得，计算出哭泣的图标的位置在雪碧图的 X 轴向右192像素， Y 轴向下96像素。 12345678.cry &#123; display:inline-block; width: 96px; height: 96px; background-image: url(sprite.png); /* 设置背景图片 */ background-repeat: no-repeat; /* 设置为不平铺 */ background-position: -192px -96px; /* 设置图标位置 */&#125; 关于坐标的问题，可以这么理解：我们定义了一个视口，固定在大图的左上角，也就是（0，0），当我们想看到哪张小图的时候，就挪动大图使其移动到视口处。 雪碧图的制作制作雪碧图的方式有许多，大概有如下几种方法： 使用 photoshop 等图片编辑工具 在线工具 目前有许多在线合成雪碧图的站点，只需要将图片上传上去，便可以根据设置，生成想要的雪碧图以及对应的 CSS 样式文件，如 spritegen、css sprites generator。 甚至我们合好的图片，也可以通过 spritecow 来帮我们完成对应的 CSS 定位。 构建工具 除了上面两种，我们还可以通过如webpack, fis3, gulp等构建工具来完成雪碧图生成工作。可参考：webpack 自动雪碧图生成 、fis3 CssSprite图片合并 。 雪碧图与字体图标优劣 雪碧图的优势： 图标更美观 由于 iconfont 的图标只能设置单色，而雪碧图的图标由于是图片，所以能展现出更为美观的图标效果。 制作成本更低 iconfont 的制作较为麻烦，需要设计师按照规范，一一制作图标的 svg 文件。而雪碧图的制作只需合并图片即可，在制作成本上更低。 雪碧图的劣势： 高清屏下会失真（第三章会介绍） 在 2x 的设备像素比的屏幕上，如果要达到和文字一样的清晰度，图片的宽度需要实际显示大小的两倍，否则看起来会比较模糊。 雪碧图不方便变化 雪碧图本质上是一张静态的图片，因此无法灵活地通过样式去动态改变图片图标的颜色和其他效果。 CSS中的渐变背景在定义背景图片时，除了使用正常的图片之外，我们还可以通过 CSS3 的 gradient 去创造渐变背景图。同比使用图像的方案，使用 CSS3 gradient 来实现可以减少带宽和页面加载时间。 目前浏览器可以支持两种类型的渐变： 线性渐变 (linear)，通过 linear-gradient 函数定义 径向渐变 (radial)，通过 radial-gradient 函数定义 线性渐变 (linear-gradient) 线性渐变，即沿着一个方向线性的进行着颜色之间的平滑过渡的一个渐变过程。 为了创建一个线性渐变，你必须至少定义两种颜色，同时你也可以设置一个方向或一个角度。其标准语法如下： background: linear-gradient([ &lt;angle&gt; | to &lt;side-or-corner&gt;], color-stop, ..., color-stop); angle：表示线性渐变的角度，该角度是指水平线和渐变线之间的角度，以顺时针方向计算。换句话说，0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。 side-or-corner：表示方向关键词（top、right、bottom、left、left top、top right、bottom right 或 left bottom）。这个参数值可以省略，当省略不写的时候其取值为“to bottom”。 color-stop：表示渐变的色标，每个色标包含一种颜色和一个位置，位置可以被指定为线长度的百分比或一个绝对长度。为实现期望的效果，可以指定任意多个色标。 径向渐变 (radial-gradient)不同于线性渐变，径向渐变是一种由指定渐变的中心按照设定的大小，向外成圆型或椭圆形扩散的渐变。其标准语法如下： background: radial-gradient(position, shape size, color-stop, ..., color-stop); position：指定渐变中心的位置，可用百分比指定径向渐变圆心的坐标值，或者用长度值指定径向渐变圆心的坐标值，也可以设置left, right, top, bottom, center等位置值 shape：定义渐变的形状，取值如下： circle 指定圆形的径向渐变 ellipse 指定椭圆形的径向渐变，默认值 size：定义了渐变的大小，取值如下： closest-side：指定径向渐变的半径长度为从圆心到离圆心最近的边 closest-corner：指定径向渐变的半径长度为从圆心到离圆心最近的角 farthest-side：指定径向渐变的半径长度为从圆心到离圆心最远的边 farthest-corner：指定径向渐变的半径长度为从圆心到离圆心最远的角 color-stop：跟线性渐变的色标一样。 默认情况下，渐变中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。 可参考：使用CSS渐变 | MDN CSS简写 CSS 规范定义简写属性的目的在于将那些关于同一主题的常见属性的定义集中在一起。如我们已经说过的margin、padding、border等。 字体相关属性 font 相关属性用于设置字体，主要由以下几个属性组成： font-family：字体家族 font-size：字体大小 line-height：行高 font-weight：字体粗细 font-style：字体样式 font-variant：变体 其简写语法为： font: size/line-height weight style variant family; 圆角属性border-radius 的取值其实和 margin 也差不多，不过它描述的是角，顺序如下（top-left，top-right，bottom-right，bottom-left） 。 可参考：border-radius | MDN 背景相关属性简写1234567891011/* 简写前 */.bg &#123; background-color: #fff; background-image: url(images/bg.png); background-repeat: no-repeat; background-position: bottom right;&#125;/* 简写后 */.bg &#123; background: #fff url(images/bg.png) no-repeat bottom right;&#125; 但是 CSS3 时代又加入了 background-size、background-origin、background-clip 及多个值，整体上比之前复杂了很多，但是没关系，这些新加的属性你可以单独写（先建议单独写，因为可能这些新的属性还有些浏览器兼容问题）。 1234.bg &#123; background: #fff url(images/bg.png) no-repeat bottom right; background-size: cover;&#125; 动画相关属性transition用于过渡动画，跟background差不多，transition属性也是由几个属性组成，如下： transition-property：应用过渡效果的CSS属性名称 transition-duration：过渡效果花费的时间 transition-timing-function：过渡效果的时间曲线 transition-delay：过渡效果何时开始 其简写语法为：transition: property duration timing-function delay; animation用于帧动画，在属性组成上，只是比transition多了几个而已。 animation-name：@keyframes 动画的名称 animation-duration：动画完成一个周期所花费的秒或毫秒 animation-timing-function：动画的速度曲线 animation-delay：动画何时开始 animation-iteration-count：动画被播放的次数 animation-direction：动画是否在下一周期逆向地播放 animation-play-state：动画是否正在运行或暂停 animation-fill-mode：动画时间之外的状态 其简写语法为：animation: name duration timing-function delay iteration-count direction play-state fill-mode; 值简写 除了属性可以通过组合的形式进行简写，一些满足条件的值也可以进行适当的“偷工减料”。 一般来说以0+单位出现的值，都可以直接用0，省略单位，如0px可直接写成0（但0deg不允许去掉 deg ） 同样一般小于1的小数的都可以省略前面的0，如0.3s可以直接写.3s 颜色值如果采用十六进制，表示红绿蓝的每两位都一样的话，可以省略一位。如#336699，则可省略为#369 样式计算样式包括浏览器默认样式、继承的样式、声明的样式，最后表现出的样式是按照这三种样式的叠加规则来展示的。优先级由高到低为：声明样式——浏览器默认样式——继承样式。这也是层叠样式表（CSS）这个名字的由来。 样式优先级 style &gt; id选择器 &gt; 类选择器（属性、伪类） &gt; 元素选择器（伪元素） &gt; 通用选择器 在关系选择器中，比较优先级应该先从优先级最高的选择器开始比较。 !important表示最高级别。 得到的结论大概如下： !important &gt; style &gt; id选择器 &gt; 类选择器(伪类，属性) &gt; 元素选择器（伪元素） &gt; * &gt; 浏览器默认 &gt; 继承 可参考：优先级 | MDN 常见继承的属性 文本相关属性都可以继承 1color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、letter-spacing、word-spacing、white-space、word-break、overflow-wrap、line-height、direction、text-indent、text-align、text-shadow 列表相关属性 1list-style-image、list-style-position、list-style-type、list-style 表格相关属性 1border-collapse、border-spacing visibility 和 cursor 常见非继承属性 盒模型相关属性 1margin、border、padding、height、min-height、max-height、width、min-width、max-width、box-sizing 布局类属性 1display、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align 系列类 1background 系列、transform 系列、transtion 系列、animation 系列、flexbox 系列、grid 系列 浏览器兼容 首先浏览器有很多种，每种浏览器会存在一定的差异，其次每个浏览器都有不同的版本，版本之间也存在必然的差异，而我们做出来的页面则需要各个浏览器以及不同版本表现一致，所以必然存在兼容问题。 一般来说兼容问题我们可以分两步走：第一步是确定浏览器是否支持，第二步是如果表现不一致，怎么去修复。 浏览器是否支持 一般来说，由于技术的不断改进和发展，大概存在以下几种问题： 新技术在老版本的浏览器总是不支持的（如ie8以下对 CSS3 支持几乎是空白） 由于新技术刚出现时，可能还没有完全定稿标准化，所以各个新浏览器一般都是先试探性的使用前缀的办法使用 同样的技术在不同的浏览器上可能表现也不一样。 对于这些问题，我们可以查阅 Can I use ，里面提供了各种浏览器支持情况。 在查阅 Can I use 的时候，我们可以看到有些版本的右上角标有-符号，这就标识该版本得使用前缀，目前我们常见的前缀有-webkit（webkit内核浏览器）、-ms（ie/edge）、-moz（火狐浏览器） 如何针对修复 如果问题出现了，我们怎么针对某些浏览器进行特定的修复而不影响到其他正常的浏览器。 这个时候就可以参考浏览器hack详细，里面提供了针对各种浏览器单独写样式的很多方法（不一定所有办法都可以，但是你可以挑选一个可以的） CSS重置现在我们已经知道了，某些元素即使我们不对它声明样式，浏览器也会有些默认的样式，如 h1、p。 那么问题来了，浏览器有那么多（Chrome，Firefox，IE 等），每个浏览器的默认样式是否一致呢？ 很可惜，这个答案是否定的。 纠正重置 由于各个浏览器的默认样式有些差异，所以我们开始 CSS 的第一步应该是要消除这些差异，让表现一致。毕竟我们的最终目标就是得给用户看到一致的页面，不论用户使用什么浏览器。 这方面我们有开源的 normalize.css，它就是为了消除各个浏览器默认样式之间的差异而生的。 清零重置 虽然我们通过 normalize.css 消除了各浏览器默认样式的差异，但是我们日常开发中也有些不需要浏览器的默认样式的（毕竟默认的样式还是比较粗糙的），这样就构成了我们第二次的重置——清零重置。 如一些元素的 margin ，我们实际排版的时候都是跟着设计稿效果图走的，这种默认外边距反而有点碍事，所以先清为零：12345678910h1, h2, h3, h4, h5, h6, p, figure, form, blockquote &#123; margin: 0;&#125;ul, ol, li, dl, dd &#123; margin: 0; padding: 0;&#125;ul, ol &#123; list-style: none outside none;&#125; 又如列表类元素，实际使用中，我们几乎不需要前面的那个 list-style-type（圆点或数字等）所以也得清除掉：1234567ul, ol, li, dl, dd &#123; margin: 0; padding: 0;&#125;ul, ol &#123; list-style: none outside none;&#125; 再如 table，网页上的表格边框几乎全是合并处理的，而且单元格的内边距还得根据内容的多少来具体设置，所以也得先设置下，方便以后好用：1234567table &#123; border-collapse: collapse; border-spacing: 0;&#125;td, th &#123; padding: 0;&#125; 除此之外，设置所有元素的 box-sizing 都为 border-box，提供一个全局的 clearfix 类等等。12345678910* &#123; box-sizing: border-box;&#125;.clearfix::before, .clearfix::after &#123; content: \"\"; display: table;&#125;.clearfix::after &#123; clear: both;&#125; 可参考：归零重置Eric Meyer’s “Reset CSS” 2.0 结合两者，可参考：Sandal inline-block简单分析相信大家对这个属性并不陌生，根据名字inline-block我们就可以大概猜出它是结合了inline和block两者的特性于一身，简单的说：设置了inline-block属性的元素既拥有了block元素可以设置width和height的特性，又保持了inline元素不换行的特性。 以前我们做横向菜单列表的时候，我们可以通过li和float:left两者来实现，现在可以通过li和display:inline-block。 inline-block的问题 默认情况下，inline元素之间有空隙出现，所以结合了inline和block属性的inline-block属性自然也有这个特点。那这些空隙是什么呢，它们是空白符！ 要去除空白符产生的间隙，首先要理解空白符归根结底是个字符，通过设置font-size属性可以控制产生的间隙的大小。 inline-block的应用 inline-block的特点是结合inline和block两种属性的特性，可以设置width和height，并且元素保持行内排列的特性。基于这一点，所有行内排列并且可以设置大小的场景都是我们可以考虑使用inline-block的应用场景。 网页头部菜单 网页头部的菜单就是典型的横向排列并且需要设置大小的应用，在inline-block之前，实现菜单基本都是用float属性来实现，float属性会造成高度塌陷，需要清除浮动等问题，使用inline-block实现就不需要在意这样的问题。 内联块元素 一切需要行内排列并且可设置大小的需求就可以用inline-block来实现。例如使用a标签做按钮时，需要设置按钮的大小，我们就可以使用inline-block来实现。 布局 inline-block也可以用于常见的布局，使用它就不需要去注意float属性布局带来的问题。 相比于使用float所带来的问题，使用inline-block所需要注意的点主要是空白符带来的问题，这一点也可以很方便的解决。 CSS动画CSS3制作动画的几个属性：变形(transform)、转换(transition)和动画(animation)。 transform主要包括以下几种：旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix。 参考：CSS3 Transform transition主要包含四个属性值： 执行变换的属性:transition-property 变换延续的时间:transition-duration 在延续时间段、变换的速率变化:transition-timing-function 变换延迟时间:transition-delay 参考：CSS3 Transition animation主要有以下几种： animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction animation-play-state 参考：CSS3 Animation 单行超过使用省略 white-space:nowrap overflow:hidden text-overflow:ellipsis","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ice-io.github.io/tags/CSS/"}]},{"title":"前端知识总结 —— HTML篇","slug":"前端知识总结——HTML基础篇","date":"2017-08-25T14:07:50.000Z","updated":"2017-08-27T13:47:40.273Z","comments":true,"path":"2017/08/25/前端知识总结——HTML基础篇/","link":"","permalink":"http://ice-io.github.io/2017/08/25/前端知识总结——HTML基础篇/","excerpt":"从之前的不懂，到现在可以用HTML5和canvas制作一个小游戏，收获是很多的。但是，学习是一个循序渐进的过程，学而时习之，不亦说乎嘛。","text":"从之前的不懂，到现在可以用HTML5和canvas制作一个小游戏，收获是很多的。但是，学习是一个循序渐进的过程，学而时习之，不亦说乎嘛。 HTML基础结构1234567891011&lt;DOCTYPE html&gt; &lt;!--文档声明，告诉浏览器应该使用哪种规范来解析--&gt;&lt;html&gt; &lt;!--根元素，所有的元素都是其子元素--&gt; &lt;head&gt; &lt;!--head元素，包含网页的基本信息和元数据--&gt; &lt;meta charset='utf-8'&gt; &lt;!--meta元素，存放元数据，由name和http-equiv两个属性--&gt; &lt;title&gt;我是网页标题&lt;/title&gt; &lt;!--title元素，表示网页标题--&gt; &lt;/head&gt; &lt;body&gt; &lt;!--body元素，存放页面内容--&gt; &lt;h1&gt;我是内容标题&lt;/h1&gt; &lt;p&gt;我是段落&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 深入了解head元素 head元素包含网页的常规信息和元数据。 其子元素主要为三类： 描述网页基本信息 —— meta元素 指向网页渲染所需要的文件链接 —— link元素和script元素 厂商自定 —— meta元素 meta元素神通广大 meta常用于定义页面的说明，关键字，最后修改日期，和其它的元数据。这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎和其它网络服务。 meta元素共有两个属性，分别是http-equiv属性和name属性。 name属性 主要用于描述网页，比如网页的关键词，叙述等。与之对应的属性值为content，content中的内容是对name填入类型的具体描述，便于搜索引擎抓取。 meta标签中name属性语法格式是： &lt;meta name=&quot;参数&quot; content=&quot;具体的描述&quot;&gt; 取值包括：keywords(关键字)、description(网站内容的描述)、 viewport(移动端的窗口)、robots(定义搜索引擎爬虫的索引方式)、author(作者)、generator(网页制作软件)、copyright(版权)、revisit-after(搜索引擎爬虫重访时间)、renderer(双核浏览器渲染方式)。 http-equiv属性 相当于HTTP的作用，比如说定义些HTTP参数啥的。 meta标签中http-equiv属性语法格式是： &lt;meta http-equiv=&quot;参数&quot; content=&quot;具体的描述&quot;&gt; 取值包括： content-Type(设定网页字符集)(推荐使用HTML5的方式)、X-UA-Compatible(浏览器采取何种版本渲染当前页面)、cache-control(指定请求和响应遵循的缓存机制)、expires(网页到期时间)、refresh(自动刷新并指向某页面)、Set-Cookie(cookie设定)。 可参考 ：HTML meta标签总结与属性使用介绍 HTML注释 程序员圈子里面有个非常经典的笑话：“当我写下这段代码的时候，只有我和上帝能看懂。现在，只有上帝能了。” 就如有些人看文章需要做笔记一样，写代码最好也需要做笔记，这个笔记就是注释。注释主要用来解释代码的功能或逻辑，可以辅助阅读代码，当然注释内容本身是不会在浏览器中显示的。大家务必养成注释的习惯，这样即利于你日后阅读，也利于团队小伙伴阅读，否则，你的代码真的只有上帝才能看懂。 HTML注释的语法为：&lt;!-- 注释写这里 --&gt; HTML属性 为了表示元素的一些特征，我们可以在开始标签中添加一些属性。 属性特性 一般属性都具有以下特征： 每个属性之间或与元素名之间都有一个空格隔开 属性名后面紧跟等号 属性值使用双引号包裹但也有一些属性只有属性名，没有属性值，这种属性我们称之为布尔属性。除此之外，我们还可以自定义属性来存储我们的一些数据以便JavaScript使用。可参考HTML data-* 属性 属性分类 属性有很多种，从使用来说大概可以分为三类： 可以用于每个元素的全局属性，如class属性 可用于某一类元素的，如form表单相关元素的name、value属性 只用于某一个元素的，如alt属性只用于img元素 属性参考 HTML 全局属性|W3school HTML 全局属性|MDN HTML 属性参考 常用基本元素 标题元素 &lt;h1&gt; &lt;h2&gt; &lt;h3&gt; &lt;h4&gt; &lt;h5&gt; &lt;h6&gt;标签用来定义标题，其大小依次减小。&lt;h1&gt;为最大的标题，&lt;h6&gt;为最小的标题。 段落元素 &lt;p&gt;标签定义段落，每一个&lt;p&gt;标签默认都另起一行。 图片元素 &lt;img&gt;标签用来在网页中嵌入图片，该标签没有结束标签。（如这种只有一个标签的元素都可以称之为“空元素（empty element）”。 &lt;img&gt;标签有两个必需的属性：src属性 和 alt属性。其中src属性为图片地址，alt属性为如果图片加载失败显示的替换文字。 链接元素 &lt;a&gt;标签定义超链接，用于网页之间的跳转（从一个网页到另一个网页），它有一个重要的属性href，用来指定链接的目标。如果需要新标签页打开，则要添加另一个属性target。 列表元素 列表分为无序列表及有序列表两种，其中无序列表标签为&lt;ul&gt;，有序列表标签为&lt;ol&gt;，其直接的子元素标签为&lt;li&gt;(不能是其他标签)。 div元素 &lt;div&gt;标签用来分割为独立的、不同的部分，每一个&lt;div&gt;标签默认都另起一行。 span元素 &lt;span&gt;标签被用来组合文档中的行内元素。 换行元素 &lt;br&gt;标签可插入一个简单的换行符，它是个空元素，没有结束标签，不包含任何内容。 HTML字符实体预留字符 在 HTML 中，某些字符是预留的不能直接使用，如小于号（&lt;）和大于号（&gt;），直接使用会误认为它们是标签。所以如果我们希望正确地显示预留字符，那必须在 HTML 源代码中使用字符实体（character entities），如可以使用&amp;lt;表示小于号（&lt;），&amp;gt;表示大于号（&gt;）。 常用字符实体如下 显示结果 描述 实体名称 实体编号 空格 &amp;nbsp; &amp;#160; &lt; 小于号 &amp;lt; &amp;#60; &gt; 大于号 &amp;gt; &amp;#62; &amp; 和号 &amp;amp; &amp;#38; © 版权 &amp;copy; &amp;#169; × 乘号 &amp;times; &amp;#215; HTML表单表单元素本身是指&lt;form&gt;，不过它也有一个更广泛的概念，指构成表单的所有元素。首先就&lt;form&gt;元素本身来说，主要有两个属性： action：表示表单数据所提交到的处理地址（如果不知道处理地址，可先用#表示） method：表示提交内容的方式，默认取值为 get，可以设置为 post 下面正式介绍一些常用的表单元素 &lt;input&gt;元素 &lt;input&gt;元素跟&lt;img&gt;元素一样，不需要闭合标签。其常见属性如下： 12345678910111213type：必备属性，常见取值如下： text：文本输入框 password：密码输入框 search：搜索框 number：数字输入框 radio：单选按钮 checkbox：复选框 hidden：隐藏域（页面不可见，用来保存数据等） file： 上传文件 button：普通按钮 submit：提交按钮 reset：重置按钮placeholder：如为输入框时，可设置该属性，在输入框中灰色显示提示信息 &lt;textarea&gt;元素 用于多行文本输入，我们常用的评论输入框也是这个。 可以通过 cols 和 rows 属性来规定 textarea 的尺寸，不过等我们学了 CSS 之后，更好的办法是使用 CSS 的 height 和 width 属性来控制其尺寸。 &lt;select&gt;元素 用于创建选项菜单，默认只能选择一个值，可通过设置属性multiple=”multiple” 来实现多选（很少很少使用多选）。 其选项为&lt;option&gt;元素，常用有两个属性： `value`：表示选中该选项的值。 `selected`：表示默认选中。 &lt;button&gt;元素 &lt;button&gt;元素用来定义按钮，跟 input 定义的按钮不同，这个是有闭合标签的。同样也可以通过设置 type 属性来实现提交按钮和重置按钮，不过不建议这么做。一般对于提交与重置按钮，我们建议使用 input 来定义，对于普通按钮可以使用 button。 &lt;label&gt;元素 &lt;label&gt;元素用于关联表单元素的标题，可直接包裹表单元素，也可以通过设置其 for 属性关联到表单元素的 id 属性，这样点击 label 标题上关联的表单元素就 可以自动获取焦点，提升用户体验。示例如下： 1234&lt;!-- 包裹表单元素 --&gt;&lt;label&gt;用户名：&lt;input type=\"text\"&gt;&lt;/label&gt;&lt;!-- 使用for属性关联表单元素的id属性 --&gt;&lt;label for=\"username\"&gt;用户名：&lt;/label&gt;&lt;input type=\"text\" id=\"username\"&gt; 可参考：HTML Form浅析之表单属性","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://ice-io.github.io/tags/HTML/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-25T10:01:56.635Z","updated":"2017-08-26T11:48:30.085Z","comments":true,"path":"2017/08/25/hello-world/","link":"","permalink":"http://ice-io.github.io/2017/08/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}